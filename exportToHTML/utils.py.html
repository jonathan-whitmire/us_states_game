<html>
<head>
<title>utils.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
utils.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Utility function to facilitate testing. 
 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">platform</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">gc</span>
<span class="s2">import </span><span class="s1">operator</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">partial</span><span class="s2">, </span><span class="s1">wraps</span>
<span class="s2">import </span><span class="s1">shutil</span>
<span class="s2">import </span><span class="s1">contextlib</span>
<span class="s2">from </span><span class="s1">tempfile </span><span class="s2">import </span><span class="s1">mkdtemp</span><span class="s2">, </span><span class="s1">mkstemp</span>
<span class="s2">from </span><span class="s1">unittest.case </span><span class="s2">import </span><span class="s1">SkipTest</span>
<span class="s2">from </span><span class="s1">warnings </span><span class="s2">import </span><span class="s1">WarningMessage</span>
<span class="s2">import </span><span class="s1">pprint</span>

<span class="s2">from </span><span class="s1">numpy.core </span><span class="s2">import</span><span class="s1">(</span>
     <span class="s1">intp</span><span class="s2">, </span><span class="s1">float32</span><span class="s2">, </span><span class="s1">empty</span><span class="s2">, </span><span class="s1">arange</span><span class="s2">, </span><span class="s1">array_repr</span><span class="s2">, </span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">isnat</span><span class="s2">, </span><span class="s1">array)</span>
<span class="s2">import </span><span class="s1">numpy.linalg.lapack_lite</span>

<span class="s2">from </span><span class="s1">io </span><span class="s2">import </span><span class="s1">StringIO</span>

<span class="s1">__all__ = [</span>
        <span class="s3">'assert_equal'</span><span class="s2">, </span><span class="s3">'assert_almost_equal'</span><span class="s2">, </span><span class="s3">'assert_approx_equal'</span><span class="s2">,</span>
        <span class="s3">'assert_array_equal'</span><span class="s2">, </span><span class="s3">'assert_array_less'</span><span class="s2">, </span><span class="s3">'assert_string_equal'</span><span class="s2">,</span>
        <span class="s3">'assert_array_almost_equal'</span><span class="s2">, </span><span class="s3">'assert_raises'</span><span class="s2">, </span><span class="s3">'build_err_msg'</span><span class="s2">,</span>
        <span class="s3">'decorate_methods'</span><span class="s2">, </span><span class="s3">'jiffies'</span><span class="s2">, </span><span class="s3">'memusage'</span><span class="s2">, </span><span class="s3">'print_assert_equal'</span><span class="s2">,</span>
        <span class="s3">'raises'</span><span class="s2">, </span><span class="s3">'rundocs'</span><span class="s2">, </span><span class="s3">'runstring'</span><span class="s2">, </span><span class="s3">'verbose'</span><span class="s2">, </span><span class="s3">'measure'</span><span class="s2">,</span>
        <span class="s3">'assert_'</span><span class="s2">, </span><span class="s3">'assert_array_almost_equal_nulp'</span><span class="s2">, </span><span class="s3">'assert_raises_regex'</span><span class="s2">,</span>
        <span class="s3">'assert_array_max_ulp'</span><span class="s2">, </span><span class="s3">'assert_warns'</span><span class="s2">, </span><span class="s3">'assert_no_warnings'</span><span class="s2">,</span>
        <span class="s3">'assert_allclose'</span><span class="s2">, </span><span class="s3">'IgnoreException'</span><span class="s2">, </span><span class="s3">'clear_and_catch_warnings'</span><span class="s2">,</span>
        <span class="s3">'SkipTest'</span><span class="s2">, </span><span class="s3">'KnownFailureException'</span><span class="s2">, </span><span class="s3">'temppath'</span><span class="s2">, </span><span class="s3">'tempdir'</span><span class="s2">, </span><span class="s3">'IS_PYPY'</span><span class="s2">,</span>
        <span class="s3">'HAS_REFCOUNT'</span><span class="s2">, </span><span class="s3">'suppress_warnings'</span><span class="s2">, </span><span class="s3">'assert_array_compare'</span><span class="s2">,</span>
        <span class="s3">'_assert_valid_refcount'</span><span class="s2">, </span><span class="s3">'_gen_alignment_data'</span><span class="s2">, </span><span class="s3">'assert_no_gc_cycles'</span><span class="s2">,</span>
        <span class="s3">'break_cycles'</span><span class="s2">, </span><span class="s3">'HAS_LAPACK64'</span>
        <span class="s1">]</span>


<span class="s2">class </span><span class="s1">KnownFailureException(Exception):</span>
    <span class="s0">'''Raise this exception to mark a test as a known failing test.'''</span>
    <span class="s2">pass</span>


<span class="s1">KnownFailureTest = KnownFailureException  </span><span class="s4"># backwards compat</span>
<span class="s1">verbose = </span><span class="s5">0</span>

<span class="s1">IS_PYPY = platform.python_implementation() == </span><span class="s3">'PyPy'</span>
<span class="s1">HAS_REFCOUNT = getattr(sys</span><span class="s2">, </span><span class="s3">'getrefcount'</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">is not None</span>
<span class="s1">HAS_LAPACK64 = numpy.linalg.lapack_lite._ilp64</span>


<span class="s2">def </span><span class="s1">import_nose():</span>
    <span class="s0">&quot;&quot;&quot; Import nose only when needed. 
    &quot;&quot;&quot;</span>
    <span class="s1">nose_is_good = </span><span class="s2">True</span>
    <span class="s1">minimum_nose_version = (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">import </span><span class="s1">nose</span>
    <span class="s2">except </span><span class="s1">ImportError:</span>
        <span class="s1">nose_is_good = </span><span class="s2">False</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">nose.__versioninfo__ &lt; minimum_nose_version:</span>
            <span class="s1">nose_is_good = </span><span class="s2">False</span>

    <span class="s2">if not </span><span class="s1">nose_is_good:</span>
        <span class="s1">msg = (</span><span class="s3">'Need nose &gt;= %d.%d.%d for tests - see '</span>
               <span class="s3">'https://nose.readthedocs.io' </span><span class="s1">%</span>
               <span class="s1">minimum_nose_version)</span>
        <span class="s2">raise </span><span class="s1">ImportError(msg)</span>

    <span class="s2">return </span><span class="s1">nose</span>


<span class="s2">def </span><span class="s1">assert_(val</span><span class="s2">, </span><span class="s1">msg=</span><span class="s3">''</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Assert that works in release mode. 
    Accepts callable msg to allow deferring evaluation until failure. 
 
    The Python built-in ``assert`` does not work when executing code in 
    optimized mode (the ``-O`` flag) - no byte-code is generated for it. 
 
    For documentation on usage, refer to the Python documentation. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">__tracebackhide__ = </span><span class="s2">True  </span><span class="s4"># Hide traceback for py.test</span>
    <span class="s2">if not </span><span class="s1">val:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">smsg = msg()</span>
        <span class="s2">except </span><span class="s1">TypeError:</span>
            <span class="s1">smsg = msg</span>
        <span class="s2">raise </span><span class="s1">AssertionError(smsg)</span>


<span class="s2">def </span><span class="s1">gisnan(x):</span>
    <span class="s0">&quot;&quot;&quot;like isnan, but always raise an error if type not supported instead of 
    returning a TypeError object. 
 
    Notes 
    ----- 
    isnan and other ufunc sometimes return a NotImplementedType object instead 
    of raising any exception. This function is a wrapper to make sure an 
    exception is always raised. 
 
    This should be removed once this problem is solved at the Ufunc level.&quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">numpy.core </span><span class="s2">import </span><span class="s1">isnan</span>
    <span class="s1">st = isnan(x)</span>
    <span class="s2">if </span><span class="s1">isinstance(st</span><span class="s2">, </span><span class="s1">type(NotImplemented)):</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;isnan not supported for this type&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">st</span>


<span class="s2">def </span><span class="s1">gisfinite(x):</span>
    <span class="s0">&quot;&quot;&quot;like isfinite, but always raise an error if type not supported instead 
    of returning a TypeError object. 
 
    Notes 
    ----- 
    isfinite and other ufunc sometimes return a NotImplementedType object 
    instead of raising any exception. This function is a wrapper to make sure 
    an exception is always raised. 
 
    This should be removed once this problem is solved at the Ufunc level.&quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">numpy.core </span><span class="s2">import </span><span class="s1">isfinite</span><span class="s2">, </span><span class="s1">errstate</span>
    <span class="s2">with </span><span class="s1">errstate(invalid=</span><span class="s3">'ignore'</span><span class="s1">):</span>
        <span class="s1">st = isfinite(x)</span>
        <span class="s2">if </span><span class="s1">isinstance(st</span><span class="s2">, </span><span class="s1">type(NotImplemented)):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;isfinite not supported for this type&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">st</span>


<span class="s2">def </span><span class="s1">gisinf(x):</span>
    <span class="s0">&quot;&quot;&quot;like isinf, but always raise an error if type not supported instead of 
    returning a TypeError object. 
 
    Notes 
    ----- 
    isinf and other ufunc sometimes return a NotImplementedType object instead 
    of raising any exception. This function is a wrapper to make sure an 
    exception is always raised. 
 
    This should be removed once this problem is solved at the Ufunc level.&quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">numpy.core </span><span class="s2">import </span><span class="s1">isinf</span><span class="s2">, </span><span class="s1">errstate</span>
    <span class="s2">with </span><span class="s1">errstate(invalid=</span><span class="s3">'ignore'</span><span class="s1">):</span>
        <span class="s1">st = isinf(x)</span>
        <span class="s2">if </span><span class="s1">isinstance(st</span><span class="s2">, </span><span class="s1">type(NotImplemented)):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;isinf not supported for this type&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">st</span>


<span class="s2">if </span><span class="s1">os.name == </span><span class="s3">'nt'</span><span class="s1">:</span>
    <span class="s4"># Code &quot;stolen&quot; from enthought/debug/memusage.py</span>
    <span class="s2">def </span><span class="s1">GetPerformanceAttributes(object</span><span class="s2">, </span><span class="s1">counter</span><span class="s2">, </span><span class="s1">instance=</span><span class="s2">None,</span>
                                 <span class="s1">inum=-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">format=</span><span class="s2">None, </span><span class="s1">machine=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s4"># NOTE: Many counters require 2 samples to give accurate results,</span>
        <span class="s4"># including &quot;% Processor Time&quot; (as by definition, at any instant, a</span>
        <span class="s4"># thread's CPU usage is either 0 or 100).  To read counters like this,</span>
        <span class="s4"># you should copy this function, but keep the counter open, and call</span>
        <span class="s4"># CollectQueryData() each time you need to know.</span>
        <span class="s4"># See http://msdn.microsoft.com/library/en-us/dnperfmo/html/perfmonpt2.asp (dead link)</span>
        <span class="s4"># My older explanation for this was that the &quot;AddCounter&quot; process</span>
        <span class="s4"># forced the CPU to 100%, but the above makes more sense :)</span>
        <span class="s2">import </span><span class="s1">win32pdh</span>
        <span class="s2">if </span><span class="s1">format </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">format = win32pdh.PDH_FMT_LONG</span>
        <span class="s1">path = win32pdh.MakeCounterPath( (machine</span><span class="s2">, </span><span class="s1">object</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, None,</span>
                                          <span class="s1">inum</span><span class="s2">, </span><span class="s1">counter))</span>
        <span class="s1">hq = win32pdh.OpenQuery()</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">hc = win32pdh.AddCounter(hq</span><span class="s2">, </span><span class="s1">path)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">win32pdh.CollectQueryData(hq)</span>
                <span class="s1">type</span><span class="s2">, </span><span class="s1">val = win32pdh.GetFormattedCounterValue(hc</span><span class="s2">, </span><span class="s1">format)</span>
                <span class="s2">return </span><span class="s1">val</span>
            <span class="s2">finally</span><span class="s1">:</span>
                <span class="s1">win32pdh.RemoveCounter(hc)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">win32pdh.CloseQuery(hq)</span>

    <span class="s2">def </span><span class="s1">memusage(processName=</span><span class="s3">&quot;python&quot;</span><span class="s2">, </span><span class="s1">instance=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s4"># from win32pdhutil, part of the win32all package</span>
        <span class="s2">import </span><span class="s1">win32pdh</span>
        <span class="s2">return </span><span class="s1">GetPerformanceAttributes(</span><span class="s3">&quot;Process&quot;</span><span class="s2">, </span><span class="s3">&quot;Virtual Bytes&quot;</span><span class="s2">,</span>
                                        <span class="s1">processName</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">,</span>
                                        <span class="s1">win32pdh.PDH_FMT_LONG</span><span class="s2">, None</span><span class="s1">)</span>
<span class="s2">elif </span><span class="s1">sys.platform[:</span><span class="s5">5</span><span class="s1">] == </span><span class="s3">'linux'</span><span class="s1">:</span>

    <span class="s2">def </span><span class="s1">memusage(_proc_pid_stat=</span><span class="s3">f'/proc/</span><span class="s2">{</span><span class="s1">os.getpid()</span><span class="s2">}</span><span class="s3">/stat'</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return virtual memory size in bytes of the running python. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">with </span><span class="s1">open(_proc_pid_stat</span><span class="s2">, </span><span class="s3">'r'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
                <span class="s1">l = f.readline().split(</span><span class="s3">' '</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">int(l[</span><span class="s5">22</span><span class="s1">])</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s2">return</span>
<span class="s2">else</span><span class="s1">:</span>
    <span class="s2">def </span><span class="s1">memusage():</span>
        <span class="s0">&quot;&quot;&quot; 
        Return memory usage of running python. [Not implemented] 
 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>


<span class="s2">if </span><span class="s1">sys.platform[:</span><span class="s5">5</span><span class="s1">] == </span><span class="s3">'linux'</span><span class="s1">:</span>
    <span class="s2">def </span><span class="s1">jiffies(_proc_pid_stat=</span><span class="s3">f'/proc/</span><span class="s2">{</span><span class="s1">os.getpid()</span><span class="s2">}</span><span class="s3">/stat'</span><span class="s2">, </span><span class="s1">_load_time=[]):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return number of jiffies elapsed. 
 
        Return number of jiffies (1/100ths of a second) that this 
        process has been scheduled in user mode. See man 5 proc. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">import </span><span class="s1">time</span>
        <span class="s2">if not </span><span class="s1">_load_time:</span>
            <span class="s1">_load_time.append(time.time())</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">with </span><span class="s1">open(_proc_pid_stat</span><span class="s2">, </span><span class="s3">'r'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
                <span class="s1">l = f.readline().split(</span><span class="s3">' '</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">int(l[</span><span class="s5">13</span><span class="s1">])</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s2">return </span><span class="s1">int(</span><span class="s5">100</span><span class="s1">*(time.time()-_load_time[</span><span class="s5">0</span><span class="s1">]))</span>
<span class="s2">else</span><span class="s1">:</span>
    <span class="s4"># os.getpid is not in all platforms available.</span>
    <span class="s4"># Using time is safe but inaccurate, especially when process</span>
    <span class="s4"># was suspended or sleeping.</span>
    <span class="s2">def </span><span class="s1">jiffies(_load_time=[]):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return number of jiffies elapsed. 
 
        Return number of jiffies (1/100ths of a second) that this 
        process has been scheduled in user mode. See man 5 proc. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">import </span><span class="s1">time</span>
        <span class="s2">if not </span><span class="s1">_load_time:</span>
            <span class="s1">_load_time.append(time.time())</span>
        <span class="s2">return </span><span class="s1">int(</span><span class="s5">100</span><span class="s1">*(time.time()-_load_time[</span><span class="s5">0</span><span class="s1">]))</span>


<span class="s2">def </span><span class="s1">build_err_msg(arrays</span><span class="s2">, </span><span class="s1">err_msg</span><span class="s2">, </span><span class="s1">header=</span><span class="s3">'Items are not equal:'</span><span class="s2">,</span>
                  <span class="s1">verbose=</span><span class="s2">True, </span><span class="s1">names=(</span><span class="s3">'ACTUAL'</span><span class="s2">, </span><span class="s3">'DESIRED'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">precision=</span><span class="s5">8</span><span class="s1">):</span>
    <span class="s1">msg = [</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">' </span><span class="s1">+ header]</span>
    <span class="s2">if </span><span class="s1">err_msg:</span>
        <span class="s2">if </span><span class="s1">err_msg.find(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">) == -</span><span class="s5">1 </span><span class="s2">and </span><span class="s1">len(err_msg) &lt; </span><span class="s5">79</span><span class="s1">-len(header):</span>
            <span class="s1">msg = [msg[</span><span class="s5">0</span><span class="s1">] + </span><span class="s3">' ' </span><span class="s1">+ err_msg]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">msg.append(err_msg)</span>
    <span class="s2">if </span><span class="s1">verbose:</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">a </span><span class="s2">in </span><span class="s1">enumerate(arrays):</span>

            <span class="s2">if </span><span class="s1">isinstance(a</span><span class="s2">, </span><span class="s1">ndarray):</span>
                <span class="s4"># precision argument is only needed if the objects are ndarrays</span>
                <span class="s1">r_func = partial(array_repr</span><span class="s2">, </span><span class="s1">precision=precision)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">r_func = repr</span>

            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">r = r_func(a)</span>
            <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">exc:</span>
                <span class="s1">r = </span><span class="s3">f'[repr failed for &lt;</span><span class="s2">{</span><span class="s1">type(a).__name__</span><span class="s2">}</span><span class="s3">&gt;: </span><span class="s2">{</span><span class="s1">exc</span><span class="s2">}</span><span class="s3">]'</span>
            <span class="s2">if </span><span class="s1">r.count(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">) &gt; </span><span class="s5">3</span><span class="s1">:</span>
                <span class="s1">r = </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">.join(r.splitlines()[:</span><span class="s5">3</span><span class="s1">])</span>
                <span class="s1">r += </span><span class="s3">'...'</span>
            <span class="s1">msg.append(</span><span class="s3">f' </span><span class="s2">{</span><span class="s1">names[i]</span><span class="s2">}</span><span class="s3">: </span><span class="s2">{</span><span class="s1">r</span><span class="s2">}</span><span class="s3">'</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">.join(msg)</span>


<span class="s2">def </span><span class="s1">assert_equal(actual</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">err_msg=</span><span class="s3">''</span><span class="s2">, </span><span class="s1">verbose=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Raises an AssertionError if two objects are not equal. 
 
    Given two objects (scalars, lists, tuples, dictionaries or numpy arrays), 
    check that all elements of these objects are equal. An exception is raised 
    at the first conflicting values. 
 
    When one of `actual` and `desired` is a scalar and the other is array_like, 
    the function checks that each element of the array_like object is equal to 
    the scalar. 
 
    This function handles NaN comparisons as if NaN was a &quot;normal&quot; number. 
    That is, AssertionError is not raised if both objects have NaNs in the same 
    positions.  This is in contrast to the IEEE standard on NaNs, which says 
    that NaN compared to anything must return False. 
 
    Parameters 
    ---------- 
    actual : array_like 
        The object to check. 
    desired : array_like 
        The expected object. 
    err_msg : str, optional 
        The error message to be printed in case of failure. 
    verbose : bool, optional 
        If True, the conflicting values are appended to the error message. 
 
    Raises 
    ------ 
    AssertionError 
        If actual and desired are not equal. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.testing.assert_equal([4,5], [4,6]) 
    Traceback (most recent call last): 
        ... 
    AssertionError: 
    Items are not equal: 
    item=1 
     ACTUAL: 5 
     DESIRED: 6 
 
    The following comparison does not raise an exception.  There are NaNs 
    in the inputs, but they are in the same positions. 
 
    &gt;&gt;&gt; np.testing.assert_equal(np.array([1.0, 2.0, np.nan]), [1, 2, np.nan]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">__tracebackhide__ = </span><span class="s2">True  </span><span class="s4"># Hide traceback for py.test</span>
    <span class="s2">if </span><span class="s1">isinstance(desired</span><span class="s2">, </span><span class="s1">dict):</span>
        <span class="s2">if not </span><span class="s1">isinstance(actual</span><span class="s2">, </span><span class="s1">dict):</span>
            <span class="s2">raise </span><span class="s1">AssertionError(repr(type(actual)))</span>
        <span class="s1">assert_equal(len(actual)</span><span class="s2">, </span><span class="s1">len(desired)</span><span class="s2">, </span><span class="s1">err_msg</span><span class="s2">, </span><span class="s1">verbose)</span>
        <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">i </span><span class="s2">in </span><span class="s1">desired.items():</span>
            <span class="s2">if </span><span class="s1">k </span><span class="s2">not in </span><span class="s1">actual:</span>
                <span class="s2">raise </span><span class="s1">AssertionError(repr(k))</span>
            <span class="s1">assert_equal(actual[k]</span><span class="s2">, </span><span class="s1">desired[k]</span><span class="s2">, </span><span class="s3">f'key=</span><span class="s2">{</span><span class="s1">k</span><span class="s2">!r}\n{</span><span class="s1">err_msg</span><span class="s2">}</span><span class="s3">'</span><span class="s2">,</span>
                         <span class="s1">verbose)</span>
        <span class="s2">return</span>
    <span class="s2">if </span><span class="s1">isinstance(desired</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)) </span><span class="s2">and </span><span class="s1">isinstance(actual</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
        <span class="s1">assert_equal(len(actual)</span><span class="s2">, </span><span class="s1">len(desired)</span><span class="s2">, </span><span class="s1">err_msg</span><span class="s2">, </span><span class="s1">verbose)</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range(len(desired)):</span>
            <span class="s1">assert_equal(actual[k]</span><span class="s2">, </span><span class="s1">desired[k]</span><span class="s2">, </span><span class="s3">f'item=</span><span class="s2">{</span><span class="s1">k</span><span class="s2">!r}\n{</span><span class="s1">err_msg</span><span class="s2">}</span><span class="s3">'</span><span class="s2">,</span>
                         <span class="s1">verbose)</span>
        <span class="s2">return</span>
    <span class="s2">from </span><span class="s1">numpy.core </span><span class="s2">import </span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">isscalar</span><span class="s2">, </span><span class="s1">signbit</span>
    <span class="s2">from </span><span class="s1">numpy.lib </span><span class="s2">import </span><span class="s1">iscomplexobj</span><span class="s2">, </span><span class="s1">real</span><span class="s2">, </span><span class="s1">imag</span>
    <span class="s2">if </span><span class="s1">isinstance(actual</span><span class="s2">, </span><span class="s1">ndarray) </span><span class="s2">or </span><span class="s1">isinstance(desired</span><span class="s2">, </span><span class="s1">ndarray):</span>
        <span class="s2">return </span><span class="s1">assert_array_equal(actual</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">err_msg</span><span class="s2">, </span><span class="s1">verbose)</span>
    <span class="s1">msg = build_err_msg([actual</span><span class="s2">, </span><span class="s1">desired]</span><span class="s2">, </span><span class="s1">err_msg</span><span class="s2">, </span><span class="s1">verbose=verbose)</span>

    <span class="s4"># Handle complex numbers: separate into real/imag to handle</span>
    <span class="s4"># nan/inf/negative zero correctly</span>
    <span class="s4"># XXX: catch ValueError for subclasses of ndarray where iscomplex fail</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">usecomplex = iscomplexobj(actual) </span><span class="s2">or </span><span class="s1">iscomplexobj(desired)</span>
    <span class="s2">except </span><span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">TypeError):</span>
        <span class="s1">usecomplex = </span><span class="s2">False</span>

    <span class="s2">if </span><span class="s1">usecomplex:</span>
        <span class="s2">if </span><span class="s1">iscomplexobj(actual):</span>
            <span class="s1">actualr = real(actual)</span>
            <span class="s1">actuali = imag(actual)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">actualr = actual</span>
            <span class="s1">actuali = </span><span class="s5">0</span>
        <span class="s2">if </span><span class="s1">iscomplexobj(desired):</span>
            <span class="s1">desiredr = real(desired)</span>
            <span class="s1">desiredi = imag(desired)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">desiredr = desired</span>
            <span class="s1">desiredi = </span><span class="s5">0</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">assert_equal(actualr</span><span class="s2">, </span><span class="s1">desiredr)</span>
            <span class="s1">assert_equal(actuali</span><span class="s2">, </span><span class="s1">desiredi)</span>
        <span class="s2">except </span><span class="s1">AssertionError:</span>
            <span class="s2">raise </span><span class="s1">AssertionError(msg)</span>

    <span class="s4"># isscalar test to check cases such as [np.nan] != np.nan</span>
    <span class="s2">if </span><span class="s1">isscalar(desired) != isscalar(actual):</span>
        <span class="s2">raise </span><span class="s1">AssertionError(msg)</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">isdesnat = isnat(desired)</span>
        <span class="s1">isactnat = isnat(actual)</span>
        <span class="s1">dtypes_match = array(desired).dtype.type == array(actual).dtype.type</span>
        <span class="s2">if </span><span class="s1">isdesnat </span><span class="s2">and </span><span class="s1">isactnat:</span>
            <span class="s4"># If both are NaT (and have the same dtype -- datetime or</span>
            <span class="s4"># timedelta) they are considered equal.</span>
            <span class="s2">if </span><span class="s1">dtypes_match:</span>
                <span class="s2">return</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">AssertionError(msg)</span>

    <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">NotImplementedError):</span>
        <span class="s2">pass</span>

    <span class="s4"># Inf/nan/negative zero handling</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">isdesnan = gisnan(desired)</span>
        <span class="s1">isactnan = gisnan(actual)</span>
        <span class="s2">if </span><span class="s1">isdesnan </span><span class="s2">and </span><span class="s1">isactnan:</span>
            <span class="s2">return  </span><span class="s4"># both nan, so equal</span>

        <span class="s4"># handle signed zero specially for floats</span>
        <span class="s1">array_actual = array(actual)</span>
        <span class="s1">array_desired = array(desired)</span>
        <span class="s2">if </span><span class="s1">(array_actual.dtype.char </span><span class="s2">in </span><span class="s3">'Mm' </span><span class="s2">or</span>
                <span class="s1">array_desired.dtype.char </span><span class="s2">in </span><span class="s3">'Mm'</span><span class="s1">):</span>
            <span class="s4"># version 1.18</span>
            <span class="s4"># until this version, gisnan failed for datetime64 and timedelta64.</span>
            <span class="s4"># Now it succeeds but comparison to scalar with a different type</span>
            <span class="s4"># emits a DeprecationWarning.</span>
            <span class="s4"># Avoid that by skipping the next check</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">'cannot compare to a scalar '</span>
                                      <span class="s3">'with a different type'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">desired == </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">actual == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">signbit(desired) == signbit(actual):</span>
                <span class="s2">raise </span><span class="s1">AssertionError(msg)</span>

    <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">NotImplementedError):</span>
        <span class="s2">pass</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s4"># Explicitly use __eq__ for comparison, gh-2552</span>
        <span class="s2">if not </span><span class="s1">(desired == actual):</span>
            <span class="s2">raise </span><span class="s1">AssertionError(msg)</span>

    <span class="s2">except </span><span class="s1">(DeprecationWarning</span><span class="s2">, </span><span class="s1">FutureWarning) </span><span class="s2">as </span><span class="s1">e:</span>
        <span class="s4"># this handles the case when the two types are not even comparable</span>
        <span class="s2">if </span><span class="s3">'elementwise == comparison' </span><span class="s2">in </span><span class="s1">e.args[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">AssertionError(msg)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise</span>


<span class="s2">def </span><span class="s1">print_assert_equal(test_string</span><span class="s2">, </span><span class="s1">actual</span><span class="s2">, </span><span class="s1">desired):</span>
    <span class="s0">&quot;&quot;&quot; 
    Test if two objects are equal, and print an error message if test fails. 
 
    The test is performed with ``actual == desired``. 
 
    Parameters 
    ---------- 
    test_string : str 
        The message supplied to AssertionError. 
    actual : object 
        The object to test for equality against `desired`. 
    desired : object 
        The expected result. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.testing.print_assert_equal('Test XYZ of func xyz', [0, 1], [0, 1]) 
    &gt;&gt;&gt; np.testing.print_assert_equal('Test XYZ of func xyz', [0, 1], [0, 2]) 
    Traceback (most recent call last): 
    ... 
    AssertionError: Test XYZ of func xyz failed 
    ACTUAL: 
    [0, 1] 
    DESIRED: 
    [0, 2] 
 
    &quot;&quot;&quot;</span>
    <span class="s1">__tracebackhide__ = </span><span class="s2">True  </span><span class="s4"># Hide traceback for py.test</span>
    <span class="s2">import </span><span class="s1">pprint</span>

    <span class="s2">if not </span><span class="s1">(actual == desired):</span>
        <span class="s1">msg = StringIO()</span>
        <span class="s1">msg.write(test_string)</span>
        <span class="s1">msg.write(</span><span class="s3">' failed</span><span class="s2">\n</span><span class="s3">ACTUAL: </span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>
        <span class="s1">pprint.pprint(actual</span><span class="s2">, </span><span class="s1">msg)</span>
        <span class="s1">msg.write(</span><span class="s3">'DESIRED: </span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>
        <span class="s1">pprint.pprint(desired</span><span class="s2">, </span><span class="s1">msg)</span>
        <span class="s2">raise </span><span class="s1">AssertionError(msg.getvalue())</span>


<span class="s2">def </span><span class="s1">assert_almost_equal(actual</span><span class="s2">,</span><span class="s1">desired</span><span class="s2">,</span><span class="s1">decimal=</span><span class="s5">7</span><span class="s2">,</span><span class="s1">err_msg=</span><span class="s3">''</span><span class="s2">,</span><span class="s1">verbose=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Raises an AssertionError if two items are not equal up to desired 
    precision. 
 
    .. note:: It is recommended to use one of `assert_allclose`, 
              `assert_array_almost_equal_nulp` or `assert_array_max_ulp` 
              instead of this function for more consistent floating point 
              comparisons. 
 
    The test verifies that the elements of ``actual`` and ``desired`` satisfy. 
 
        ``abs(desired-actual) &lt; 1.5 * 10**(-decimal)`` 
 
    That is a looser test than originally documented, but agrees with what the 
    actual implementation in `assert_array_almost_equal` did up to rounding 
    vagaries. An exception is raised at conflicting values. For ndarrays this 
    delegates to assert_array_almost_equal 
 
    Parameters 
    ---------- 
    actual : array_like 
        The object to check. 
    desired : array_like 
        The expected object. 
    decimal : int, optional 
        Desired precision, default is 7. 
    err_msg : str, optional 
        The error message to be printed in case of failure. 
    verbose : bool, optional 
        If True, the conflicting values are appended to the error message. 
 
    Raises 
    ------ 
    AssertionError 
      If actual and desired are not equal up to specified precision. 
 
    See Also 
    -------- 
    assert_allclose: Compare two array_like objects for equality with desired 
                     relative and/or absolute precision. 
    assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy.testing as npt 
    &gt;&gt;&gt; npt.assert_almost_equal(2.3333333333333, 2.33333334) 
    &gt;&gt;&gt; npt.assert_almost_equal(2.3333333333333, 2.33333334, decimal=10) 
    Traceback (most recent call last): 
        ... 
    AssertionError: 
    Arrays are not almost equal to 10 decimals 
     ACTUAL: 2.3333333333333 
     DESIRED: 2.33333334 
 
    &gt;&gt;&gt; npt.assert_almost_equal(np.array([1.0,2.3333333333333]), 
    ...                         np.array([1.0,2.33333334]), decimal=9) 
    Traceback (most recent call last): 
        ... 
    AssertionError: 
    Arrays are not almost equal to 9 decimals 
    &lt;BLANKLINE&gt; 
    Mismatched elements: 1 / 2 (50%) 
    Max absolute difference: 6.66669964e-09 
    Max relative difference: 2.85715698e-09 
     x: array([1.         , 2.333333333]) 
     y: array([1.        , 2.33333334]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">__tracebackhide__ = </span><span class="s2">True  </span><span class="s4"># Hide traceback for py.test</span>
    <span class="s2">from </span><span class="s1">numpy.core </span><span class="s2">import </span><span class="s1">ndarray</span>
    <span class="s2">from </span><span class="s1">numpy.lib </span><span class="s2">import </span><span class="s1">iscomplexobj</span><span class="s2">, </span><span class="s1">real</span><span class="s2">, </span><span class="s1">imag</span>

    <span class="s4"># Handle complex numbers: separate into real/imag to handle</span>
    <span class="s4"># nan/inf/negative zero correctly</span>
    <span class="s4"># XXX: catch ValueError for subclasses of ndarray where iscomplex fail</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">usecomplex = iscomplexobj(actual) </span><span class="s2">or </span><span class="s1">iscomplexobj(desired)</span>
    <span class="s2">except </span><span class="s1">ValueError:</span>
        <span class="s1">usecomplex = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">_build_err_msg():</span>
        <span class="s1">header = (</span><span class="s3">'Arrays are not almost equal to %d decimals' </span><span class="s1">% decimal)</span>
        <span class="s2">return </span><span class="s1">build_err_msg([actual</span><span class="s2">, </span><span class="s1">desired]</span><span class="s2">, </span><span class="s1">err_msg</span><span class="s2">, </span><span class="s1">verbose=verbose</span><span class="s2">,</span>
                             <span class="s1">header=header)</span>

    <span class="s2">if </span><span class="s1">usecomplex:</span>
        <span class="s2">if </span><span class="s1">iscomplexobj(actual):</span>
            <span class="s1">actualr = real(actual)</span>
            <span class="s1">actuali = imag(actual)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">actualr = actual</span>
            <span class="s1">actuali = </span><span class="s5">0</span>
        <span class="s2">if </span><span class="s1">iscomplexobj(desired):</span>
            <span class="s1">desiredr = real(desired)</span>
            <span class="s1">desiredi = imag(desired)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">desiredr = desired</span>
            <span class="s1">desiredi = </span><span class="s5">0</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">assert_almost_equal(actualr</span><span class="s2">, </span><span class="s1">desiredr</span><span class="s2">, </span><span class="s1">decimal=decimal)</span>
            <span class="s1">assert_almost_equal(actuali</span><span class="s2">, </span><span class="s1">desiredi</span><span class="s2">, </span><span class="s1">decimal=decimal)</span>
        <span class="s2">except </span><span class="s1">AssertionError:</span>
            <span class="s2">raise </span><span class="s1">AssertionError(_build_err_msg())</span>

    <span class="s2">if </span><span class="s1">isinstance(actual</span><span class="s2">, </span><span class="s1">(ndarray</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">list)) \</span>
            <span class="s2">or </span><span class="s1">isinstance(desired</span><span class="s2">, </span><span class="s1">(ndarray</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">list)):</span>
        <span class="s2">return </span><span class="s1">assert_array_almost_equal(actual</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">decimal</span><span class="s2">, </span><span class="s1">err_msg)</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s4"># If one of desired/actual is not finite, handle it specially here:</span>
        <span class="s4"># check that both are nan if any is a nan, and test for equality</span>
        <span class="s4"># otherwise</span>
        <span class="s2">if not </span><span class="s1">(gisfinite(desired) </span><span class="s2">and </span><span class="s1">gisfinite(actual)):</span>
            <span class="s2">if </span><span class="s1">gisnan(desired) </span><span class="s2">or </span><span class="s1">gisnan(actual):</span>
                <span class="s2">if not </span><span class="s1">(gisnan(desired) </span><span class="s2">and </span><span class="s1">gisnan(actual)):</span>
                    <span class="s2">raise </span><span class="s1">AssertionError(_build_err_msg())</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if not </span><span class="s1">desired == actual:</span>
                    <span class="s2">raise </span><span class="s1">AssertionError(_build_err_msg())</span>
            <span class="s2">return</span>
    <span class="s2">except </span><span class="s1">(NotImplementedError</span><span class="s2">, </span><span class="s1">TypeError):</span>
        <span class="s2">pass</span>
    <span class="s2">if </span><span class="s1">abs(desired - actual) &gt;= </span><span class="s5">1.5 </span><span class="s1">* </span><span class="s5">10.0</span><span class="s1">**(-decimal):</span>
        <span class="s2">raise </span><span class="s1">AssertionError(_build_err_msg())</span>


<span class="s2">def </span><span class="s1">assert_approx_equal(actual</span><span class="s2">,</span><span class="s1">desired</span><span class="s2">,</span><span class="s1">significant=</span><span class="s5">7</span><span class="s2">,</span><span class="s1">err_msg=</span><span class="s3">''</span><span class="s2">,</span><span class="s1">verbose=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Raises an AssertionError if two items are not equal up to significant 
    digits. 
 
    .. note:: It is recommended to use one of `assert_allclose`, 
              `assert_array_almost_equal_nulp` or `assert_array_max_ulp` 
              instead of this function for more consistent floating point 
              comparisons. 
 
    Given two numbers, check that they are approximately equal. 
    Approximately equal is defined as the number of significant digits 
    that agree. 
 
    Parameters 
    ---------- 
    actual : scalar 
        The object to check. 
    desired : scalar 
        The expected object. 
    significant : int, optional 
        Desired precision, default is 7. 
    err_msg : str, optional 
        The error message to be printed in case of failure. 
    verbose : bool, optional 
        If True, the conflicting values are appended to the error message. 
 
    Raises 
    ------ 
    AssertionError 
      If actual and desired are not equal up to specified precision. 
 
    See Also 
    -------- 
    assert_allclose: Compare two array_like objects for equality with desired 
                     relative and/or absolute precision. 
    assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.testing.assert_approx_equal(0.12345677777777e-20, 0.1234567e-20) 
    &gt;&gt;&gt; np.testing.assert_approx_equal(0.12345670e-20, 0.12345671e-20, 
    ...                                significant=8) 
    &gt;&gt;&gt; np.testing.assert_approx_equal(0.12345670e-20, 0.12345672e-20, 
    ...                                significant=8) 
    Traceback (most recent call last): 
        ... 
    AssertionError: 
    Items are not equal to 8 significant digits: 
     ACTUAL: 1.234567e-21 
     DESIRED: 1.2345672e-21 
 
    the evaluated condition that raises the exception is 
 
    &gt;&gt;&gt; abs(0.12345670e-20/1e-21 - 0.12345672e-20/1e-21) &gt;= 10**-(8-1) 
    True 
 
    &quot;&quot;&quot;</span>
    <span class="s1">__tracebackhide__ = </span><span class="s2">True  </span><span class="s4"># Hide traceback for py.test</span>
    <span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

    <span class="s1">(actual</span><span class="s2">, </span><span class="s1">desired) = map(float</span><span class="s2">, </span><span class="s1">(actual</span><span class="s2">, </span><span class="s1">desired))</span>
    <span class="s2">if </span><span class="s1">desired == actual:</span>
        <span class="s2">return</span>
    <span class="s4"># Normalized the numbers to be in range (-10.0,10.0)</span>
    <span class="s4"># scale = float(pow(10,math.floor(math.log10(0.5*(abs(desired)+abs(actual))))))</span>
    <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">'ignore'</span><span class="s1">):</span>
        <span class="s1">scale = </span><span class="s5">0.5</span><span class="s1">*(np.abs(desired) + np.abs(actual))</span>
        <span class="s1">scale = np.power(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">np.floor(np.log10(scale)))</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">sc_desired = desired/scale</span>
    <span class="s2">except </span><span class="s1">ZeroDivisionError:</span>
        <span class="s1">sc_desired = </span><span class="s5">0.0</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">sc_actual = actual/scale</span>
    <span class="s2">except </span><span class="s1">ZeroDivisionError:</span>
        <span class="s1">sc_actual = </span><span class="s5">0.0</span>
    <span class="s1">msg = build_err_msg(</span>
        <span class="s1">[actual</span><span class="s2">, </span><span class="s1">desired]</span><span class="s2">, </span><span class="s1">err_msg</span><span class="s2">,</span>
        <span class="s1">header=</span><span class="s3">'Items are not equal to %d significant digits:' </span><span class="s1">% significant</span><span class="s2">,</span>
        <span class="s1">verbose=verbose)</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s4"># If one of desired/actual is not finite, handle it specially here:</span>
        <span class="s4"># check that both are nan if any is a nan, and test for equality</span>
        <span class="s4"># otherwise</span>
        <span class="s2">if not </span><span class="s1">(gisfinite(desired) </span><span class="s2">and </span><span class="s1">gisfinite(actual)):</span>
            <span class="s2">if </span><span class="s1">gisnan(desired) </span><span class="s2">or </span><span class="s1">gisnan(actual):</span>
                <span class="s2">if not </span><span class="s1">(gisnan(desired) </span><span class="s2">and </span><span class="s1">gisnan(actual)):</span>
                    <span class="s2">raise </span><span class="s1">AssertionError(msg)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if not </span><span class="s1">desired == actual:</span>
                    <span class="s2">raise </span><span class="s1">AssertionError(msg)</span>
            <span class="s2">return</span>
    <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">NotImplementedError):</span>
        <span class="s2">pass</span>
    <span class="s2">if </span><span class="s1">np.abs(sc_desired - sc_actual) &gt;= np.power(</span><span class="s5">10.</span><span class="s2">, </span><span class="s1">-(significant-</span><span class="s5">1</span><span class="s1">)):</span>
        <span class="s2">raise </span><span class="s1">AssertionError(msg)</span>


<span class="s2">def </span><span class="s1">assert_array_compare(comparison</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">err_msg=</span><span class="s3">''</span><span class="s2">, </span><span class="s1">verbose=</span><span class="s2">True, </span><span class="s1">header=</span><span class="s3">''</span><span class="s2">,</span>
                         <span class="s1">precision=</span><span class="s5">6</span><span class="s2">, </span><span class="s1">equal_nan=</span><span class="s2">True, </span><span class="s1">equal_inf=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s1">__tracebackhide__ = </span><span class="s2">True  </span><span class="s4"># Hide traceback for py.test</span>
    <span class="s2">from </span><span class="s1">numpy.core </span><span class="s2">import </span><span class="s1">array</span><span class="s2">, </span><span class="s1">array2string</span><span class="s2">, </span><span class="s1">isnan</span><span class="s2">, </span><span class="s1">inf</span><span class="s2">, </span><span class="s1">bool_</span><span class="s2">, </span><span class="s1">errstate</span><span class="s2">, </span><span class="s1">all</span><span class="s2">, </span><span class="s1">max</span><span class="s2">, </span><span class="s1">object_</span>

    <span class="s1">x = array(x</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False, </span><span class="s1">subok=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">y = array(y</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False, </span><span class="s1">subok=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s4"># original array for output formatting</span>
    <span class="s1">ox</span><span class="s2">, </span><span class="s1">oy = x</span><span class="s2">, </span><span class="s1">y</span>

    <span class="s2">def </span><span class="s1">isnumber(x):</span>
        <span class="s2">return </span><span class="s1">x.dtype.char </span><span class="s2">in </span><span class="s3">'?bhilqpBHILQPefdgFDG'</span>

    <span class="s2">def </span><span class="s1">istime(x):</span>
        <span class="s2">return </span><span class="s1">x.dtype.char </span><span class="s2">in </span><span class="s3">&quot;Mm&quot;</span>

    <span class="s2">def </span><span class="s1">func_assert_same_pos(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">func=isnan</span><span class="s2">, </span><span class="s1">hasval=</span><span class="s3">'nan'</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Handling nan/inf. 
 
        Combine results of running func on x and y, checking that they are True 
        at the same locations. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">__tracebackhide__ = </span><span class="s2">True  </span><span class="s4"># Hide traceback for py.test</span>

        <span class="s1">x_id = func(x)</span>
        <span class="s1">y_id = func(y)</span>
        <span class="s4"># We include work-arounds here to handle three types of slightly</span>
        <span class="s4"># pathological ndarray subclasses:</span>
        <span class="s4"># (1) all() on `masked` array scalars can return masked arrays, so we</span>
        <span class="s4">#     use != True</span>
        <span class="s4"># (2) __eq__ on some ndarray subclasses returns Python booleans</span>
        <span class="s4">#     instead of element-wise comparisons, so we cast to bool_() and</span>
        <span class="s4">#     use isinstance(..., bool) checks</span>
        <span class="s4"># (3) subclasses with bare-bones __array_function__ implementations may</span>
        <span class="s4">#     not implement np.all(), so favor using the .all() method</span>
        <span class="s4"># We are not committed to supporting such subclasses, but it's nice to</span>
        <span class="s4"># support them if possible.</span>
        <span class="s2">if </span><span class="s1">bool_(x_id == y_id).all() != </span><span class="s2">True</span><span class="s1">:</span>
            <span class="s1">msg = build_err_msg([x</span><span class="s2">, </span><span class="s1">y]</span><span class="s2">,</span>
                                <span class="s1">err_msg + </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">x and y %s location mismatch:'</span>
                                <span class="s1">% (hasval)</span><span class="s2">, </span><span class="s1">verbose=verbose</span><span class="s2">, </span><span class="s1">header=header</span><span class="s2">,</span>
                                <span class="s1">names=(</span><span class="s3">'x'</span><span class="s2">, </span><span class="s3">'y'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">precision=precision)</span>
            <span class="s2">raise </span><span class="s1">AssertionError(msg)</span>
        <span class="s4"># If there is a scalar, then here we know the array has the same</span>
        <span class="s4"># flag as it everywhere, so we should return the scalar flag.</span>
        <span class="s2">if </span><span class="s1">isinstance(x_id</span><span class="s2">, </span><span class="s1">bool) </span><span class="s2">or </span><span class="s1">x_id.ndim == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">bool_(x_id)</span>
        <span class="s2">elif </span><span class="s1">isinstance(y_id</span><span class="s2">, </span><span class="s1">bool) </span><span class="s2">or </span><span class="s1">y_id.ndim == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">bool_(y_id)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">y_id</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">cond = (x.shape == () </span><span class="s2">or </span><span class="s1">y.shape == ()) </span><span class="s2">or </span><span class="s1">x.shape == y.shape</span>
        <span class="s2">if not </span><span class="s1">cond:</span>
            <span class="s1">msg = build_err_msg([x</span><span class="s2">, </span><span class="s1">y]</span><span class="s2">,</span>
                                <span class="s1">err_msg</span>
                                <span class="s1">+ </span><span class="s3">f'</span><span class="s2">\n</span><span class="s3">(shapes </span><span class="s2">{</span><span class="s1">x.shape</span><span class="s2">}</span><span class="s3">, </span><span class="s2">{</span><span class="s1">y.shape</span><span class="s2">} </span><span class="s3">mismatch)'</span><span class="s2">,</span>
                                <span class="s1">verbose=verbose</span><span class="s2">, </span><span class="s1">header=header</span><span class="s2">,</span>
                                <span class="s1">names=(</span><span class="s3">'x'</span><span class="s2">, </span><span class="s3">'y'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">precision=precision)</span>
            <span class="s2">raise </span><span class="s1">AssertionError(msg)</span>

        <span class="s1">flagged = bool_(</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">isnumber(x) </span><span class="s2">and </span><span class="s1">isnumber(y):</span>
            <span class="s2">if </span><span class="s1">equal_nan:</span>
                <span class="s1">flagged = func_assert_same_pos(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">func=isnan</span><span class="s2">, </span><span class="s1">hasval=</span><span class="s3">'nan'</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">equal_inf:</span>
                <span class="s1">flagged |= func_assert_same_pos(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">,</span>
                                                <span class="s1">func=</span><span class="s2">lambda </span><span class="s1">xy: xy == +inf</span><span class="s2">,</span>
                                                <span class="s1">hasval=</span><span class="s3">'+inf'</span><span class="s1">)</span>
                <span class="s1">flagged |= func_assert_same_pos(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">,</span>
                                                <span class="s1">func=</span><span class="s2">lambda </span><span class="s1">xy: xy == -inf</span><span class="s2">,</span>
                                                <span class="s1">hasval=</span><span class="s3">'-inf'</span><span class="s1">)</span>

        <span class="s2">elif </span><span class="s1">istime(x) </span><span class="s2">and </span><span class="s1">istime(y):</span>
            <span class="s4"># If one is datetime64 and the other timedelta64 there is no point</span>
            <span class="s2">if </span><span class="s1">equal_nan </span><span class="s2">and </span><span class="s1">x.dtype.type == y.dtype.type:</span>
                <span class="s1">flagged = func_assert_same_pos(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">func=isnat</span><span class="s2">, </span><span class="s1">hasval=</span><span class="s3">&quot;NaT&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">flagged.ndim &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">y = x[~flagged]</span><span class="s2">, </span><span class="s1">y[~flagged]</span>
            <span class="s4"># Only do the comparison if actual values are left</span>
            <span class="s2">if </span><span class="s1">x.size == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">return</span>
        <span class="s2">elif </span><span class="s1">flagged:</span>
            <span class="s4"># no sense doing comparison if everything is flagged.</span>
            <span class="s2">return</span>

        <span class="s1">val = comparison(x</span><span class="s2">, </span><span class="s1">y)</span>

        <span class="s2">if </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">bool):</span>
            <span class="s1">cond = val</span>
            <span class="s1">reduced = array([val])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">reduced = val.ravel()</span>
            <span class="s1">cond = reduced.all()</span>

        <span class="s4"># The below comparison is a hack to ensure that fully masked</span>
        <span class="s4"># results, for which val.ravel().all() returns np.ma.masked,</span>
        <span class="s4"># do not trigger a failure (np.ma.masked != True evaluates as</span>
        <span class="s4"># np.ma.masked, which is falsy).</span>
        <span class="s2">if </span><span class="s1">cond != </span><span class="s2">True</span><span class="s1">:</span>
            <span class="s1">n_mismatch = reduced.size - reduced.sum(dtype=intp)</span>
            <span class="s1">n_elements = flagged.size </span><span class="s2">if </span><span class="s1">flagged.ndim != </span><span class="s5">0 </span><span class="s2">else </span><span class="s1">reduced.size</span>
            <span class="s1">percent_mismatch = </span><span class="s5">100 </span><span class="s1">* n_mismatch / n_elements</span>
            <span class="s1">remarks = [</span>
                <span class="s3">'Mismatched elements: {} / {} ({:.3g}%)'</span><span class="s1">.format(</span>
                    <span class="s1">n_mismatch</span><span class="s2">, </span><span class="s1">n_elements</span><span class="s2">, </span><span class="s1">percent_mismatch)]</span>

            <span class="s2">with </span><span class="s1">errstate(invalid=</span><span class="s3">'ignore'</span><span class="s2">, </span><span class="s1">divide=</span><span class="s3">'ignore'</span><span class="s1">):</span>
                <span class="s4"># ignore errors for non-numeric types</span>
                <span class="s2">with </span><span class="s1">contextlib.suppress(TypeError):</span>
                    <span class="s1">error = abs(x - y)</span>
                    <span class="s1">max_abs_error = max(error)</span>
                    <span class="s2">if </span><span class="s1">getattr(error</span><span class="s2">, </span><span class="s3">'dtype'</span><span class="s2">, </span><span class="s1">object_) == object_:</span>
                        <span class="s1">remarks.append(</span><span class="s3">'Max absolute difference: '</span>
                                        <span class="s1">+ str(max_abs_error))</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">remarks.append(</span><span class="s3">'Max absolute difference: '</span>
                                        <span class="s1">+ array2string(max_abs_error))</span>

                    <span class="s4"># note: this definition of relative error matches that one</span>
                    <span class="s4"># used by assert_allclose (found in np.isclose)</span>
                    <span class="s4"># Filter values where the divisor would be zero</span>
                    <span class="s1">nonzero = bool_(y != </span><span class="s5">0</span><span class="s1">)</span>
                    <span class="s2">if </span><span class="s1">all(~nonzero):</span>
                        <span class="s1">max_rel_error = array(inf)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">max_rel_error = max(error[nonzero] / abs(y[nonzero]))</span>
                    <span class="s2">if </span><span class="s1">getattr(error</span><span class="s2">, </span><span class="s3">'dtype'</span><span class="s2">, </span><span class="s1">object_) == object_:</span>
                        <span class="s1">remarks.append(</span><span class="s3">'Max relative difference: '</span>
                                        <span class="s1">+ str(max_rel_error))</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">remarks.append(</span><span class="s3">'Max relative difference: '</span>
                                        <span class="s1">+ array2string(max_rel_error))</span>

            <span class="s1">err_msg += </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">.join(remarks)</span>
            <span class="s1">msg = build_err_msg([ox</span><span class="s2">, </span><span class="s1">oy]</span><span class="s2">, </span><span class="s1">err_msg</span><span class="s2">,</span>
                                <span class="s1">verbose=verbose</span><span class="s2">, </span><span class="s1">header=header</span><span class="s2">,</span>
                                <span class="s1">names=(</span><span class="s3">'x'</span><span class="s2">, </span><span class="s3">'y'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">precision=precision)</span>
            <span class="s2">raise </span><span class="s1">AssertionError(msg)</span>
    <span class="s2">except </span><span class="s1">ValueError:</span>
        <span class="s2">import </span><span class="s1">traceback</span>
        <span class="s1">efmt = traceback.format_exc()</span>
        <span class="s1">header = </span><span class="s3">f'error during assertion:</span><span class="s2">\n\n{</span><span class="s1">efmt</span><span class="s2">}\n\n{</span><span class="s1">header</span><span class="s2">}</span><span class="s3">'</span>

        <span class="s1">msg = build_err_msg([x</span><span class="s2">, </span><span class="s1">y]</span><span class="s2">, </span><span class="s1">err_msg</span><span class="s2">, </span><span class="s1">verbose=verbose</span><span class="s2">, </span><span class="s1">header=header</span><span class="s2">,</span>
                            <span class="s1">names=(</span><span class="s3">'x'</span><span class="s2">, </span><span class="s3">'y'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">precision=precision)</span>
        <span class="s2">raise </span><span class="s1">ValueError(msg)</span>


<span class="s2">def </span><span class="s1">assert_array_equal(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">err_msg=</span><span class="s3">''</span><span class="s2">, </span><span class="s1">verbose=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Raises an AssertionError if two array_like objects are not equal. 
 
    Given two array_like objects, check that the shape is equal and all 
    elements of these objects are equal (but see the Notes for the special 
    handling of a scalar). An exception is raised at shape mismatch or 
    conflicting values. In contrast to the standard usage in numpy, NaNs 
    are compared like numbers, no assertion is raised if both objects have 
    NaNs in the same positions. 
 
    The usual caution for verifying equality with floating point numbers is 
    advised. 
 
    Parameters 
    ---------- 
    x : array_like 
        The actual object to check. 
    y : array_like 
        The desired, expected object. 
    err_msg : str, optional 
        The error message to be printed in case of failure. 
    verbose : bool, optional 
        If True, the conflicting values are appended to the error message. 
 
    Raises 
    ------ 
    AssertionError 
        If actual and desired objects are not equal. 
 
    See Also 
    -------- 
    assert_allclose: Compare two array_like objects for equality with desired 
                     relative and/or absolute precision. 
    assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal 
 
    Notes 
    ----- 
    When one of `x` and `y` is a scalar and the other is array_like, the 
    function checks that each element of the array_like object is equal to 
    the scalar. 
 
    Examples 
    -------- 
    The first assert does not raise an exception: 
 
    &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan], 
    ...                               [np.exp(0),2.33333, np.nan]) 
 
    Assert fails with numerical imprecision with floats: 
 
    &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan], 
    ...                               [1, np.sqrt(np.pi)**2, np.nan]) 
    Traceback (most recent call last): 
        ... 
    AssertionError: 
    Arrays are not equal 
    &lt;BLANKLINE&gt; 
    Mismatched elements: 1 / 3 (33.3%) 
    Max absolute difference: 4.4408921e-16 
    Max relative difference: 1.41357986e-16 
     x: array([1.      , 3.141593,      nan]) 
     y: array([1.      , 3.141593,      nan]) 
 
    Use `assert_allclose` or one of the nulp (number of floating point values) 
    functions for these cases instead: 
 
    &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan], 
    ...                            [1, np.sqrt(np.pi)**2, np.nan], 
    ...                            rtol=1e-10, atol=0) 
 
    As mentioned in the Notes section, `assert_array_equal` has special 
    handling for scalars. Here the test checks that each value in `x` is 3: 
 
    &gt;&gt;&gt; x = np.full((2, 5), fill_value=3) 
    &gt;&gt;&gt; np.testing.assert_array_equal(x, 3) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">__tracebackhide__ = </span><span class="s2">True  </span><span class="s4"># Hide traceback for py.test</span>
    <span class="s1">assert_array_compare(operator.__eq__</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">err_msg=err_msg</span><span class="s2">,</span>
                         <span class="s1">verbose=verbose</span><span class="s2">, </span><span class="s1">header=</span><span class="s3">'Arrays are not equal'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">assert_array_almost_equal(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s5">6</span><span class="s2">, </span><span class="s1">err_msg=</span><span class="s3">''</span><span class="s2">, </span><span class="s1">verbose=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Raises an AssertionError if two objects are not equal up to desired 
    precision. 
 
    .. note:: It is recommended to use one of `assert_allclose`, 
              `assert_array_almost_equal_nulp` or `assert_array_max_ulp` 
              instead of this function for more consistent floating point 
              comparisons. 
 
    The test verifies identical shapes and that the elements of ``actual`` and 
    ``desired`` satisfy. 
 
        ``abs(desired-actual) &lt; 1.5 * 10**(-decimal)`` 
 
    That is a looser test than originally documented, but agrees with what the 
    actual implementation did up to rounding vagaries. An exception is raised 
    at shape mismatch or conflicting values. In contrast to the standard usage 
    in numpy, NaNs are compared like numbers, no assertion is raised if both 
    objects have NaNs in the same positions. 
 
    Parameters 
    ---------- 
    x : array_like 
        The actual object to check. 
    y : array_like 
        The desired, expected object. 
    decimal : int, optional 
        Desired precision, default is 6. 
    err_msg : str, optional 
      The error message to be printed in case of failure. 
    verbose : bool, optional 
        If True, the conflicting values are appended to the error message. 
 
    Raises 
    ------ 
    AssertionError 
        If actual and desired are not equal up to specified precision. 
 
    See Also 
    -------- 
    assert_allclose: Compare two array_like objects for equality with desired 
                     relative and/or absolute precision. 
    assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal 
 
    Examples 
    -------- 
    the first assert does not raise an exception 
 
    &gt;&gt;&gt; np.testing.assert_array_almost_equal([1.0,2.333,np.nan], 
    ...                                      [1.0,2.333,np.nan]) 
 
    &gt;&gt;&gt; np.testing.assert_array_almost_equal([1.0,2.33333,np.nan], 
    ...                                      [1.0,2.33339,np.nan], decimal=5) 
    Traceback (most recent call last): 
        ... 
    AssertionError: 
    Arrays are not almost equal to 5 decimals 
    &lt;BLANKLINE&gt; 
    Mismatched elements: 1 / 3 (33.3%) 
    Max absolute difference: 6.e-05 
    Max relative difference: 2.57136612e-05 
     x: array([1.     , 2.33333,     nan]) 
     y: array([1.     , 2.33339,     nan]) 
 
    &gt;&gt;&gt; np.testing.assert_array_almost_equal([1.0,2.33333,np.nan], 
    ...                                      [1.0,2.33333, 5], decimal=5) 
    Traceback (most recent call last): 
        ... 
    AssertionError: 
    Arrays are not almost equal to 5 decimals 
    &lt;BLANKLINE&gt; 
    x and y nan location mismatch: 
     x: array([1.     , 2.33333,     nan]) 
     y: array([1.     , 2.33333, 5.     ]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">__tracebackhide__ = </span><span class="s2">True  </span><span class="s4"># Hide traceback for py.test</span>
    <span class="s2">from </span><span class="s1">numpy.core </span><span class="s2">import </span><span class="s1">number</span><span class="s2">, </span><span class="s1">float_</span><span class="s2">, </span><span class="s1">result_type</span><span class="s2">, </span><span class="s1">array</span>
    <span class="s2">from </span><span class="s1">numpy.core.numerictypes </span><span class="s2">import </span><span class="s1">issubdtype</span>
    <span class="s2">from </span><span class="s1">numpy.core.fromnumeric </span><span class="s2">import </span><span class="s1">any </span><span class="s2">as </span><span class="s1">npany</span>

    <span class="s2">def </span><span class="s1">compare(x</span><span class="s2">, </span><span class="s1">y):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">npany(gisinf(x)) </span><span class="s2">or </span><span class="s1">npany( gisinf(y)):</span>
                <span class="s1">xinfid = gisinf(x)</span>
                <span class="s1">yinfid = gisinf(y)</span>
                <span class="s2">if not </span><span class="s1">(xinfid == yinfid).all():</span>
                    <span class="s2">return False</span>
                <span class="s4"># if one item, x and y is +- inf</span>
                <span class="s2">if </span><span class="s1">x.size == y.size == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">x == y</span>
                <span class="s1">x = x[~xinfid]</span>
                <span class="s1">y = y[~yinfid]</span>
        <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">NotImplementedError):</span>
            <span class="s2">pass</span>

        <span class="s4"># make sure y is an inexact type to avoid abs(MIN_INT); will cause</span>
        <span class="s4"># casting of x later.</span>
        <span class="s1">dtype = result_type(y</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">)</span>
        <span class="s1">y = array(y</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False, </span><span class="s1">subok=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">z = abs(x - y)</span>

        <span class="s2">if not </span><span class="s1">issubdtype(z.dtype</span><span class="s2">, </span><span class="s1">number):</span>
            <span class="s1">z = z.astype(float_)  </span><span class="s4"># handle object arrays</span>

        <span class="s2">return </span><span class="s1">z &lt; </span><span class="s5">1.5 </span><span class="s1">* </span><span class="s5">10.0</span><span class="s1">**(-decimal)</span>

    <span class="s1">assert_array_compare(compare</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">err_msg=err_msg</span><span class="s2">, </span><span class="s1">verbose=verbose</span><span class="s2">,</span>
             <span class="s1">header=(</span><span class="s3">'Arrays are not almost equal to %d decimals' </span><span class="s1">% decimal)</span><span class="s2">,</span>
             <span class="s1">precision=decimal)</span>


<span class="s2">def </span><span class="s1">assert_array_less(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">err_msg=</span><span class="s3">''</span><span class="s2">, </span><span class="s1">verbose=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Raises an AssertionError if two array_like objects are not ordered by less 
    than. 
 
    Given two array_like objects, check that the shape is equal and all 
    elements of the first object are strictly smaller than those of the 
    second object. An exception is raised at shape mismatch or incorrectly 
    ordered values. Shape mismatch does not raise if an object has zero 
    dimension. In contrast to the standard usage in numpy, NaNs are 
    compared, no assertion is raised if both objects have NaNs in the same 
    positions. 
 
 
 
    Parameters 
    ---------- 
    x : array_like 
      The smaller object to check. 
    y : array_like 
      The larger object to compare. 
    err_msg : string 
      The error message to be printed in case of failure. 
    verbose : bool 
        If True, the conflicting values are appended to the error message. 
 
    Raises 
    ------ 
    AssertionError 
      If actual and desired objects are not equal. 
 
    See Also 
    -------- 
    assert_array_equal: tests objects for equality 
    assert_array_almost_equal: test objects for equality up to precision 
 
 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.testing.assert_array_less([1.0, 1.0, np.nan], [1.1, 2.0, np.nan]) 
    &gt;&gt;&gt; np.testing.assert_array_less([1.0, 1.0, np.nan], [1, 2.0, np.nan]) 
    Traceback (most recent call last): 
        ... 
    AssertionError: 
    Arrays are not less-ordered 
    &lt;BLANKLINE&gt; 
    Mismatched elements: 1 / 3 (33.3%) 
    Max absolute difference: 1. 
    Max relative difference: 0.5 
     x: array([ 1.,  1., nan]) 
     y: array([ 1.,  2., nan]) 
 
    &gt;&gt;&gt; np.testing.assert_array_less([1.0, 4.0], 3) 
    Traceback (most recent call last): 
        ... 
    AssertionError: 
    Arrays are not less-ordered 
    &lt;BLANKLINE&gt; 
    Mismatched elements: 1 / 2 (50%) 
    Max absolute difference: 2. 
    Max relative difference: 0.66666667 
     x: array([1., 4.]) 
     y: array(3) 
 
    &gt;&gt;&gt; np.testing.assert_array_less([1.0, 2.0, 3.0], [4]) 
    Traceback (most recent call last): 
        ... 
    AssertionError: 
    Arrays are not less-ordered 
    &lt;BLANKLINE&gt; 
    (shapes (3,), (1,) mismatch) 
     x: array([1., 2., 3.]) 
     y: array([4]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">__tracebackhide__ = </span><span class="s2">True  </span><span class="s4"># Hide traceback for py.test</span>
    <span class="s1">assert_array_compare(operator.__lt__</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">err_msg=err_msg</span><span class="s2">,</span>
                         <span class="s1">verbose=verbose</span><span class="s2">,</span>
                         <span class="s1">header=</span><span class="s3">'Arrays are not less-ordered'</span><span class="s2">,</span>
                         <span class="s1">equal_inf=</span><span class="s2">False</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">runstring(astr</span><span class="s2">, </span><span class="s1">dict):</span>
    <span class="s1">exec(astr</span><span class="s2">, </span><span class="s1">dict)</span>


<span class="s2">def </span><span class="s1">assert_string_equal(actual</span><span class="s2">, </span><span class="s1">desired):</span>
    <span class="s0">&quot;&quot;&quot; 
    Test if two strings are equal. 
 
    If the given strings are equal, `assert_string_equal` does nothing. 
    If they are not equal, an AssertionError is raised, and the diff 
    between the strings is shown. 
 
    Parameters 
    ---------- 
    actual : str 
        The string to test for equality against the expected string. 
    desired : str 
        The expected string. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.testing.assert_string_equal('abc', 'abc') 
    &gt;&gt;&gt; np.testing.assert_string_equal('abc', 'abcd') 
    Traceback (most recent call last): 
      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; 
    ... 
    AssertionError: Differences in strings: 
    - abc+ abcd?    + 
 
    &quot;&quot;&quot;</span>
    <span class="s4"># delay import of difflib to reduce startup time</span>
    <span class="s1">__tracebackhide__ = </span><span class="s2">True  </span><span class="s4"># Hide traceback for py.test</span>
    <span class="s2">import </span><span class="s1">difflib</span>

    <span class="s2">if not </span><span class="s1">isinstance(actual</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s2">raise </span><span class="s1">AssertionError(repr(type(actual)))</span>
    <span class="s2">if not </span><span class="s1">isinstance(desired</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s2">raise </span><span class="s1">AssertionError(repr(type(desired)))</span>
    <span class="s2">if </span><span class="s1">desired == actual:</span>
        <span class="s2">return</span>

    <span class="s1">diff = list(difflib.Differ().compare(actual.splitlines(</span><span class="s2">True</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">desired.splitlines(</span><span class="s2">True</span><span class="s1">)))</span>
    <span class="s1">diff_list = []</span>
    <span class="s2">while </span><span class="s1">diff:</span>
        <span class="s1">d1 = diff.pop(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">d1.startswith(</span><span class="s3">'  '</span><span class="s1">):</span>
            <span class="s2">continue</span>
        <span class="s2">if </span><span class="s1">d1.startswith(</span><span class="s3">'- '</span><span class="s1">):</span>
            <span class="s1">l = [d1]</span>
            <span class="s1">d2 = diff.pop(</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">d2.startswith(</span><span class="s3">'? '</span><span class="s1">):</span>
                <span class="s1">l.append(d2)</span>
                <span class="s1">d2 = diff.pop(</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">d2.startswith(</span><span class="s3">'+ '</span><span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">AssertionError(repr(d2))</span>
            <span class="s1">l.append(d2)</span>
            <span class="s2">if </span><span class="s1">diff:</span>
                <span class="s1">d3 = diff.pop(</span><span class="s5">0</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">d3.startswith(</span><span class="s3">'? '</span><span class="s1">):</span>
                    <span class="s1">l.append(d3)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">diff.insert(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">d3)</span>
            <span class="s2">if </span><span class="s1">d2[</span><span class="s5">2</span><span class="s1">:] == d1[</span><span class="s5">2</span><span class="s1">:]:</span>
                <span class="s2">continue</span>
            <span class="s1">diff_list.extend(l)</span>
            <span class="s2">continue</span>
        <span class="s2">raise </span><span class="s1">AssertionError(repr(d1))</span>
    <span class="s2">if not </span><span class="s1">diff_list:</span>
        <span class="s2">return</span>
    <span class="s1">msg = </span><span class="s3">f&quot;Differences in strings:</span><span class="s2">\n{</span><span class="s3">''</span><span class="s1">.join(diff_list).rstrip()</span><span class="s2">}</span><span class="s3">&quot;</span>
    <span class="s2">if </span><span class="s1">actual != desired:</span>
        <span class="s2">raise </span><span class="s1">AssertionError(msg)</span>


<span class="s2">def </span><span class="s1">rundocs(filename=</span><span class="s2">None, </span><span class="s1">raise_on_error=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Run doctests found in the given file. 
 
    By default `rundocs` raises an AssertionError on failure. 
 
    Parameters 
    ---------- 
    filename : str 
        The path to the file for which the doctests are run. 
    raise_on_error : bool 
        Whether to raise an AssertionError when a doctest fails. Default is 
        True. 
 
    Notes 
    ----- 
    The doctests can be run by the user/developer by adding the ``doctests`` 
    argument to the ``test()`` call. For example, to run all tests (including 
    doctests) for `numpy.lib`: 
 
    &gt;&gt;&gt; np.lib.test(doctests=True)  # doctest: +SKIP 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">numpy.compat </span><span class="s2">import </span><span class="s1">npy_load_module</span>
    <span class="s2">import </span><span class="s1">doctest</span>
    <span class="s2">if </span><span class="s1">filename </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">f = sys._getframe(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">filename = f.f_globals[</span><span class="s3">'__file__'</span><span class="s1">]</span>
    <span class="s1">name = os.path.splitext(os.path.basename(filename))[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">m = npy_load_module(name</span><span class="s2">, </span><span class="s1">filename)</span>

    <span class="s1">tests = doctest.DocTestFinder().find(m)</span>
    <span class="s1">runner = doctest.DocTestRunner(verbose=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s1">msg = []</span>
    <span class="s2">if </span><span class="s1">raise_on_error:</span>
        <span class="s1">out = </span><span class="s2">lambda </span><span class="s1">s: msg.append(s)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">out = </span><span class="s2">None</span>

    <span class="s2">for </span><span class="s1">test </span><span class="s2">in </span><span class="s1">tests:</span>
        <span class="s1">runner.run(test</span><span class="s2">, </span><span class="s1">out=out)</span>

    <span class="s2">if </span><span class="s1">runner.failures &gt; </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">raise_on_error:</span>
        <span class="s2">raise </span><span class="s1">AssertionError(</span><span class="s3">&quot;Some doctests failed:</span><span class="s2">\n</span><span class="s3">%s&quot; </span><span class="s1">% </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join(msg))</span>


<span class="s2">def </span><span class="s1">raises(*args):</span>
    <span class="s0">&quot;&quot;&quot;Decorator to check for raised exceptions. 
 
    The decorated test function must raise one of the passed exceptions to 
    pass.  If you want to test many assertions about exceptions in a single 
    test, you may want to use `assert_raises` instead. 
 
    .. warning:: 
       This decorator is nose specific, do not use it if you are using a 
       different test framework. 
 
    Parameters 
    ---------- 
    args : exceptions 
        The test passes if any of the passed exceptions is raised. 
 
    Raises 
    ------ 
    AssertionError 
 
    Examples 
    -------- 
 
    Usage:: 
 
        @raises(TypeError, ValueError) 
        def test_raises_type_error(): 
            raise TypeError(&quot;This test passes&quot;) 
 
        @raises(Exception) 
        def test_that_fails_by_passing(): 
            pass 
 
    &quot;&quot;&quot;</span>
    <span class="s1">nose = import_nose()</span>
    <span class="s2">return </span><span class="s1">nose.tools.raises(*args)</span>

<span class="s4">#</span>
<span class="s4"># assert_raises and assert_raises_regex are taken from unittest.</span>
<span class="s4">#</span>
<span class="s2">import </span><span class="s1">unittest</span>


<span class="s2">class </span><span class="s1">_Dummy(unittest.TestCase):</span>
    <span class="s2">def </span><span class="s1">nop(self):</span>
        <span class="s2">pass</span>

<span class="s1">_d = _Dummy(</span><span class="s3">'nop'</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">assert_raises(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    assert_raises(exception_class, callable, *args, **kwargs) 
    assert_raises(exception_class) 
 
    Fail unless an exception of class exception_class is thrown 
    by callable when invoked with arguments args and keyword 
    arguments kwargs. If a different type of exception is 
    thrown, it will not be caught, and the test case will be 
    deemed to have suffered an error, exactly as for an 
    unexpected exception. 
 
    Alternatively, `assert_raises` can be used as a context manager: 
 
    &gt;&gt;&gt; from numpy.testing import assert_raises 
    &gt;&gt;&gt; with assert_raises(ZeroDivisionError): 
    ...     1 / 0 
 
    is equivalent to 
 
    &gt;&gt;&gt; def div(x, y): 
    ...     return x / y 
    &gt;&gt;&gt; assert_raises(ZeroDivisionError, div, 1, 0) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">__tracebackhide__ = </span><span class="s2">True  </span><span class="s4"># Hide traceback for py.test</span>
    <span class="s2">return </span><span class="s1">_d.assertRaises(*args</span><span class="s2">,</span><span class="s1">**kwargs)</span>


<span class="s2">def </span><span class="s1">assert_raises_regex(exception_class</span><span class="s2">, </span><span class="s1">expected_regexp</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    assert_raises_regex(exception_class, expected_regexp, callable, *args, 
                        **kwargs) 
    assert_raises_regex(exception_class, expected_regexp) 
 
    Fail unless an exception of class exception_class and with message that 
    matches expected_regexp is thrown by callable when invoked with arguments 
    args and keyword arguments kwargs. 
 
    Alternatively, can be used as a context manager like `assert_raises`. 
 
    Name of this function adheres to Python 3.2+ reference, but should work in 
    all versions down to 2.6. 
 
    Notes 
    ----- 
    .. versionadded:: 1.9.0 
 
    &quot;&quot;&quot;</span>
    <span class="s1">__tracebackhide__ = </span><span class="s2">True  </span><span class="s4"># Hide traceback for py.test</span>
    <span class="s2">return </span><span class="s1">_d.assertRaisesRegex(exception_class</span><span class="s2">, </span><span class="s1">expected_regexp</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">def </span><span class="s1">decorate_methods(cls</span><span class="s2">, </span><span class="s1">decorator</span><span class="s2">, </span><span class="s1">testmatch=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Apply a decorator to all methods in a class matching a regular expression. 
 
    The given decorator is applied to all public methods of `cls` that are 
    matched by the regular expression `testmatch` 
    (``testmatch.search(methodname)``). Methods that are private, i.e. start 
    with an underscore, are ignored. 
 
    Parameters 
    ---------- 
    cls : class 
        Class whose methods to decorate. 
    decorator : function 
        Decorator to apply to methods 
    testmatch : compiled regexp or str, optional 
        The regular expression. Default value is None, in which case the 
        nose default (``re.compile(r'(?:^|[\\b_\\.%s-])[Tt]est' % os.sep)``) 
        is used. 
        If `testmatch` is a string, it is compiled to a regular expression 
        first. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">testmatch </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">testmatch = re.compile(</span><span class="s3">r'(?:^|[\\b_\\.%s-])[Tt]est' </span><span class="s1">% os.sep)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">testmatch = re.compile(testmatch)</span>
    <span class="s1">cls_attr = cls.__dict__</span>

    <span class="s4"># delayed import to reduce startup time</span>
    <span class="s2">from </span><span class="s1">inspect </span><span class="s2">import </span><span class="s1">isfunction</span>

    <span class="s1">methods = [_m </span><span class="s2">for </span><span class="s1">_m </span><span class="s2">in </span><span class="s1">cls_attr.values() </span><span class="s2">if </span><span class="s1">isfunction(_m)]</span>
    <span class="s2">for </span><span class="s1">function </span><span class="s2">in </span><span class="s1">methods:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">hasattr(function</span><span class="s2">, </span><span class="s3">'compat_func_name'</span><span class="s1">):</span>
                <span class="s1">funcname = function.compat_func_name</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">funcname = function.__name__</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s4"># not a function</span>
            <span class="s2">continue</span>
        <span class="s2">if </span><span class="s1">testmatch.search(funcname) </span><span class="s2">and not </span><span class="s1">funcname.startswith(</span><span class="s3">'_'</span><span class="s1">):</span>
            <span class="s1">setattr(cls</span><span class="s2">, </span><span class="s1">funcname</span><span class="s2">, </span><span class="s1">decorator(function))</span>
    <span class="s2">return</span>


<span class="s2">def </span><span class="s1">measure(code_str</span><span class="s2">, </span><span class="s1">times=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">label=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return elapsed time for executing code in the namespace of the caller. 
 
    The supplied code string is compiled with the Python builtin ``compile``. 
    The precision of the timing is 10 milli-seconds. If the code will execute 
    fast on this timescale, it can be executed many times to get reasonable 
    timing accuracy. 
 
    Parameters 
    ---------- 
    code_str : str 
        The code to be timed. 
    times : int, optional 
        The number of times the code is executed. Default is 1. The code is 
        only compiled once. 
    label : str, optional 
        A label to identify `code_str` with. This is passed into ``compile`` 
        as the second argument (for run-time error messages). 
 
    Returns 
    ------- 
    elapsed : float 
        Total elapsed time in seconds for executing `code_str` `times` times. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; times = 10 
    &gt;&gt;&gt; etime = np.testing.measure('for i in range(1000): np.sqrt(i**2)', times=times) 
    &gt;&gt;&gt; print(&quot;Time for a single execution : &quot;, etime / times, &quot;s&quot;)  # doctest: +SKIP 
    Time for a single execution :  0.005 s 
 
    &quot;&quot;&quot;</span>
    <span class="s1">frame = sys._getframe(</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">locs</span><span class="s2">, </span><span class="s1">globs = frame.f_locals</span><span class="s2">, </span><span class="s1">frame.f_globals</span>

    <span class="s1">code = compile(code_str</span><span class="s2">, </span><span class="s3">f'Test name: </span><span class="s2">{</span><span class="s1">label</span><span class="s2">} </span><span class="s3">'</span><span class="s2">, </span><span class="s3">'exec'</span><span class="s1">)</span>
    <span class="s1">i = </span><span class="s5">0</span>
    <span class="s1">elapsed = jiffies()</span>
    <span class="s2">while </span><span class="s1">i &lt; times:</span>
        <span class="s1">i += </span><span class="s5">1</span>
        <span class="s1">exec(code</span><span class="s2">, </span><span class="s1">globs</span><span class="s2">, </span><span class="s1">locs)</span>
    <span class="s1">elapsed = jiffies() - elapsed</span>
    <span class="s2">return </span><span class="s5">0.01</span><span class="s1">*elapsed</span>


<span class="s2">def </span><span class="s1">_assert_valid_refcount(op):</span>
    <span class="s0">&quot;&quot;&quot; 
    Check that ufuncs don't mishandle refcount of object `1`. 
    Used in a few regression tests. 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">HAS_REFCOUNT:</span>
        <span class="s2">return True</span>

    <span class="s2">import </span><span class="s1">gc</span>
    <span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

    <span class="s1">b = np.arange(</span><span class="s5">100</span><span class="s1">*</span><span class="s5">100</span><span class="s1">).reshape(</span><span class="s5">100</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)</span>
    <span class="s1">c = b</span>
    <span class="s1">i = </span><span class="s5">1</span>

    <span class="s1">gc.disable()</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">rc = sys.getrefcount(i)</span>
        <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">15</span><span class="s1">):</span>
            <span class="s1">d = op(b</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s1">assert_(sys.getrefcount(i) &gt;= rc)</span>
    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s1">gc.enable()</span>
    <span class="s2">del </span><span class="s1">d  </span><span class="s4"># for pyflakes</span>


<span class="s2">def </span><span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-7</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">equal_nan=</span><span class="s2">True,</span>
                    <span class="s1">err_msg=</span><span class="s3">''</span><span class="s2">, </span><span class="s1">verbose=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Raises an AssertionError if two objects are not equal up to desired 
    tolerance. 
 
    The test is equivalent to ``allclose(actual, desired, rtol, atol)`` (note 
    that ``allclose`` has different default values). It compares the difference 
    between `actual` and `desired` to ``atol + rtol * abs(desired)``. 
 
    .. versionadded:: 1.5.0 
 
    Parameters 
    ---------- 
    actual : array_like 
        Array obtained. 
    desired : array_like 
        Array desired. 
    rtol : float, optional 
        Relative tolerance. 
    atol : float, optional 
        Absolute tolerance. 
    equal_nan : bool, optional. 
        If True, NaNs will compare equal. 
    err_msg : str, optional 
        The error message to be printed in case of failure. 
    verbose : bool, optional 
        If True, the conflicting values are appended to the error message. 
 
    Raises 
    ------ 
    AssertionError 
        If actual and desired are not equal up to specified precision. 
 
    See Also 
    -------- 
    assert_array_almost_equal_nulp, assert_array_max_ulp 
 
    Examples 
    -------- 
    &gt;&gt;&gt; x = [1e-5, 1e-3, 1e-1] 
    &gt;&gt;&gt; y = np.arccos(np.cos(x)) 
    &gt;&gt;&gt; np.testing.assert_allclose(x, y, rtol=1e-5, atol=0) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">__tracebackhide__ = </span><span class="s2">True  </span><span class="s4"># Hide traceback for py.test</span>
    <span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

    <span class="s2">def </span><span class="s1">compare(x</span><span class="s2">, </span><span class="s1">y):</span>
        <span class="s2">return </span><span class="s1">np.core.numeric.isclose(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">rtol=rtol</span><span class="s2">, </span><span class="s1">atol=atol</span><span class="s2">,</span>
                                       <span class="s1">equal_nan=equal_nan)</span>

    <span class="s1">actual</span><span class="s2">, </span><span class="s1">desired = np.asanyarray(actual)</span><span class="s2">, </span><span class="s1">np.asanyarray(desired)</span>
    <span class="s1">header = </span><span class="s3">f'Not equal to tolerance rtol=</span><span class="s2">{</span><span class="s1">rtol</span><span class="s2">:</span><span class="s3">g</span><span class="s2">}</span><span class="s3">, atol=</span><span class="s2">{</span><span class="s1">atol</span><span class="s2">:</span><span class="s3">g</span><span class="s2">}</span><span class="s3">'</span>
    <span class="s1">assert_array_compare(compare</span><span class="s2">, </span><span class="s1">actual</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">err_msg=str(err_msg)</span><span class="s2">,</span>
                         <span class="s1">verbose=verbose</span><span class="s2">, </span><span class="s1">header=header</span><span class="s2">, </span><span class="s1">equal_nan=equal_nan)</span>


<span class="s2">def </span><span class="s1">assert_array_almost_equal_nulp(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">nulp=</span><span class="s5">1</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compare two arrays relatively to their spacing. 
 
    This is a relatively robust method to compare two arrays whose amplitude 
    is variable. 
 
    Parameters 
    ---------- 
    x, y : array_like 
        Input arrays. 
    nulp : int, optional 
        The maximum number of unit in the last place for tolerance (see Notes). 
        Default is 1. 
 
    Returns 
    ------- 
    None 
 
    Raises 
    ------ 
    AssertionError 
        If the spacing between `x` and `y` for one or more elements is larger 
        than `nulp`. 
 
    See Also 
    -------- 
    assert_array_max_ulp : Check that all items of arrays differ in at most 
        N Units in the Last Place. 
    spacing : Return the distance between x and the nearest adjacent number. 
 
    Notes 
    ----- 
    An assertion is raised if the following condition is not met:: 
 
        abs(x - y) &lt;= nulps * spacing(maximum(abs(x), abs(y))) 
 
    Examples 
    -------- 
    &gt;&gt;&gt; x = np.array([1., 1e-10, 1e-20]) 
    &gt;&gt;&gt; eps = np.finfo(x.dtype).eps 
    &gt;&gt;&gt; np.testing.assert_array_almost_equal_nulp(x, x*eps/2 + x) 
 
    &gt;&gt;&gt; np.testing.assert_array_almost_equal_nulp(x, x*eps + x) 
    Traceback (most recent call last): 
      ... 
    AssertionError: X and Y are not equal to 1 ULP (max is 2) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">__tracebackhide__ = </span><span class="s2">True  </span><span class="s4"># Hide traceback for py.test</span>
    <span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
    <span class="s1">ax = np.abs(x)</span>
    <span class="s1">ay = np.abs(y)</span>
    <span class="s1">ref = nulp * np.spacing(np.where(ax &gt; ay</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">ay))</span>
    <span class="s2">if not </span><span class="s1">np.all(np.abs(x-y) &lt;= ref):</span>
        <span class="s2">if </span><span class="s1">np.iscomplexobj(x) </span><span class="s2">or </span><span class="s1">np.iscomplexobj(y):</span>
            <span class="s1">msg = </span><span class="s3">&quot;X and Y are not equal to %d ULP&quot; </span><span class="s1">% nulp</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">max_nulp = np.max(nulp_diff(x</span><span class="s2">, </span><span class="s1">y))</span>
            <span class="s1">msg = </span><span class="s3">&quot;X and Y are not equal to %d ULP (max is %g)&quot; </span><span class="s1">% (nulp</span><span class="s2">, </span><span class="s1">max_nulp)</span>
        <span class="s2">raise </span><span class="s1">AssertionError(msg)</span>


<span class="s2">def </span><span class="s1">assert_array_max_ulp(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">maxulp=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Check that all items of arrays differ in at most N Units in the Last Place. 
 
    Parameters 
    ---------- 
    a, b : array_like 
        Input arrays to be compared. 
    maxulp : int, optional 
        The maximum number of units in the last place that elements of `a` and 
        `b` can differ. Default is 1. 
    dtype : dtype, optional 
        Data-type to convert `a` and `b` to if given. Default is None. 
 
    Returns 
    ------- 
    ret : ndarray 
        Array containing number of representable floating point numbers between 
        items in `a` and `b`. 
 
    Raises 
    ------ 
    AssertionError 
        If one or more elements differ by more than `maxulp`. 
 
    Notes 
    ----- 
    For computing the ULP difference, this API does not differentiate between 
    various representations of NAN (ULP difference between 0x7fc00000 and 0xffc00000 
    is zero). 
 
    See Also 
    -------- 
    assert_array_almost_equal_nulp : Compare two arrays relatively to their 
        spacing. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; a = np.linspace(0., 1., 100) 
    &gt;&gt;&gt; res = np.testing.assert_array_max_ulp(a, np.arcsin(np.sin(a))) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">__tracebackhide__ = </span><span class="s2">True  </span><span class="s4"># Hide traceback for py.test</span>
    <span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
    <span class="s1">ret = nulp_diff(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">dtype)</span>
    <span class="s2">if not </span><span class="s1">np.all(ret &lt;= maxulp):</span>
        <span class="s2">raise </span><span class="s1">AssertionError(</span><span class="s3">&quot;Arrays are not almost equal up to %g &quot;</span>
                             <span class="s3">&quot;ULP (max difference is %g ULP)&quot; </span><span class="s1">%</span>
                             <span class="s1">(maxulp</span><span class="s2">, </span><span class="s1">np.max(ret)))</span>
    <span class="s2">return </span><span class="s1">ret</span>


<span class="s2">def </span><span class="s1">nulp_diff(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;For each item in x and y, return the number of representable floating 
    points between them. 
 
    Parameters 
    ---------- 
    x : array_like 
        first input array 
    y : array_like 
        second input array 
    dtype : dtype, optional 
        Data-type to convert `x` and `y` to if given. Default is None. 
 
    Returns 
    ------- 
    nulp : array_like 
        number of representable floating point numbers between each item in x 
        and y. 
 
    Notes 
    ----- 
    For computing the ULP difference, this API does not differentiate between 
    various representations of NAN (ULP difference between 0x7fc00000 and 0xffc00000 
    is zero). 
 
    Examples 
    -------- 
    # By definition, epsilon is the smallest number such as 1 + eps != 1, so 
    # there should be exactly one ULP between 1 and 1 + eps 
    &gt;&gt;&gt; nulp_diff(1, 1 + np.finfo(x.dtype).eps) 
    1.0 
    &quot;&quot;&quot;</span>
    <span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
    <span class="s2">if </span><span class="s1">dtype:</span>
        <span class="s1">x = np.array(x</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">y = np.array(y</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">x = np.array(x)</span>
        <span class="s1">y = np.array(y)</span>

    <span class="s1">t = np.common_type(x</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s2">if </span><span class="s1">np.iscomplexobj(x) </span><span class="s2">or </span><span class="s1">np.iscomplexobj(y):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;_nulp not implemented for complex array&quot;</span><span class="s1">)</span>

    <span class="s1">x = np.array([x]</span><span class="s2">, </span><span class="s1">dtype=t)</span>
    <span class="s1">y = np.array([y]</span><span class="s2">, </span><span class="s1">dtype=t)</span>

    <span class="s1">x[np.isnan(x)] = np.nan</span>
    <span class="s1">y[np.isnan(y)] = np.nan</span>

    <span class="s2">if not </span><span class="s1">x.shape == y.shape:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;x and y do not have the same shape: %s - %s&quot; </span><span class="s1">%</span>
                         <span class="s1">(x.shape</span><span class="s2">, </span><span class="s1">y.shape))</span>

    <span class="s2">def </span><span class="s1">_diff(rx</span><span class="s2">, </span><span class="s1">ry</span><span class="s2">, </span><span class="s1">vdt):</span>
        <span class="s1">diff = np.array(rx-ry</span><span class="s2">, </span><span class="s1">dtype=vdt)</span>
        <span class="s2">return </span><span class="s1">np.abs(diff)</span>

    <span class="s1">rx = integer_repr(x)</span>
    <span class="s1">ry = integer_repr(y)</span>
    <span class="s2">return </span><span class="s1">_diff(rx</span><span class="s2">, </span><span class="s1">ry</span><span class="s2">, </span><span class="s1">t)</span>


<span class="s2">def </span><span class="s1">_integer_repr(x</span><span class="s2">, </span><span class="s1">vdt</span><span class="s2">, </span><span class="s1">comp):</span>
    <span class="s4"># Reinterpret binary representation of the float as sign-magnitude:</span>
    <span class="s4"># take into account two-complement representation</span>
    <span class="s4"># See also</span>
    <span class="s4"># https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/</span>
    <span class="s1">rx = x.view(vdt)</span>
    <span class="s2">if not </span><span class="s1">(rx.size == </span><span class="s5">1</span><span class="s1">):</span>
        <span class="s1">rx[rx &lt; </span><span class="s5">0</span><span class="s1">] = comp - rx[rx &lt; </span><span class="s5">0</span><span class="s1">]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">rx &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">rx = comp - rx</span>

    <span class="s2">return </span><span class="s1">rx</span>


<span class="s2">def </span><span class="s1">integer_repr(x):</span>
    <span class="s0">&quot;&quot;&quot;Return the signed-magnitude interpretation of the binary representation 
    of x.&quot;&quot;&quot;</span>
    <span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
    <span class="s2">if </span><span class="s1">x.dtype == np.float16:</span>
        <span class="s2">return </span><span class="s1">_integer_repr(x</span><span class="s2">, </span><span class="s1">np.int16</span><span class="s2">, </span><span class="s1">np.int16(-</span><span class="s5">2</span><span class="s1">**</span><span class="s5">15</span><span class="s1">))</span>
    <span class="s2">elif </span><span class="s1">x.dtype == np.float32:</span>
        <span class="s2">return </span><span class="s1">_integer_repr(x</span><span class="s2">, </span><span class="s1">np.int32</span><span class="s2">, </span><span class="s1">np.int32(-</span><span class="s5">2</span><span class="s1">**</span><span class="s5">31</span><span class="s1">))</span>
    <span class="s2">elif </span><span class="s1">x.dtype == np.float64:</span>
        <span class="s2">return </span><span class="s1">_integer_repr(x</span><span class="s2">, </span><span class="s1">np.int64</span><span class="s2">, </span><span class="s1">np.int64(-</span><span class="s5">2</span><span class="s1">**</span><span class="s5">63</span><span class="s1">))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f'Unsupported dtype </span><span class="s2">{</span><span class="s1">x.dtype</span><span class="s2">}</span><span class="s3">'</span><span class="s1">)</span>


<span class="s1">@contextlib.contextmanager</span>
<span class="s2">def </span><span class="s1">_assert_warns_context(warning_class</span><span class="s2">, </span><span class="s1">name=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s1">__tracebackhide__ = </span><span class="s2">True  </span><span class="s4"># Hide traceback for py.test</span>
    <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
        <span class="s1">l = sup.record(warning_class)</span>
        <span class="s2">yield</span>
        <span class="s2">if not </span><span class="s1">len(l) &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">name_str = </span><span class="s3">f' when calling </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">' </span><span class="s2">if </span><span class="s1">name </span><span class="s2">is not None else </span><span class="s3">''</span>
            <span class="s2">raise </span><span class="s1">AssertionError(</span><span class="s3">&quot;No warning raised&quot; </span><span class="s1">+ name_str)</span>


<span class="s2">def </span><span class="s1">assert_warns(warning_class</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    Fail unless the given callable throws the specified warning. 
 
    A warning of class warning_class should be thrown by the callable when 
    invoked with arguments args and keyword arguments kwargs. 
    If a different type of warning is thrown, it will not be caught. 
 
    If called with all arguments other than the warning class omitted, may be 
    used as a context manager: 
 
        with assert_warns(SomeWarning): 
            do_something() 
 
    The ability to be used as a context manager is new in NumPy v1.11.0. 
 
    .. versionadded:: 1.4.0 
 
    Parameters 
    ---------- 
    warning_class : class 
        The class defining the warning that `func` is expected to throw. 
    func : callable, optional 
        Callable to test 
    *args : Arguments 
        Arguments for `func`. 
    **kwargs : Kwargs 
        Keyword arguments for `func`. 
 
    Returns 
    ------- 
    The value returned by `func`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import warnings 
    &gt;&gt;&gt; def deprecated_func(num): 
    ...     warnings.warn(&quot;Please upgrade&quot;, DeprecationWarning) 
    ...     return num*num 
    &gt;&gt;&gt; with np.testing.assert_warns(DeprecationWarning): 
    ...     assert deprecated_func(4) == 16 
    &gt;&gt;&gt; # or passing a func 
    &gt;&gt;&gt; ret = np.testing.assert_warns(DeprecationWarning, deprecated_func, 4) 
    &gt;&gt;&gt; assert ret == 16 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">args:</span>
        <span class="s2">return </span><span class="s1">_assert_warns_context(warning_class)</span>

    <span class="s1">func = args[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">args = args[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s2">with </span><span class="s1">_assert_warns_context(warning_class</span><span class="s2">, </span><span class="s1">name=func.__name__):</span>
        <span class="s2">return </span><span class="s1">func(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s1">@contextlib.contextmanager</span>
<span class="s2">def </span><span class="s1">_assert_no_warnings_context(name=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s1">__tracebackhide__ = </span><span class="s2">True  </span><span class="s4"># Hide traceback for py.test</span>
    <span class="s2">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s2">True</span><span class="s1">) </span><span class="s2">as </span><span class="s1">l:</span>
        <span class="s1">warnings.simplefilter(</span><span class="s3">'always'</span><span class="s1">)</span>
        <span class="s2">yield</span>
        <span class="s2">if </span><span class="s1">len(l) &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">name_str = </span><span class="s3">f' when calling </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">' </span><span class="s2">if </span><span class="s1">name </span><span class="s2">is not None else </span><span class="s3">''</span>
            <span class="s2">raise </span><span class="s1">AssertionError(</span><span class="s3">f'Got warnings</span><span class="s2">{</span><span class="s1">name_str</span><span class="s2">}</span><span class="s3">: </span><span class="s2">{</span><span class="s1">l</span><span class="s2">}</span><span class="s3">'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">assert_no_warnings(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    Fail if the given callable produces any warnings. 
 
    If called with all arguments omitted, may be used as a context manager: 
 
        with assert_no_warnings(): 
            do_something() 
 
    The ability to be used as a context manager is new in NumPy v1.11.0. 
 
    .. versionadded:: 1.7.0 
 
    Parameters 
    ---------- 
    func : callable 
        The callable to test. 
    \\*args : Arguments 
        Arguments passed to `func`. 
    \\*\\*kwargs : Kwargs 
        Keyword arguments passed to `func`. 
 
    Returns 
    ------- 
    The value returned by `func`. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">args:</span>
        <span class="s2">return </span><span class="s1">_assert_no_warnings_context()</span>

    <span class="s1">func = args[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">args = args[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s2">with </span><span class="s1">_assert_no_warnings_context(name=func.__name__):</span>
        <span class="s2">return </span><span class="s1">func(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">def </span><span class="s1">_gen_alignment_data(dtype=float32</span><span class="s2">, </span><span class="s1">type=</span><span class="s3">'binary'</span><span class="s2">, </span><span class="s1">max_size=</span><span class="s5">24</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    generator producing data with different alignment and offsets 
    to test simd vectorization 
 
    Parameters 
    ---------- 
    dtype : dtype 
        data type to produce 
    type : string 
        'unary': create data for unary operations, creates one input 
                 and output array 
        'binary': create data for unary operations, creates two input 
                 and output array 
    max_size : integer 
        maximum size of data to produce 
 
    Returns 
    ------- 
    if type is 'unary' yields one output, one input array and a message 
    containing information on the data 
    if type is 'binary' yields one output array, two input array and a message 
    containing information on the data 
 
    &quot;&quot;&quot;</span>
    <span class="s1">ufmt = </span><span class="s3">'unary offset=(%d, %d), size=%d, dtype=%r, %s'</span>
    <span class="s1">bfmt = </span><span class="s3">'binary offset=(%d, %d, %d), size=%d, dtype=%r, %s'</span>
    <span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">3</span><span class="s1">):</span>
        <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">range(o + </span><span class="s5">2</span><span class="s2">, </span><span class="s1">max(o + </span><span class="s5">3</span><span class="s2">, </span><span class="s1">max_size)):</span>
            <span class="s2">if </span><span class="s1">type == </span><span class="s3">'unary'</span><span class="s1">:</span>
                <span class="s1">inp = </span><span class="s2">lambda</span><span class="s1">: arange(s</span><span class="s2">, </span><span class="s1">dtype=dtype)[o:]</span>
                <span class="s1">out = empty((s</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)[o:]</span>
                <span class="s2">yield </span><span class="s1">out</span><span class="s2">, </span><span class="s1">inp()</span><span class="s2">, </span><span class="s1">ufmt % (o</span><span class="s2">, </span><span class="s1">o</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s3">'out of place'</span><span class="s1">)</span>
                <span class="s1">d = inp()</span>
                <span class="s2">yield </span><span class="s1">d</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">ufmt % (o</span><span class="s2">, </span><span class="s1">o</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s3">'in place'</span><span class="s1">)</span>
                <span class="s2">yield </span><span class="s1">out[</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">inp()[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ufmt % \</span>
                    <span class="s1">(o + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">o</span><span class="s2">, </span><span class="s1">s - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s3">'out of place'</span><span class="s1">)</span>
                <span class="s2">yield </span><span class="s1">out[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">inp()[</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">ufmt % \</span>
                    <span class="s1">(o</span><span class="s2">, </span><span class="s1">o + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">s - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s3">'out of place'</span><span class="s1">)</span>
                <span class="s2">yield </span><span class="s1">inp()[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">inp()[</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">ufmt % \</span>
                    <span class="s1">(o</span><span class="s2">, </span><span class="s1">o + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">s - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s3">'aliased'</span><span class="s1">)</span>
                <span class="s2">yield </span><span class="s1">inp()[</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">inp()[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ufmt % \</span>
                    <span class="s1">(o + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">o</span><span class="s2">, </span><span class="s1">s - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s3">'aliased'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">type == </span><span class="s3">'binary'</span><span class="s1">:</span>
                <span class="s1">inp1 = </span><span class="s2">lambda</span><span class="s1">: arange(s</span><span class="s2">, </span><span class="s1">dtype=dtype)[o:]</span>
                <span class="s1">inp2 = </span><span class="s2">lambda</span><span class="s1">: arange(s</span><span class="s2">, </span><span class="s1">dtype=dtype)[o:]</span>
                <span class="s1">out = empty((s</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)[o:]</span>
                <span class="s2">yield </span><span class="s1">out</span><span class="s2">, </span><span class="s1">inp1()</span><span class="s2">, </span><span class="s1">inp2()</span><span class="s2">,  </span><span class="s1">bfmt % \</span>
                    <span class="s1">(o</span><span class="s2">, </span><span class="s1">o</span><span class="s2">, </span><span class="s1">o</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s3">'out of place'</span><span class="s1">)</span>
                <span class="s1">d = inp1()</span>
                <span class="s2">yield </span><span class="s1">d</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">inp2()</span><span class="s2">, </span><span class="s1">bfmt % \</span>
                    <span class="s1">(o</span><span class="s2">, </span><span class="s1">o</span><span class="s2">, </span><span class="s1">o</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s3">'in place1'</span><span class="s1">)</span>
                <span class="s1">d = inp2()</span>
                <span class="s2">yield </span><span class="s1">d</span><span class="s2">, </span><span class="s1">inp1()</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">bfmt % \</span>
                    <span class="s1">(o</span><span class="s2">, </span><span class="s1">o</span><span class="s2">, </span><span class="s1">o</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s3">'in place2'</span><span class="s1">)</span>
                <span class="s2">yield </span><span class="s1">out[</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">inp1()[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">inp2()[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">bfmt % \</span>
                    <span class="s1">(o + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">o</span><span class="s2">, </span><span class="s1">o</span><span class="s2">, </span><span class="s1">s - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s3">'out of place'</span><span class="s1">)</span>
                <span class="s2">yield </span><span class="s1">out[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">inp1()[</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">inp2()[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">bfmt % \</span>
                    <span class="s1">(o</span><span class="s2">, </span><span class="s1">o + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">o</span><span class="s2">, </span><span class="s1">s - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s3">'out of place'</span><span class="s1">)</span>
                <span class="s2">yield </span><span class="s1">out[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">inp1()[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">inp2()[</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">bfmt % \</span>
                    <span class="s1">(o</span><span class="s2">, </span><span class="s1">o</span><span class="s2">, </span><span class="s1">o + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">s - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s3">'out of place'</span><span class="s1">)</span>
                <span class="s2">yield </span><span class="s1">inp1()[</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">inp1()[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">inp2()[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">bfmt % \</span>
                    <span class="s1">(o + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">o</span><span class="s2">, </span><span class="s1">o</span><span class="s2">, </span><span class="s1">s - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s3">'aliased'</span><span class="s1">)</span>
                <span class="s2">yield </span><span class="s1">inp1()[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">inp1()[</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">inp2()[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">bfmt % \</span>
                    <span class="s1">(o</span><span class="s2">, </span><span class="s1">o + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">o</span><span class="s2">, </span><span class="s1">s - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s3">'aliased'</span><span class="s1">)</span>
                <span class="s2">yield </span><span class="s1">inp1()[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">inp1()[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">inp2()[</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">bfmt % \</span>
                    <span class="s1">(o</span><span class="s2">, </span><span class="s1">o</span><span class="s2">, </span><span class="s1">o + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">s - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s3">'aliased'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">IgnoreException(Exception):</span>
    <span class="s0">&quot;Ignoring this exception due to disabled feature&quot;</span>
    <span class="s2">pass</span>


<span class="s1">@contextlib.contextmanager</span>
<span class="s2">def </span><span class="s1">tempdir(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot;Context manager to provide a temporary test folder. 
 
    All arguments are passed as this to the underlying tempfile.mkdtemp 
    function. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">tmpdir = mkdtemp(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">yield </span><span class="s1">tmpdir</span>
    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s1">shutil.rmtree(tmpdir)</span>


<span class="s1">@contextlib.contextmanager</span>
<span class="s2">def </span><span class="s1">temppath(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot;Context manager for temporary files. 
 
    Context manager that returns the path to a closed temporary file. Its 
    parameters are the same as for tempfile.mkstemp and are passed directly 
    to that function. The underlying file is removed when the context is 
    exited, so it should be closed at that time. 
 
    Windows does not allow a temporary file to be opened if it is already 
    open, so the underlying file must be closed after opening before it 
    can be opened again. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">fd</span><span class="s2">, </span><span class="s1">path = mkstemp(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s1">os.close(fd)</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">yield </span><span class="s1">path</span>
    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s1">os.remove(path)</span>


<span class="s2">class </span><span class="s1">clear_and_catch_warnings(warnings.catch_warnings):</span>
    <span class="s0">&quot;&quot;&quot; Context manager that resets warning registry for catching warnings 
 
    Warnings can be slippery, because, whenever a warning is triggered, Python 
    adds a ``__warningregistry__`` member to the *calling* module.  This makes 
    it impossible to retrigger the warning in this module, whatever you put in 
    the warnings filters.  This context manager accepts a sequence of `modules` 
    as a keyword argument to its constructor and: 
 
    * stores and removes any ``__warningregistry__`` entries in given `modules` 
      on entry; 
    * resets ``__warningregistry__`` to its previous state on exit. 
 
    This makes it possible to trigger any warning afresh inside the context 
    manager without disturbing the state of warnings outside. 
 
    For compatibility with Python 3.0, please consider all arguments to be 
    keyword-only. 
 
    Parameters 
    ---------- 
    record : bool, optional 
        Specifies whether warnings should be captured by a custom 
        implementation of ``warnings.showwarning()`` and be appended to a list 
        returned by the context manager. Otherwise None is returned by the 
        context manager. The objects appended to the list are arguments whose 
        attributes mirror the arguments to ``showwarning()``. 
    modules : sequence, optional 
        Sequence of modules for which to reset warnings registry on entry and 
        restore on exit. To work correctly, all 'ignore' filters should 
        filter by one of these modules. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import warnings 
    &gt;&gt;&gt; with np.testing.clear_and_catch_warnings( 
    ...         modules=[np.core.fromnumeric]): 
    ...     warnings.simplefilter('always') 
    ...     warnings.filterwarnings('ignore', module='np.core.fromnumeric') 
    ...     # do something that raises a warning but ignore those in 
    ...     # np.core.fromnumeric 
    &quot;&quot;&quot;</span>
    <span class="s1">class_modules = ()</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">record=</span><span class="s2">False, </span><span class="s1">modules=()):</span>
        <span class="s1">self.modules = set(modules).union(self.class_modules)</span>
        <span class="s1">self._warnreg_copies = {}</span>
        <span class="s1">super(clear_and_catch_warnings</span><span class="s2">, </span><span class="s1">self).__init__(record=record)</span>

    <span class="s2">def </span><span class="s1">__enter__(self):</span>
        <span class="s2">for </span><span class="s1">mod </span><span class="s2">in </span><span class="s1">self.modules:</span>
            <span class="s2">if </span><span class="s1">hasattr(mod</span><span class="s2">, </span><span class="s3">'__warningregistry__'</span><span class="s1">):</span>
                <span class="s1">mod_reg = mod.__warningregistry__</span>
                <span class="s1">self._warnreg_copies[mod] = mod_reg.copy()</span>
                <span class="s1">mod_reg.clear()</span>
        <span class="s2">return </span><span class="s1">super(clear_and_catch_warnings</span><span class="s2">, </span><span class="s1">self).__enter__()</span>

    <span class="s2">def </span><span class="s1">__exit__(self</span><span class="s2">, </span><span class="s1">*exc_info):</span>
        <span class="s1">super(clear_and_catch_warnings</span><span class="s2">, </span><span class="s1">self).__exit__(*exc_info)</span>
        <span class="s2">for </span><span class="s1">mod </span><span class="s2">in </span><span class="s1">self.modules:</span>
            <span class="s2">if </span><span class="s1">hasattr(mod</span><span class="s2">, </span><span class="s3">'__warningregistry__'</span><span class="s1">):</span>
                <span class="s1">mod.__warningregistry__.clear()</span>
            <span class="s2">if </span><span class="s1">mod </span><span class="s2">in </span><span class="s1">self._warnreg_copies:</span>
                <span class="s1">mod.__warningregistry__.update(self._warnreg_copies[mod])</span>


<span class="s2">class </span><span class="s1">suppress_warnings:</span>
    <span class="s0">&quot;&quot;&quot; 
    Context manager and decorator doing much the same as 
    ``warnings.catch_warnings``. 
 
    However, it also provides a filter mechanism to work around 
    https://bugs.python.org/issue4180. 
 
    This bug causes Python before 3.4 to not reliably show warnings again 
    after they have been ignored once (even within catch_warnings). It 
    means that no &quot;ignore&quot; filter can be used easily, since following 
    tests might need to see the warning. Additionally it allows easier 
    specificity for testing warnings and can be nested. 
 
    Parameters 
    ---------- 
    forwarding_rule : str, optional 
        One of &quot;always&quot;, &quot;once&quot;, &quot;module&quot;, or &quot;location&quot;. Analogous to 
        the usual warnings module filter mode, it is useful to reduce 
        noise mostly on the outmost level. Unsuppressed and unrecorded 
        warnings will be forwarded based on this rule. Defaults to &quot;always&quot;. 
        &quot;location&quot; is equivalent to the warnings &quot;default&quot;, match by exact 
        location the warning warning originated from. 
 
    Notes 
    ----- 
    Filters added inside the context manager will be discarded again 
    when leaving it. Upon entering all filters defined outside a 
    context will be applied automatically. 
 
    When a recording filter is added, matching warnings are stored in the 
    ``log`` attribute as well as in the list returned by ``record``. 
 
    If filters are added and the ``module`` keyword is given, the 
    warning registry of this module will additionally be cleared when 
    applying it, entering the context, or exiting it. This could cause 
    warnings to appear a second time after leaving the context if they 
    were configured to be printed once (default) and were already 
    printed before the context was entered. 
 
    Nesting this context manager will work as expected when the 
    forwarding rule is &quot;always&quot; (default). Unfiltered and unrecorded 
    warnings will be passed out and be matched by the outer level. 
    On the outmost level they will be printed (or caught by another 
    warnings context). The forwarding rule argument can modify this 
    behaviour. 
 
    Like ``catch_warnings`` this context manager is not threadsafe. 
 
    Examples 
    -------- 
 
    With a context manager:: 
 
        with np.testing.suppress_warnings() as sup: 
            sup.filter(DeprecationWarning, &quot;Some text&quot;) 
            sup.filter(module=np.ma.core) 
            log = sup.record(FutureWarning, &quot;Does this occur?&quot;) 
            command_giving_warnings() 
            # The FutureWarning was given once, the filtered warnings were 
            # ignored. All other warnings abide outside settings (may be 
            # printed/error) 
            assert_(len(log) == 1) 
            assert_(len(sup.log) == 1)  # also stored in log attribute 
 
    Or as a decorator:: 
 
        sup = np.testing.suppress_warnings() 
        sup.filter(module=np.ma.core)  # module must match exactly 
        @sup 
        def some_function(): 
            # do something which causes a warning in np.ma.core 
            pass 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">forwarding_rule=</span><span class="s3">&quot;always&quot;</span><span class="s1">):</span>
        <span class="s1">self._entered = </span><span class="s2">False</span>

        <span class="s4"># Suppressions are either instance or defined inside one with block:</span>
        <span class="s1">self._suppressions = []</span>

        <span class="s2">if </span><span class="s1">forwarding_rule </span><span class="s2">not in </span><span class="s1">{</span><span class="s3">&quot;always&quot;</span><span class="s2">, </span><span class="s3">&quot;module&quot;</span><span class="s2">, </span><span class="s3">&quot;once&quot;</span><span class="s2">, </span><span class="s3">&quot;location&quot;</span><span class="s1">}:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;unsupported forwarding rule.&quot;</span><span class="s1">)</span>
        <span class="s1">self._forwarding_rule = forwarding_rule</span>

    <span class="s2">def </span><span class="s1">_clear_registries(self):</span>
        <span class="s2">if </span><span class="s1">hasattr(warnings</span><span class="s2">, </span><span class="s3">&quot;_filters_mutated&quot;</span><span class="s1">):</span>
            <span class="s4"># clearing the registry should not be necessary on new pythons,</span>
            <span class="s4"># instead the filters should be mutated.</span>
            <span class="s1">warnings._filters_mutated()</span>
            <span class="s2">return</span>
        <span class="s4"># Simply clear the registry, this should normally be harmless,</span>
        <span class="s4"># note that on new pythons it would be invalidated anyway.</span>
        <span class="s2">for </span><span class="s1">module </span><span class="s2">in </span><span class="s1">self._tmp_modules:</span>
            <span class="s2">if </span><span class="s1">hasattr(module</span><span class="s2">, </span><span class="s3">&quot;__warningregistry__&quot;</span><span class="s1">):</span>
                <span class="s1">module.__warningregistry__.clear()</span>

    <span class="s2">def </span><span class="s1">_filter(self</span><span class="s2">, </span><span class="s1">category=Warning</span><span class="s2">, </span><span class="s1">message=</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s1">module=</span><span class="s2">None, </span><span class="s1">record=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">record:</span>
            <span class="s1">record = []  </span><span class="s4"># The log where to store warnings</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">record = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">self._entered:</span>
            <span class="s2">if </span><span class="s1">module </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">warnings.filterwarnings(</span>
                    <span class="s3">&quot;always&quot;</span><span class="s2">, </span><span class="s1">category=category</span><span class="s2">, </span><span class="s1">message=message)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">module_regex = module.__name__.replace(</span><span class="s3">'.'</span><span class="s2">, </span><span class="s3">r'\.'</span><span class="s1">) + </span><span class="s3">'$'</span>
                <span class="s1">warnings.filterwarnings(</span>
                    <span class="s3">&quot;always&quot;</span><span class="s2">, </span><span class="s1">category=category</span><span class="s2">, </span><span class="s1">message=message</span><span class="s2">,</span>
                    <span class="s1">module=module_regex)</span>
                <span class="s1">self._tmp_modules.add(module)</span>
                <span class="s1">self._clear_registries()</span>

            <span class="s1">self._tmp_suppressions.append(</span>
                <span class="s1">(category</span><span class="s2">, </span><span class="s1">message</span><span class="s2">, </span><span class="s1">re.compile(message</span><span class="s2">, </span><span class="s1">re.I)</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">record))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._suppressions.append(</span>
                <span class="s1">(category</span><span class="s2">, </span><span class="s1">message</span><span class="s2">, </span><span class="s1">re.compile(message</span><span class="s2">, </span><span class="s1">re.I)</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">record))</span>

        <span class="s2">return </span><span class="s1">record</span>

    <span class="s2">def </span><span class="s1">filter(self</span><span class="s2">, </span><span class="s1">category=Warning</span><span class="s2">, </span><span class="s1">message=</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s1">module=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add a new suppressing filter or apply it if the state is entered. 
 
        Parameters 
        ---------- 
        category : class, optional 
            Warning class to filter 
        message : string, optional 
            Regular expression matching the warning message. 
        module : module, optional 
            Module to filter for. Note that the module (and its file) 
            must match exactly and cannot be a submodule. This may make 
            it unreliable for external modules. 
 
        Notes 
        ----- 
        When added within a context, filters are only added inside 
        the context and will be forgotten when the context is exited. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._filter(category=category</span><span class="s2">, </span><span class="s1">message=message</span><span class="s2">, </span><span class="s1">module=module</span><span class="s2">,</span>
                     <span class="s1">record=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">record(self</span><span class="s2">, </span><span class="s1">category=Warning</span><span class="s2">, </span><span class="s1">message=</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s1">module=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Append a new recording filter or apply it if the state is entered. 
 
        All warnings matching will be appended to the ``log`` attribute. 
 
        Parameters 
        ---------- 
        category : class, optional 
            Warning class to filter 
        message : string, optional 
            Regular expression matching the warning message. 
        module : module, optional 
            Module to filter for. Note that the module (and its file) 
            must match exactly and cannot be a submodule. This may make 
            it unreliable for external modules. 
 
        Returns 
        ------- 
        log : list 
            A list which will be filled with all matched warnings. 
 
        Notes 
        ----- 
        When added within a context, filters are only added inside 
        the context and will be forgotten when the context is exited. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._filter(category=category</span><span class="s2">, </span><span class="s1">message=message</span><span class="s2">, </span><span class="s1">module=module</span><span class="s2">,</span>
                            <span class="s1">record=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__enter__(self):</span>
        <span class="s2">if </span><span class="s1">self._entered:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;cannot enter suppress_warnings twice.&quot;</span><span class="s1">)</span>

        <span class="s1">self._orig_show = warnings.showwarning</span>
        <span class="s1">self._filters = warnings.filters</span>
        <span class="s1">warnings.filters = self._filters[:]</span>

        <span class="s1">self._entered = </span><span class="s2">True</span>
        <span class="s1">self._tmp_suppressions = []</span>
        <span class="s1">self._tmp_modules = set()</span>
        <span class="s1">self._forwarded = set()</span>

        <span class="s1">self.log = []  </span><span class="s4"># reset global log (no need to keep same list)</span>

        <span class="s2">for </span><span class="s1">cat</span><span class="s2">, </span><span class="s1">mess</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">mod</span><span class="s2">, </span><span class="s1">log </span><span class="s2">in </span><span class="s1">self._suppressions:</span>
            <span class="s2">if </span><span class="s1">log </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">del </span><span class="s1">log[:]  </span><span class="s4"># clear the log</span>
            <span class="s2">if </span><span class="s1">mod </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">warnings.filterwarnings(</span>
                    <span class="s3">&quot;always&quot;</span><span class="s2">, </span><span class="s1">category=cat</span><span class="s2">, </span><span class="s1">message=mess)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">module_regex = mod.__name__.replace(</span><span class="s3">'.'</span><span class="s2">, </span><span class="s3">r'\.'</span><span class="s1">) + </span><span class="s3">'$'</span>
                <span class="s1">warnings.filterwarnings(</span>
                    <span class="s3">&quot;always&quot;</span><span class="s2">, </span><span class="s1">category=cat</span><span class="s2">, </span><span class="s1">message=mess</span><span class="s2">,</span>
                    <span class="s1">module=module_regex)</span>
                <span class="s1">self._tmp_modules.add(mod)</span>
        <span class="s1">warnings.showwarning = self._showwarning</span>
        <span class="s1">self._clear_registries()</span>

        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__exit__(self</span><span class="s2">, </span><span class="s1">*exc_info):</span>
        <span class="s1">warnings.showwarning = self._orig_show</span>
        <span class="s1">warnings.filters = self._filters</span>
        <span class="s1">self._clear_registries()</span>
        <span class="s1">self._entered = </span><span class="s2">False</span>
        <span class="s2">del </span><span class="s1">self._orig_show</span>
        <span class="s2">del </span><span class="s1">self._filters</span>

    <span class="s2">def </span><span class="s1">_showwarning(self</span><span class="s2">, </span><span class="s1">message</span><span class="s2">, </span><span class="s1">category</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">lineno</span><span class="s2">,</span>
                     <span class="s1">*args</span><span class="s2">, </span><span class="s1">use_warnmsg=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s2">for </span><span class="s1">cat</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">pattern</span><span class="s2">, </span><span class="s1">mod</span><span class="s2">, </span><span class="s1">rec </span><span class="s2">in </span><span class="s1">(</span>
                <span class="s1">self._suppressions + self._tmp_suppressions)[::-</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s2">if </span><span class="s1">(issubclass(category</span><span class="s2">, </span><span class="s1">cat) </span><span class="s2">and</span>
                    <span class="s1">pattern.match(message.args[</span><span class="s5">0</span><span class="s1">]) </span><span class="s2">is not None</span><span class="s1">):</span>
                <span class="s2">if </span><span class="s1">mod </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s4"># Message and category match, either recorded or ignored</span>
                    <span class="s2">if </span><span class="s1">rec </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s1">msg = WarningMessage(message</span><span class="s2">, </span><span class="s1">category</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">,</span>
                                             <span class="s1">lineno</span><span class="s2">, </span><span class="s1">**kwargs)</span>
                        <span class="s1">self.log.append(msg)</span>
                        <span class="s1">rec.append(msg)</span>
                    <span class="s2">return</span>
                <span class="s4"># Use startswith, because warnings strips the c or o from</span>
                <span class="s4"># .pyc/.pyo files.</span>
                <span class="s2">elif </span><span class="s1">mod.__file__.startswith(filename):</span>
                    <span class="s4"># The message and module (filename) match</span>
                    <span class="s2">if </span><span class="s1">rec </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s1">msg = WarningMessage(message</span><span class="s2">, </span><span class="s1">category</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">,</span>
                                             <span class="s1">lineno</span><span class="s2">, </span><span class="s1">**kwargs)</span>
                        <span class="s1">self.log.append(msg)</span>
                        <span class="s1">rec.append(msg)</span>
                    <span class="s2">return</span>

        <span class="s4"># There is no filter in place, so pass to the outside handler</span>
        <span class="s4"># unless we should only pass it once</span>
        <span class="s2">if </span><span class="s1">self._forwarding_rule == </span><span class="s3">&quot;always&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">use_warnmsg </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">self._orig_show(message</span><span class="s2">, </span><span class="s1">category</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">lineno</span><span class="s2">,</span>
                                <span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self._orig_showmsg(use_warnmsg)</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">self._forwarding_rule == </span><span class="s3">&quot;once&quot;</span><span class="s1">:</span>
            <span class="s1">signature = (message.args</span><span class="s2">, </span><span class="s1">category)</span>
        <span class="s2">elif </span><span class="s1">self._forwarding_rule == </span><span class="s3">&quot;module&quot;</span><span class="s1">:</span>
            <span class="s1">signature = (message.args</span><span class="s2">, </span><span class="s1">category</span><span class="s2">, </span><span class="s1">filename)</span>
        <span class="s2">elif </span><span class="s1">self._forwarding_rule == </span><span class="s3">&quot;location&quot;</span><span class="s1">:</span>
            <span class="s1">signature = (message.args</span><span class="s2">, </span><span class="s1">category</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">lineno)</span>

        <span class="s2">if </span><span class="s1">signature </span><span class="s2">in </span><span class="s1">self._forwarded:</span>
            <span class="s2">return</span>
        <span class="s1">self._forwarded.add(signature)</span>
        <span class="s2">if </span><span class="s1">use_warnmsg </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._orig_show(message</span><span class="s2">, </span><span class="s1">category</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">lineno</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">,</span>
                            <span class="s1">**kwargs)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._orig_showmsg(use_warnmsg)</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">func):</span>
        <span class="s0">&quot;&quot;&quot; 
        Function decorator to apply certain suppressions to a whole 
        function. 
        &quot;&quot;&quot;</span>
        <span class="s1">@wraps(func)</span>
        <span class="s2">def </span><span class="s1">new_func(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
            <span class="s2">with </span><span class="s1">self:</span>
                <span class="s2">return </span><span class="s1">func(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s2">return </span><span class="s1">new_func</span>


<span class="s1">@contextlib.contextmanager</span>
<span class="s2">def </span><span class="s1">_assert_no_gc_cycles_context(name=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s1">__tracebackhide__ = </span><span class="s2">True  </span><span class="s4"># Hide traceback for py.test</span>

    <span class="s4"># not meaningful to test if there is no refcounting</span>
    <span class="s2">if not </span><span class="s1">HAS_REFCOUNT:</span>
        <span class="s2">yield</span>
        <span class="s2">return</span>

    <span class="s1">assert_(gc.isenabled())</span>
    <span class="s1">gc.disable()</span>
    <span class="s1">gc_debug = gc.get_debug()</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">100</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">gc.collect() == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">break</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span>
                <span class="s3">&quot;Unable to fully collect garbage - perhaps a __del__ method &quot;</span>
                <span class="s3">&quot;is creating more reference cycles?&quot;</span><span class="s1">)</span>

        <span class="s1">gc.set_debug(gc.DEBUG_SAVEALL)</span>
        <span class="s2">yield</span>
        <span class="s4"># gc.collect returns the number of unreachable objects in cycles that</span>
        <span class="s4"># were found -- we are checking that no cycles were created in the context</span>
        <span class="s1">n_objects_in_cycles = gc.collect()</span>
        <span class="s1">objects_in_cycles = gc.garbage[:]</span>
    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s2">del </span><span class="s1">gc.garbage[:]</span>
        <span class="s1">gc.set_debug(gc_debug)</span>
        <span class="s1">gc.enable()</span>

    <span class="s2">if </span><span class="s1">n_objects_in_cycles:</span>
        <span class="s1">name_str = </span><span class="s3">f' when calling </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">' </span><span class="s2">if </span><span class="s1">name </span><span class="s2">is not None else </span><span class="s3">''</span>
        <span class="s2">raise </span><span class="s1">AssertionError(</span>
            <span class="s3">&quot;Reference cycles were found{}: {} objects were collected, &quot;</span>
            <span class="s3">&quot;of which {} are shown below:{}&quot;</span>
            <span class="s1">.format(</span>
                <span class="s1">name_str</span><span class="s2">,</span>
                <span class="s1">n_objects_in_cycles</span><span class="s2">,</span>
                <span class="s1">len(objects_in_cycles)</span><span class="s2">,</span>
                <span class="s3">''</span><span class="s1">.join(</span>
                    <span class="s3">&quot;</span><span class="s2">\n  </span><span class="s3">{} object with id={}:</span><span class="s2">\n    </span><span class="s3">{}&quot;</span><span class="s1">.format(</span>
                        <span class="s1">type(o).__name__</span><span class="s2">,</span>
                        <span class="s1">id(o)</span><span class="s2">,</span>
                        <span class="s1">pprint.pformat(o).replace(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">, </span><span class="s3">'</span><span class="s2">\n    </span><span class="s3">'</span><span class="s1">)</span>
                    <span class="s1">) </span><span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">objects_in_cycles</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">)</span>


<span class="s2">def </span><span class="s1">assert_no_gc_cycles(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    Fail if the given callable produces any reference cycles. 
 
    If called with all arguments omitted, may be used as a context manager: 
 
        with assert_no_gc_cycles(): 
            do_something() 
 
    .. versionadded:: 1.15.0 
 
    Parameters 
    ---------- 
    func : callable 
        The callable to test. 
    \\*args : Arguments 
        Arguments passed to `func`. 
    \\*\\*kwargs : Kwargs 
        Keyword arguments passed to `func`. 
 
    Returns 
    ------- 
    Nothing. The result is deliberately discarded to ensure that all cycles 
    are found. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">args:</span>
        <span class="s2">return </span><span class="s1">_assert_no_gc_cycles_context()</span>

    <span class="s1">func = args[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">args = args[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s2">with </span><span class="s1">_assert_no_gc_cycles_context(name=func.__name__):</span>
        <span class="s1">func(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

<span class="s2">def </span><span class="s1">break_cycles():</span>
    <span class="s0">&quot;&quot;&quot; 
    Break reference cycles by calling gc.collect 
    Objects can call other objects' methods (for instance, another object's 
     __del__) inside their own __del__. On PyPy, the interpreter only runs 
    between calls to gc.collect, so multiple calls are needed to completely 
    release all cycles. 
    &quot;&quot;&quot;</span>

    <span class="s1">gc.collect()</span>
    <span class="s2">if </span><span class="s1">IS_PYPY:</span>
        <span class="s4"># interpreter runs now, to call deleted objects' __del__ methods</span>
        <span class="s1">gc.collect()</span>
        <span class="s4"># two more, just to make sure</span>
        <span class="s1">gc.collect()</span>
        <span class="s1">gc.collect()</span>


<span class="s2">def </span><span class="s1">requires_memory(free_bytes):</span>
    <span class="s0">&quot;&quot;&quot;Decorator to skip a test if not enough memory is available&quot;&quot;&quot;</span>
    <span class="s2">import </span><span class="s1">pytest</span>

    <span class="s2">def </span><span class="s1">decorator(func):</span>
        <span class="s1">@wraps(func)</span>
        <span class="s2">def </span><span class="s1">wrapper(*a</span><span class="s2">, </span><span class="s1">**kw):</span>
            <span class="s1">msg = check_free_memory(free_bytes)</span>
            <span class="s2">if </span><span class="s1">msg </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">pytest.skip(msg)</span>

            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">func(*a</span><span class="s2">, </span><span class="s1">**kw)</span>
            <span class="s2">except </span><span class="s1">MemoryError:</span>
                <span class="s4"># Probably ran out of memory regardless: don't regard as failure</span>
                <span class="s1">pytest.xfail(</span><span class="s3">&quot;MemoryError raised&quot;</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">wrapper</span>

    <span class="s2">return </span><span class="s1">decorator</span>


<span class="s2">def </span><span class="s1">check_free_memory(free_bytes):</span>
    <span class="s0">&quot;&quot;&quot; 
    Check whether `free_bytes` amount of memory is currently free. 
    Returns: None if enough memory available, otherwise error message 
    &quot;&quot;&quot;</span>
    <span class="s1">env_var = </span><span class="s3">'NPY_AVAILABLE_MEM'</span>
    <span class="s1">env_value = os.environ.get(env_var)</span>
    <span class="s2">if </span><span class="s1">env_value </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">mem_free = _parse_size(env_value)</span>
        <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">exc:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f'Invalid environment variable </span><span class="s2">{</span><span class="s1">env_var</span><span class="s2">}</span><span class="s3">: </span><span class="s2">{</span><span class="s1">exc</span><span class="s2">}</span><span class="s3">'</span><span class="s1">)</span>

        <span class="s1">msg = (</span><span class="s3">f'</span><span class="s2">{</span><span class="s1">free_bytes/</span><span class="s5">1e9</span><span class="s2">} </span><span class="s3">GB memory required, but environment variable '</span>
               <span class="s3">f'NPY_AVAILABLE_MEM=</span><span class="s2">{</span><span class="s1">env_value</span><span class="s2">} </span><span class="s3">set'</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">mem_free = _get_mem_available()</span>

        <span class="s2">if </span><span class="s1">mem_free </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">msg = (</span><span class="s3">&quot;Could not determine available memory; set NPY_AVAILABLE_MEM &quot;</span>
                   <span class="s3">&quot;environment variable (e.g. NPY_AVAILABLE_MEM=16GB) to run &quot;</span>
                   <span class="s3">&quot;the test.&quot;</span><span class="s1">)</span>
            <span class="s1">mem_free = -</span><span class="s5">1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s3">f'</span><span class="s2">{</span><span class="s1">free_bytes/</span><span class="s5">1e9</span><span class="s2">} </span><span class="s3">GB memory required, but </span><span class="s2">{</span><span class="s1">mem_free/</span><span class="s5">1e9</span><span class="s2">} </span><span class="s3">GB available'</span>

    <span class="s2">return </span><span class="s1">msg </span><span class="s2">if </span><span class="s1">mem_free &lt; free_bytes </span><span class="s2">else None</span>


<span class="s2">def </span><span class="s1">_parse_size(size_str):</span>
    <span class="s0">&quot;&quot;&quot;Convert memory size strings ('12 GB' etc.) to float&quot;&quot;&quot;</span>
    <span class="s1">suffixes = {</span><span class="s3">''</span><span class="s1">: </span><span class="s5">1</span><span class="s2">, </span><span class="s3">'b'</span><span class="s1">: </span><span class="s5">1</span><span class="s2">,</span>
                <span class="s3">'k'</span><span class="s1">: </span><span class="s5">1000</span><span class="s2">, </span><span class="s3">'m'</span><span class="s1">: </span><span class="s5">1000</span><span class="s1">**</span><span class="s5">2</span><span class="s2">, </span><span class="s3">'g'</span><span class="s1">: </span><span class="s5">1000</span><span class="s1">**</span><span class="s5">3</span><span class="s2">, </span><span class="s3">'t'</span><span class="s1">: </span><span class="s5">1000</span><span class="s1">**</span><span class="s5">4</span><span class="s2">,</span>
                <span class="s3">'kb'</span><span class="s1">: </span><span class="s5">1000</span><span class="s2">, </span><span class="s3">'mb'</span><span class="s1">: </span><span class="s5">1000</span><span class="s1">**</span><span class="s5">2</span><span class="s2">, </span><span class="s3">'gb'</span><span class="s1">: </span><span class="s5">1000</span><span class="s1">**</span><span class="s5">3</span><span class="s2">, </span><span class="s3">'tb'</span><span class="s1">: </span><span class="s5">1000</span><span class="s1">**</span><span class="s5">4</span><span class="s2">,</span>
                <span class="s3">'kib'</span><span class="s1">: </span><span class="s5">1024</span><span class="s2">, </span><span class="s3">'mib'</span><span class="s1">: </span><span class="s5">1024</span><span class="s1">**</span><span class="s5">2</span><span class="s2">, </span><span class="s3">'gib'</span><span class="s1">: </span><span class="s5">1024</span><span class="s1">**</span><span class="s5">3</span><span class="s2">, </span><span class="s3">'tib'</span><span class="s1">: </span><span class="s5">1024</span><span class="s1">**</span><span class="s5">4</span><span class="s1">}</span>

    <span class="s1">size_re = re.compile(</span><span class="s3">r'^\s*(\d+|\d+\.\d+)\s*({0})\s*$'</span><span class="s1">.format(</span>
        <span class="s3">'|'</span><span class="s1">.join(suffixes.keys()))</span><span class="s2">, </span><span class="s1">re.I)</span>

    <span class="s1">m = size_re.match(size_str.lower())</span>
    <span class="s2">if not </span><span class="s1">m </span><span class="s2">or </span><span class="s1">m.group(</span><span class="s5">2</span><span class="s1">) </span><span class="s2">not in </span><span class="s1">suffixes:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f'value </span><span class="s2">{</span><span class="s1">size_str</span><span class="s2">!r} </span><span class="s3">not a valid size'</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">int(float(m.group(</span><span class="s5">1</span><span class="s1">)) * suffixes[m.group(</span><span class="s5">2</span><span class="s1">)])</span>


<span class="s2">def </span><span class="s1">_get_mem_available():</span>
    <span class="s0">&quot;&quot;&quot;Return available memory in bytes, or None if unknown.&quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">import </span><span class="s1">psutil</span>
        <span class="s2">return </span><span class="s1">psutil.virtual_memory().available</span>
    <span class="s2">except </span><span class="s1">(ImportError</span><span class="s2">, </span><span class="s1">AttributeError):</span>
        <span class="s2">pass</span>

    <span class="s2">if </span><span class="s1">sys.platform.startswith(</span><span class="s3">'linux'</span><span class="s1">):</span>
        <span class="s1">info = {}</span>
        <span class="s2">with </span><span class="s1">open(</span><span class="s3">'/proc/meminfo'</span><span class="s2">, </span><span class="s3">'r'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
            <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">f:</span>
                <span class="s1">p = line.split()</span>
                <span class="s1">info[p[</span><span class="s5">0</span><span class="s1">].strip(</span><span class="s3">':'</span><span class="s1">).lower()] = int(p[</span><span class="s5">1</span><span class="s1">]) * </span><span class="s5">1024</span>

        <span class="s2">if </span><span class="s3">'memavailable' </span><span class="s2">in </span><span class="s1">info:</span>
            <span class="s4"># Linux &gt;= 3.14</span>
            <span class="s2">return </span><span class="s1">info[</span><span class="s3">'memavailable'</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">info[</span><span class="s3">'memfree'</span><span class="s1">] + info[</span><span class="s3">'cached'</span><span class="s1">]</span>

    <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">_no_tracing(func):</span>
    <span class="s0">&quot;&quot;&quot; 
    Decorator to temporarily turn off tracing for the duration of a test. 
    Needed in tests that check refcounting, otherwise the tracing itself 
    influences the refcounts 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">hasattr(sys</span><span class="s2">, </span><span class="s3">'gettrace'</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">func</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">@wraps(func)</span>
        <span class="s2">def </span><span class="s1">wrapper(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
            <span class="s1">original_trace = sys.gettrace()</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">sys.settrace(</span><span class="s2">None</span><span class="s1">)</span>
                <span class="s2">return </span><span class="s1">func(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s2">finally</span><span class="s1">:</span>
                <span class="s1">sys.settrace(original_trace)</span>
        <span class="s2">return </span><span class="s1">wrapper</span>

</pre>
</body>
</html>