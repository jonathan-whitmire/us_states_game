<html>
<head>
<title>_testing.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_testing.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">bz2</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">Counter</span>
<span class="s0">from </span><span class="s1">contextlib </span><span class="s0">import </span><span class="s1">contextmanager</span>
<span class="s0">from </span><span class="s1">datetime </span><span class="s0">import </span><span class="s1">datetime</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">wraps</span>
<span class="s0">import </span><span class="s1">gzip</span>
<span class="s0">import </span><span class="s1">operator</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">from </span><span class="s1">pathlib </span><span class="s0">import </span><span class="s1">Path</span>
<span class="s0">import </span><span class="s1">random</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">from </span><span class="s1">shutil </span><span class="s0">import </span><span class="s1">rmtree</span>
<span class="s0">import </span><span class="s1">string</span>
<span class="s0">import </span><span class="s1">tempfile</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">IO</span><span class="s0">, </span><span class="s1">Any</span><span class="s0">, </span><span class="s1">Callable</span><span class="s0">, </span><span class="s1">ContextManager</span><span class="s0">, </span><span class="s1">List</span><span class="s0">, </span><span class="s1">Optional</span><span class="s0">, </span><span class="s1">Type</span><span class="s0">, </span><span class="s1">Union</span><span class="s0">, </span><span class="s1">cast</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">import </span><span class="s1">zipfile</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.random </span><span class="s0">import </span><span class="s1">rand</span><span class="s0">, </span><span class="s1">randn</span>

<span class="s0">from </span><span class="s1">pandas._config.localization </span><span class="s0">import </span><span class="s1">(  </span><span class="s2"># noqa:F401</span>
    <span class="s1">can_set_locale</span><span class="s0">,</span>
    <span class="s1">get_locales</span><span class="s0">,</span>
    <span class="s1">set_locale</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">pandas._libs.lib </span><span class="s0">import </span><span class="s1">no_default</span>
<span class="s0">import </span><span class="s1">pandas._libs.testing </span><span class="s0">as </span><span class="s1">_testing</span>
<span class="s0">from </span><span class="s1">pandas._typing </span><span class="s0">import </span><span class="s1">Dtype</span><span class="s0">, </span><span class="s1">FilePathOrBuffer</span><span class="s0">, </span><span class="s1">FrameOrSeries</span>
<span class="s0">from </span><span class="s1">pandas.compat </span><span class="s0">import </span><span class="s1">get_lzma_file</span><span class="s0">, </span><span class="s1">import_lzma</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">is_bool</span><span class="s0">,</span>
    <span class="s1">is_categorical_dtype</span><span class="s0">,</span>
    <span class="s1">is_datetime64_dtype</span><span class="s0">,</span>
    <span class="s1">is_datetime64tz_dtype</span><span class="s0">,</span>
    <span class="s1">is_extension_array_dtype</span><span class="s0">,</span>
    <span class="s1">is_interval_dtype</span><span class="s0">,</span>
    <span class="s1">is_number</span><span class="s0">,</span>
    <span class="s1">is_numeric_dtype</span><span class="s0">,</span>
    <span class="s1">is_period_dtype</span><span class="s0">,</span>
    <span class="s1">is_sequence</span><span class="s0">,</span>
    <span class="s1">is_timedelta64_dtype</span><span class="s0">,</span>
    <span class="s1">needs_i8_conversion</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.missing </span><span class="s0">import </span><span class="s1">array_equivalent</span>

<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Categorical</span><span class="s0">,</span>
    <span class="s1">CategoricalIndex</span><span class="s0">,</span>
    <span class="s1">DataFrame</span><span class="s0">,</span>
    <span class="s1">DatetimeIndex</span><span class="s0">,</span>
    <span class="s1">Index</span><span class="s0">,</span>
    <span class="s1">IntervalIndex</span><span class="s0">,</span>
    <span class="s1">MultiIndex</span><span class="s0">,</span>
    <span class="s1">RangeIndex</span><span class="s0">,</span>
    <span class="s1">Series</span><span class="s0">,</span>
    <span class="s1">bdate_range</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.algorithms </span><span class="s0">import </span><span class="s1">safe_sort</span><span class="s0">, </span><span class="s1">take_1d</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DatetimeArray</span><span class="s0">,</span>
    <span class="s1">ExtensionArray</span><span class="s0">,</span>
    <span class="s1">IntervalArray</span><span class="s0">,</span>
    <span class="s1">PeriodArray</span><span class="s0">,</span>
    <span class="s1">TimedeltaArray</span><span class="s0">,</span>
    <span class="s1">period_array</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays.datetimelike </span><span class="s0">import </span><span class="s1">DatetimeLikeArrayMixin</span>

<span class="s0">from </span><span class="s1">pandas.io.common </span><span class="s0">import </span><span class="s1">urlopen</span>
<span class="s0">from </span><span class="s1">pandas.io.formats.printing </span><span class="s0">import </span><span class="s1">pprint_thing</span>

<span class="s1">lzma = import_lzma()</span>

<span class="s1">_N = </span><span class="s3">30</span>
<span class="s1">_K = </span><span class="s3">4</span>
<span class="s1">_RAISE_NETWORK_ERROR_DEFAULT = </span><span class="s0">False</span>

<span class="s1">UNSIGNED_INT_DTYPES: List[Dtype] = [</span><span class="s4">&quot;uint8&quot;</span><span class="s0">, </span><span class="s4">&quot;uint16&quot;</span><span class="s0">, </span><span class="s4">&quot;uint32&quot;</span><span class="s0">, </span><span class="s4">&quot;uint64&quot;</span><span class="s1">]</span>
<span class="s1">UNSIGNED_EA_INT_DTYPES: List[Dtype] = [</span><span class="s4">&quot;UInt8&quot;</span><span class="s0">, </span><span class="s4">&quot;UInt16&quot;</span><span class="s0">, </span><span class="s4">&quot;UInt32&quot;</span><span class="s0">, </span><span class="s4">&quot;UInt64&quot;</span><span class="s1">]</span>
<span class="s1">SIGNED_INT_DTYPES: List[Dtype] = [int</span><span class="s0">, </span><span class="s4">&quot;int8&quot;</span><span class="s0">, </span><span class="s4">&quot;int16&quot;</span><span class="s0">, </span><span class="s4">&quot;int32&quot;</span><span class="s0">, </span><span class="s4">&quot;int64&quot;</span><span class="s1">]</span>
<span class="s1">SIGNED_EA_INT_DTYPES: List[Dtype] = [</span><span class="s4">&quot;Int8&quot;</span><span class="s0">, </span><span class="s4">&quot;Int16&quot;</span><span class="s0">, </span><span class="s4">&quot;Int32&quot;</span><span class="s0">, </span><span class="s4">&quot;Int64&quot;</span><span class="s1">]</span>
<span class="s1">ALL_INT_DTYPES = UNSIGNED_INT_DTYPES + SIGNED_INT_DTYPES</span>
<span class="s1">ALL_EA_INT_DTYPES = UNSIGNED_EA_INT_DTYPES + SIGNED_EA_INT_DTYPES</span>

<span class="s1">FLOAT_DTYPES: List[Dtype] = [float</span><span class="s0">, </span><span class="s4">&quot;float32&quot;</span><span class="s0">, </span><span class="s4">&quot;float64&quot;</span><span class="s1">]</span>
<span class="s1">FLOAT_EA_DTYPES: List[Dtype] = [</span><span class="s4">&quot;Float32&quot;</span><span class="s0">, </span><span class="s4">&quot;Float64&quot;</span><span class="s1">]</span>
<span class="s1">COMPLEX_DTYPES: List[Dtype] = [complex</span><span class="s0">, </span><span class="s4">&quot;complex64&quot;</span><span class="s0">, </span><span class="s4">&quot;complex128&quot;</span><span class="s1">]</span>
<span class="s1">STRING_DTYPES: List[Dtype] = [str</span><span class="s0">, </span><span class="s4">&quot;str&quot;</span><span class="s0">, </span><span class="s4">&quot;U&quot;</span><span class="s1">]</span>

<span class="s1">DATETIME64_DTYPES: List[Dtype] = [</span><span class="s4">&quot;datetime64[ns]&quot;</span><span class="s0">, </span><span class="s4">&quot;M8[ns]&quot;</span><span class="s1">]</span>
<span class="s1">TIMEDELTA64_DTYPES: List[Dtype] = [</span><span class="s4">&quot;timedelta64[ns]&quot;</span><span class="s0">, </span><span class="s4">&quot;m8[ns]&quot;</span><span class="s1">]</span>

<span class="s1">BOOL_DTYPES = [bool</span><span class="s0">, </span><span class="s4">&quot;bool&quot;</span><span class="s1">]</span>
<span class="s1">BYTES_DTYPES = [bytes</span><span class="s0">, </span><span class="s4">&quot;bytes&quot;</span><span class="s1">]</span>
<span class="s1">OBJECT_DTYPES = [object</span><span class="s0">, </span><span class="s4">&quot;object&quot;</span><span class="s1">]</span>

<span class="s1">ALL_REAL_DTYPES = FLOAT_DTYPES + ALL_INT_DTYPES</span>
<span class="s1">ALL_NUMPY_DTYPES = (</span>
    <span class="s1">ALL_REAL_DTYPES</span>
    <span class="s1">+ COMPLEX_DTYPES</span>
    <span class="s1">+ STRING_DTYPES</span>
    <span class="s1">+ DATETIME64_DTYPES</span>
    <span class="s1">+ TIMEDELTA64_DTYPES</span>
    <span class="s1">+ BOOL_DTYPES</span>
    <span class="s1">+ OBJECT_DTYPES</span>
    <span class="s1">+ BYTES_DTYPES</span>
<span class="s1">)</span>

<span class="s1">NULL_OBJECTS = [</span><span class="s0">None, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">pd.NaT</span><span class="s0">, </span><span class="s1">float(</span><span class="s4">&quot;nan&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pd.NA]</span>


<span class="s2"># set testing_mode</span>
<span class="s1">_testing_mode_warnings = (DeprecationWarning</span><span class="s0">, </span><span class="s1">ResourceWarning)</span>


<span class="s0">def </span><span class="s1">set_testing_mode():</span>
    <span class="s2"># set the testing mode filters</span>
    <span class="s1">testing_mode = os.environ.get(</span><span class="s4">&quot;PANDAS_TESTING_MODE&quot;</span><span class="s0">, </span><span class="s4">&quot;None&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s4">&quot;deprecate&quot; </span><span class="s0">in </span><span class="s1">testing_mode:</span>
        <span class="s2"># pandas\_testing.py:119: error: Argument 2 to &quot;simplefilter&quot; has</span>
        <span class="s2"># incompatible type &quot;Tuple[Type[DeprecationWarning],</span>
        <span class="s2"># Type[ResourceWarning]]&quot;; expected &quot;Type[Warning]&quot;</span>
        <span class="s1">warnings.simplefilter(</span>
            <span class="s4">&quot;always&quot;</span><span class="s0">, </span><span class="s1">_testing_mode_warnings  </span><span class="s2"># type: ignore[arg-type]</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">reset_testing_mode():</span>
    <span class="s2"># reset the testing mode filters</span>
    <span class="s1">testing_mode = os.environ.get(</span><span class="s4">&quot;PANDAS_TESTING_MODE&quot;</span><span class="s0">, </span><span class="s4">&quot;None&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s4">&quot;deprecate&quot; </span><span class="s0">in </span><span class="s1">testing_mode:</span>
        <span class="s2"># pandas\_testing.py:126: error: Argument 2 to &quot;simplefilter&quot; has</span>
        <span class="s2"># incompatible type &quot;Tuple[Type[DeprecationWarning],</span>
        <span class="s2"># Type[ResourceWarning]]&quot;; expected &quot;Type[Warning]&quot;</span>
        <span class="s1">warnings.simplefilter(</span>
            <span class="s4">&quot;ignore&quot;</span><span class="s0">, </span><span class="s1">_testing_mode_warnings  </span><span class="s2"># type: ignore[arg-type]</span>
        <span class="s1">)</span>


<span class="s1">set_testing_mode()</span>


<span class="s0">def </span><span class="s1">reset_display_options():</span>
    <span class="s5">&quot;&quot;&quot; 
    Reset the display options for printing and representing objects. 
    &quot;&quot;&quot;</span>
    <span class="s1">pd.reset_option(</span><span class="s4">&quot;^display.&quot;</span><span class="s0">, </span><span class="s1">silent=</span><span class="s0">True</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">round_trip_pickle(</span>
    <span class="s1">obj: Any</span><span class="s0">, </span><span class="s1">path: Optional[FilePathOrBuffer] = </span><span class="s0">None</span>
<span class="s1">) -&gt; FrameOrSeries:</span>
    <span class="s5">&quot;&quot;&quot; 
    Pickle an object and then read it again. 
 
    Parameters 
    ---------- 
    obj : any object 
        The object to pickle and then re-read. 
    path : str, path object or file-like object, default None 
        The path where the pickled object is written and then read. 
 
    Returns 
    ------- 
    pandas object 
        The original object that was pickled and then re-read. 
    &quot;&quot;&quot;</span>
    <span class="s1">_path = path</span>
    <span class="s0">if </span><span class="s1">_path </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">_path = </span><span class="s4">f&quot;__</span><span class="s0">{</span><span class="s1">rands(</span><span class="s3">10</span><span class="s1">)</span><span class="s0">}</span><span class="s4">__.pickle&quot;</span>
    <span class="s0">with </span><span class="s1">ensure_clean(_path) </span><span class="s0">as </span><span class="s1">temp_path:</span>
        <span class="s1">pd.to_pickle(obj</span><span class="s0">, </span><span class="s1">temp_path)</span>
        <span class="s0">return </span><span class="s1">pd.read_pickle(temp_path)</span>


<span class="s0">def </span><span class="s1">round_trip_pathlib(writer</span><span class="s0">, </span><span class="s1">reader</span><span class="s0">, </span><span class="s1">path: Optional[str] = </span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Write an object to file specified by a pathlib.Path and read it back 
 
    Parameters 
    ---------- 
    writer : callable bound to pandas object 
        IO writing function (e.g. DataFrame.to_csv ) 
    reader : callable 
        IO reading function (e.g. pd.read_csv ) 
    path : str, default None 
        The path where the object is written and then read. 
 
    Returns 
    ------- 
    pandas object 
        The original object that was serialized and then re-read. 
    &quot;&quot;&quot;</span>
    <span class="s0">import </span><span class="s1">pytest</span>

    <span class="s1">Path = pytest.importorskip(</span><span class="s4">&quot;pathlib&quot;</span><span class="s1">).Path</span>
    <span class="s0">if </span><span class="s1">path </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">path = </span><span class="s4">&quot;___pathlib___&quot;</span>
    <span class="s0">with </span><span class="s1">ensure_clean(path) </span><span class="s0">as </span><span class="s1">path:</span>
        <span class="s1">writer(Path(path))</span>
        <span class="s1">obj = reader(Path(path))</span>
    <span class="s0">return </span><span class="s1">obj</span>


<span class="s0">def </span><span class="s1">round_trip_localpath(writer</span><span class="s0">, </span><span class="s1">reader</span><span class="s0">, </span><span class="s1">path: Optional[str] = </span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Write an object to file specified by a py.path LocalPath and read it back. 
 
    Parameters 
    ---------- 
    writer : callable bound to pandas object 
        IO writing function (e.g. DataFrame.to_csv ) 
    reader : callable 
        IO reading function (e.g. pd.read_csv ) 
    path : str, default None 
        The path where the object is written and then read. 
 
    Returns 
    ------- 
    pandas object 
        The original object that was serialized and then re-read. 
    &quot;&quot;&quot;</span>
    <span class="s0">import </span><span class="s1">pytest</span>

    <span class="s1">LocalPath = pytest.importorskip(</span><span class="s4">&quot;py.path&quot;</span><span class="s1">).local</span>
    <span class="s0">if </span><span class="s1">path </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">path = </span><span class="s4">&quot;___localpath___&quot;</span>
    <span class="s0">with </span><span class="s1">ensure_clean(path) </span><span class="s0">as </span><span class="s1">path:</span>
        <span class="s1">writer(LocalPath(path))</span>
        <span class="s1">obj = reader(LocalPath(path))</span>
    <span class="s0">return </span><span class="s1">obj</span>


<span class="s1">@contextmanager</span>
<span class="s0">def </span><span class="s1">decompress_file(path</span><span class="s0">, </span><span class="s1">compression):</span>
    <span class="s5">&quot;&quot;&quot; 
    Open a compressed file and return a file object. 
 
    Parameters 
    ---------- 
    path : str 
        The path where the file is read from. 
 
    compression : {'gzip', 'bz2', 'zip', 'xz', None} 
        Name of the decompression to use 
 
    Returns 
    ------- 
    file object 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">compression </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">f = open(path</span><span class="s0">, </span><span class="s4">&quot;rb&quot;</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">compression == </span><span class="s4">&quot;gzip&quot;</span><span class="s1">:</span>
        <span class="s2"># pandas\_testing.py:243: error: Incompatible types in assignment</span>
        <span class="s2"># (expression has type &quot;IO[Any]&quot;, variable has type &quot;BinaryIO&quot;)</span>
        <span class="s1">f = gzip.open(path</span><span class="s0">, </span><span class="s4">&quot;rb&quot;</span><span class="s1">)  </span><span class="s2"># type: ignore[assignment]</span>
    <span class="s0">elif </span><span class="s1">compression == </span><span class="s4">&quot;bz2&quot;</span><span class="s1">:</span>
        <span class="s2"># pandas\_testing.py:245: error: Incompatible types in assignment</span>
        <span class="s2"># (expression has type &quot;BZ2File&quot;, variable has type &quot;BinaryIO&quot;)</span>
        <span class="s1">f = bz2.BZ2File(path</span><span class="s0">, </span><span class="s4">&quot;rb&quot;</span><span class="s1">)  </span><span class="s2"># type: ignore[assignment]</span>
    <span class="s0">elif </span><span class="s1">compression == </span><span class="s4">&quot;xz&quot;</span><span class="s1">:</span>
        <span class="s1">f = get_lzma_file(lzma)(path</span><span class="s0">, </span><span class="s4">&quot;rb&quot;</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">compression == </span><span class="s4">&quot;zip&quot;</span><span class="s1">:</span>
        <span class="s1">zip_file = zipfile.ZipFile(path)</span>
        <span class="s1">zip_names = zip_file.namelist()</span>
        <span class="s0">if </span><span class="s1">len(zip_names) == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s2"># pandas\_testing.py:252: error: Incompatible types in assignment</span>
            <span class="s2"># (expression has type &quot;IO[bytes]&quot;, variable has type &quot;BinaryIO&quot;)</span>
            <span class="s1">f = zip_file.open(zip_names.pop())  </span><span class="s2"># type: ignore[assignment]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;ZIP file </span><span class="s0">{</span><span class="s1">path</span><span class="s0">} </span><span class="s4">error. Only one file per ZIP.&quot;</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Unrecognized compression type: </span><span class="s0">{</span><span class="s1">compression</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">yield </span><span class="s1">f</span>
    <span class="s0">finally</span><span class="s1">:</span>
        <span class="s1">f.close()</span>
        <span class="s0">if </span><span class="s1">compression == </span><span class="s4">&quot;zip&quot;</span><span class="s1">:</span>
            <span class="s1">zip_file.close()</span>


<span class="s0">def </span><span class="s1">write_to_compressed(compression</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">dest=</span><span class="s4">&quot;test&quot;</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Write data to a compressed file. 
 
    Parameters 
    ---------- 
    compression : {'gzip', 'bz2', 'zip', 'xz'} 
        The compression type to use. 
    path : str 
        The file path to write the data. 
    data : str 
        The data to write. 
    dest : str, default &quot;test&quot; 
        The destination file (for ZIP only) 
 
    Raises 
    ------ 
    ValueError : An invalid compression value was passed in. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">compression == </span><span class="s4">&quot;zip&quot;</span><span class="s1">:</span>
        <span class="s1">compress_method = zipfile.ZipFile</span>
    <span class="s0">elif </span><span class="s1">compression == </span><span class="s4">&quot;gzip&quot;</span><span class="s1">:</span>
        <span class="s2"># pandas\_testing.py:288: error: Incompatible types in assignment</span>
        <span class="s2"># (expression has type &quot;Type[GzipFile]&quot;, variable has type</span>
        <span class="s2"># &quot;Type[ZipFile]&quot;)</span>
        <span class="s1">compress_method = gzip.GzipFile  </span><span class="s2"># type: ignore[assignment]</span>
    <span class="s0">elif </span><span class="s1">compression == </span><span class="s4">&quot;bz2&quot;</span><span class="s1">:</span>
        <span class="s2"># pandas\_testing.py:290: error: Incompatible types in assignment</span>
        <span class="s2"># (expression has type &quot;Type[BZ2File]&quot;, variable has type</span>
        <span class="s2"># &quot;Type[ZipFile]&quot;)</span>
        <span class="s1">compress_method = bz2.BZ2File  </span><span class="s2"># type: ignore[assignment]</span>
    <span class="s0">elif </span><span class="s1">compression == </span><span class="s4">&quot;xz&quot;</span><span class="s1">:</span>
        <span class="s1">compress_method = get_lzma_file(lzma)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Unrecognized compression type: </span><span class="s0">{</span><span class="s1">compression</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">compression == </span><span class="s4">&quot;zip&quot;</span><span class="s1">:</span>
        <span class="s1">mode = </span><span class="s4">&quot;w&quot;</span>
        <span class="s1">args = (dest</span><span class="s0">, </span><span class="s1">data)</span>
        <span class="s1">method = </span><span class="s4">&quot;writestr&quot;</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">mode = </span><span class="s4">&quot;wb&quot;</span>
        <span class="s2"># pandas\_testing.py:302: error: Incompatible types in assignment</span>
        <span class="s2"># (expression has type &quot;Tuple[Any]&quot;, variable has type &quot;Tuple[Any,</span>
        <span class="s2"># Any]&quot;)</span>
        <span class="s1">args = (data</span><span class="s0">,</span><span class="s1">)  </span><span class="s2"># type: ignore[assignment]</span>
        <span class="s1">method = </span><span class="s4">&quot;write&quot;</span>

    <span class="s0">with </span><span class="s1">compress_method(path</span><span class="s0">, </span><span class="s1">mode=mode) </span><span class="s0">as </span><span class="s1">f:</span>
        <span class="s1">getattr(f</span><span class="s0">, </span><span class="s1">method)(*args)</span>


<span class="s0">def </span><span class="s1">_get_tol_from_less_precise(check_less_precise: Union[bool</span><span class="s0">, </span><span class="s1">int]) -&gt; float:</span>
    <span class="s5">&quot;&quot;&quot; 
    Return the tolerance equivalent to the deprecated `check_less_precise` 
    parameter. 
 
    Parameters 
    ---------- 
    check_less_precise : bool or int 
 
    Returns 
    ------- 
    float 
        Tolerance to be used as relative/absolute tolerance. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; # Using check_less_precise as a bool: 
    &gt;&gt;&gt; _get_tol_from_less_precise(False) 
    0.5e-5 
    &gt;&gt;&gt; _get_tol_from_less_precise(True) 
    0.5e-3 
    &gt;&gt;&gt; # Using check_less_precise as an int representing the decimal 
    &gt;&gt;&gt; # tolerance intended: 
    &gt;&gt;&gt; _get_tol_from_less_precise(2) 
    0.5e-2 
    &gt;&gt;&gt; _get_tol_from_less_precise(8) 
    0.5e-8 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance(check_less_precise</span><span class="s0">, </span><span class="s1">bool):</span>
        <span class="s0">if </span><span class="s1">check_less_precise:</span>
            <span class="s2"># 3-digit tolerance</span>
            <span class="s0">return </span><span class="s3">0.5e-3</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># 5-digit tolerance</span>
            <span class="s0">return </span><span class="s3">0.5e-5</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s2"># Equivalent to setting checking_less_precise=&lt;decimals&gt;</span>
        <span class="s0">return </span><span class="s3">0.5 </span><span class="s1">* </span><span class="s3">10 </span><span class="s1">** -check_less_precise</span>


<span class="s0">def </span><span class="s1">assert_almost_equal(</span>
    <span class="s1">left</span><span class="s0">,</span>
    <span class="s1">right</span><span class="s0">,</span>
    <span class="s1">check_dtype: Union[bool</span><span class="s0">, </span><span class="s1">str] = </span><span class="s4">&quot;equiv&quot;</span><span class="s0">,</span>
    <span class="s1">check_less_precise: Union[bool</span><span class="s0">, </span><span class="s1">int] = no_default</span><span class="s0">,</span>
    <span class="s1">rtol: float = </span><span class="s3">1.0e-5</span><span class="s0">,</span>
    <span class="s1">atol: float = </span><span class="s3">1.0e-8</span><span class="s0">,</span>
    <span class="s1">**kwargs</span><span class="s0">,</span>
<span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Check that the left and right objects are approximately equal. 
 
    By approximately equal, we refer to objects that are numbers or that 
    contain numbers which may be equivalent to specific levels of precision. 
 
    Parameters 
    ---------- 
    left : object 
    right : object 
    check_dtype : bool or {'equiv'}, default 'equiv' 
        Check dtype if both a and b are the same type. If 'equiv' is passed in, 
        then `RangeIndex` and `Int64Index` are also considered equivalent 
        when doing type checking. 
    check_less_precise : bool or int, default False 
        Specify comparison precision. 5 digits (False) or 3 digits (True) 
        after decimal points are compared. If int, then specify the number 
        of digits to compare. 
 
        When comparing two numbers, if the first number has magnitude less 
        than 1e-5, we compare the two numbers directly and check whether 
        they are equivalent within the specified precision. Otherwise, we 
        compare the **ratio** of the second number to the first number and 
        check whether it is equivalent to 1 within the specified precision. 
 
        .. deprecated:: 1.1.0 
           Use `rtol` and `atol` instead to define relative/absolute 
           tolerance, respectively. Similar to :func:`math.isclose`. 
    rtol : float, default 1e-5 
        Relative tolerance. 
 
        .. versionadded:: 1.1.0 
    atol : float, default 1e-8 
        Absolute tolerance. 
 
        .. versionadded:: 1.1.0 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">check_less_precise </span><span class="s0">is not </span><span class="s1">no_default:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s4">&quot;The 'check_less_precise' keyword in testing.assert_*_equal &quot;</span>
            <span class="s4">&quot;is deprecated and will be removed in a future version. &quot;</span>
            <span class="s4">&quot;You can stop passing 'check_less_precise' to silence this warning.&quot;</span><span class="s0">,</span>
            <span class="s1">FutureWarning</span><span class="s0">,</span>
            <span class="s1">stacklevel=</span><span class="s3">2</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">rtol = atol = _get_tol_from_less_precise(check_less_precise)</span>

    <span class="s0">if </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">pd.Index):</span>
        <span class="s1">assert_index_equal(</span>
            <span class="s1">left</span><span class="s0">,</span>
            <span class="s1">right</span><span class="s0">,</span>
            <span class="s1">check_exact=</span><span class="s0">False,</span>
            <span class="s1">exact=check_dtype</span><span class="s0">,</span>
            <span class="s1">rtol=rtol</span><span class="s0">,</span>
            <span class="s1">atol=atol</span><span class="s0">,</span>
            <span class="s1">**kwargs</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">elif </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">pd.Series):</span>
        <span class="s1">assert_series_equal(</span>
            <span class="s1">left</span><span class="s0">,</span>
            <span class="s1">right</span><span class="s0">,</span>
            <span class="s1">check_exact=</span><span class="s0">False,</span>
            <span class="s1">check_dtype=check_dtype</span><span class="s0">,</span>
            <span class="s1">rtol=rtol</span><span class="s0">,</span>
            <span class="s1">atol=atol</span><span class="s0">,</span>
            <span class="s1">**kwargs</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">elif </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">pd.DataFrame):</span>
        <span class="s1">assert_frame_equal(</span>
            <span class="s1">left</span><span class="s0">,</span>
            <span class="s1">right</span><span class="s0">,</span>
            <span class="s1">check_exact=</span><span class="s0">False,</span>
            <span class="s1">check_dtype=check_dtype</span><span class="s0">,</span>
            <span class="s1">rtol=rtol</span><span class="s0">,</span>
            <span class="s1">atol=atol</span><span class="s0">,</span>
            <span class="s1">**kwargs</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">else</span><span class="s1">:</span>
        <span class="s2"># Other sequences.</span>
        <span class="s0">if </span><span class="s1">check_dtype:</span>
            <span class="s0">if </span><span class="s1">is_number(left) </span><span class="s0">and </span><span class="s1">is_number(right):</span>
                <span class="s2"># Do not compare numeric classes, like np.float64 and float.</span>
                <span class="s0">pass</span>
            <span class="s0">elif </span><span class="s1">is_bool(left) </span><span class="s0">and </span><span class="s1">is_bool(right):</span>
                <span class="s2"># Do not compare bool classes, like np.bool_ and bool.</span>
                <span class="s0">pass</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">or </span><span class="s1">isinstance(right</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
                    <span class="s1">obj = </span><span class="s4">&quot;numpy array&quot;</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">obj = </span><span class="s4">&quot;Input&quot;</span>
                <span class="s1">assert_class_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>
        <span class="s1">_testing.assert_almost_equal(</span>
            <span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">check_dtype=check_dtype</span><span class="s0">, </span><span class="s1">rtol=rtol</span><span class="s0">, </span><span class="s1">atol=atol</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_check_isinstance(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">cls):</span>
    <span class="s5">&quot;&quot;&quot; 
    Helper method for our assert_* methods that ensures that 
    the two objects being compared have the right type before 
    proceeding with the comparison. 
 
    Parameters 
    ---------- 
    left : The first object being compared. 
    right : The second object being compared. 
    cls : The class type to check against. 
 
    Raises 
    ------ 
    AssertionError : Either `left` or `right` is not an instance of `cls`. 
    &quot;&quot;&quot;</span>
    <span class="s1">cls_name = cls.__name__</span>

    <span class="s0">if not </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">cls):</span>
        <span class="s0">raise </span><span class="s1">AssertionError(</span>
            <span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">cls_name</span><span class="s0">} </span><span class="s4">Expected type </span><span class="s0">{</span><span class="s1">cls</span><span class="s0">}</span><span class="s4">, found </span><span class="s0">{</span><span class="s1">type(left)</span><span class="s0">} </span><span class="s4">instead&quot;</span>
        <span class="s1">)</span>
    <span class="s0">if not </span><span class="s1">isinstance(right</span><span class="s0">, </span><span class="s1">cls):</span>
        <span class="s0">raise </span><span class="s1">AssertionError(</span>
            <span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">cls_name</span><span class="s0">} </span><span class="s4">Expected type </span><span class="s0">{</span><span class="s1">cls</span><span class="s0">}</span><span class="s4">, found </span><span class="s0">{</span><span class="s1">type(right)</span><span class="s0">} </span><span class="s4">instead&quot;</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">assert_dict_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">compare_keys: bool = </span><span class="s0">True</span><span class="s1">):</span>

    <span class="s1">_check_isinstance(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">dict)</span>
    <span class="s1">_testing.assert_dict_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">compare_keys=compare_keys)</span>


<span class="s0">def </span><span class="s1">randbool(size=()</span><span class="s0">, </span><span class="s1">p: float = </span><span class="s3">0.5</span><span class="s1">):</span>
    <span class="s0">return </span><span class="s1">rand(*size) &lt;= p</span>


<span class="s1">RANDS_CHARS = np.array(list(string.ascii_letters + string.digits)</span><span class="s0">, </span><span class="s1">dtype=(np.str_</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
<span class="s1">RANDU_CHARS = np.array(</span>
    <span class="s1">list(</span><span class="s4">&quot;&quot;</span><span class="s1">.join(map(chr</span><span class="s0">, </span><span class="s1">range(</span><span class="s3">1488</span><span class="s0">, </span><span class="s3">1488 </span><span class="s1">+ </span><span class="s3">26</span><span class="s1">))) + string.digits)</span><span class="s0">,</span>
    <span class="s1">dtype=(np.unicode_</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
<span class="s1">)</span>


<span class="s0">def </span><span class="s1">rands_array(nchars</span><span class="s0">, </span><span class="s1">size</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;O&quot;</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Generate an array of byte strings. 
    &quot;&quot;&quot;</span>
    <span class="s1">retval = (</span>
        <span class="s1">np.random.choice(RANDS_CHARS</span><span class="s0">, </span><span class="s1">size=nchars * np.prod(size))</span>
        <span class="s1">.view((np.str_</span><span class="s0">, </span><span class="s1">nchars))</span>
        <span class="s1">.reshape(size)</span>
    <span class="s1">)</span>
    <span class="s0">return </span><span class="s1">retval.astype(dtype)</span>


<span class="s0">def </span><span class="s1">randu_array(nchars</span><span class="s0">, </span><span class="s1">size</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;O&quot;</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Generate an array of unicode strings. 
    &quot;&quot;&quot;</span>
    <span class="s1">retval = (</span>
        <span class="s1">np.random.choice(RANDU_CHARS</span><span class="s0">, </span><span class="s1">size=nchars * np.prod(size))</span>
        <span class="s1">.view((np.unicode_</span><span class="s0">, </span><span class="s1">nchars))</span>
        <span class="s1">.reshape(size)</span>
    <span class="s1">)</span>
    <span class="s0">return </span><span class="s1">retval.astype(dtype)</span>


<span class="s0">def </span><span class="s1">rands(nchars):</span>
    <span class="s5">&quot;&quot;&quot; 
    Generate one random byte string. 
 
    See `rands_array` if you want to create an array of random strings. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s4">&quot;&quot;</span><span class="s1">.join(np.random.choice(RANDS_CHARS</span><span class="s0">, </span><span class="s1">nchars))</span>


<span class="s0">def </span><span class="s1">close(fignum=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">from </span><span class="s1">matplotlib.pyplot </span><span class="s0">import </span><span class="s1">close </span><span class="s0">as </span><span class="s1">_close</span><span class="s0">, </span><span class="s1">get_fignums</span>

    <span class="s0">if </span><span class="s1">fignum </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">for </span><span class="s1">fignum </span><span class="s0">in </span><span class="s1">get_fignums():</span>
            <span class="s1">_close(fignum)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">_close(fignum)</span>


<span class="s2"># -----------------------------------------------------------------------------</span>
<span class="s2"># contextmanager to ensure the file cleanup</span>


<span class="s1">@contextmanager</span>
<span class="s0">def </span><span class="s1">ensure_clean(filename=</span><span class="s0">None, </span><span class="s1">return_filelike: bool = </span><span class="s0">False, </span><span class="s1">**kwargs: Any):</span>
    <span class="s5">&quot;&quot;&quot; 
    Gets a temporary path and agrees to remove on close. 
 
    This implementation does not use tempfile.mkstemp to avoid having a file handle. 
    If the code using the returned path wants to delete the file itself, windows 
    requires that no program has a file handle to it. 
 
    Parameters 
    ---------- 
    filename : str (optional) 
        suffix of the created file. 
    return_filelike : bool (default False) 
        if True, returns a file-like which is *always* cleaned. Necessary for 
        savefig and other functions which want to append extensions. 
    **kwargs 
        Additional keywords are passed to open(). 
 
    &quot;&quot;&quot;</span>
    <span class="s1">folder = Path(tempfile.gettempdir())</span>

    <span class="s0">if </span><span class="s1">filename </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">filename = </span><span class="s4">&quot;&quot;</span>
    <span class="s1">filename = (</span>
        <span class="s4">&quot;&quot;</span><span class="s1">.join(random.choices(string.ascii_letters + string.digits</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">30</span><span class="s1">)) + filename</span>
    <span class="s1">)</span>
    <span class="s1">path = folder / filename</span>

    <span class="s1">path.touch()</span>

    <span class="s1">handle_or_str: Union[str</span><span class="s0">, </span><span class="s1">IO] = str(path)</span>
    <span class="s0">if </span><span class="s1">return_filelike:</span>
        <span class="s1">kwargs.setdefault(</span><span class="s4">&quot;mode&quot;</span><span class="s0">, </span><span class="s4">&quot;w+b&quot;</span><span class="s1">)</span>
        <span class="s1">handle_or_str = open(path</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">yield </span><span class="s1">handle_or_str</span>
    <span class="s0">finally</span><span class="s1">:</span>
        <span class="s0">if not </span><span class="s1">isinstance(handle_or_str</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">handle_or_str.close()</span>
        <span class="s0">if </span><span class="s1">path.is_file():</span>
            <span class="s1">path.unlink()</span>


<span class="s1">@contextmanager</span>
<span class="s0">def </span><span class="s1">ensure_clean_dir():</span>
    <span class="s5">&quot;&quot;&quot; 
    Get a temporary directory path and agrees to remove on close. 
 
    Yields 
    ------ 
    Temporary directory path 
    &quot;&quot;&quot;</span>
    <span class="s1">directory_name = tempfile.mkdtemp(suffix=</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">yield </span><span class="s1">directory_name</span>
    <span class="s0">finally</span><span class="s1">:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">rmtree(directory_name)</span>
        <span class="s0">except </span><span class="s1">OSError:</span>
            <span class="s0">pass</span>


<span class="s1">@contextmanager</span>
<span class="s0">def </span><span class="s1">ensure_safe_environment_variables():</span>
    <span class="s5">&quot;&quot;&quot; 
    Get a context manager to safely set environment variables 
 
    All changes will be undone on close, hence environment variables set 
    within this contextmanager will neither persist nor change global state. 
    &quot;&quot;&quot;</span>
    <span class="s1">saved_environ = dict(os.environ)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">yield</span>
    <span class="s0">finally</span><span class="s1">:</span>
        <span class="s1">os.environ.clear()</span>
        <span class="s1">os.environ.update(saved_environ)</span>


<span class="s2"># -----------------------------------------------------------------------------</span>
<span class="s2"># Comparators</span>


<span class="s0">def </span><span class="s1">equalContents(arr1</span><span class="s0">, </span><span class="s1">arr2) -&gt; bool:</span>
    <span class="s5">&quot;&quot;&quot; 
    Checks if the set of unique elements of arr1 and arr2 are equivalent. 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">frozenset(arr1) == frozenset(arr2)</span>


<span class="s0">def </span><span class="s1">assert_index_equal(</span>
    <span class="s1">left: Index</span><span class="s0">,</span>
    <span class="s1">right: Index</span><span class="s0">,</span>
    <span class="s1">exact: Union[bool</span><span class="s0">, </span><span class="s1">str] = </span><span class="s4">&quot;equiv&quot;</span><span class="s0">,</span>
    <span class="s1">check_names: bool = </span><span class="s0">True,</span>
    <span class="s1">check_less_precise: Union[bool</span><span class="s0">, </span><span class="s1">int] = no_default</span><span class="s0">,</span>
    <span class="s1">check_exact: bool = </span><span class="s0">True,</span>
    <span class="s1">check_categorical: bool = </span><span class="s0">True,</span>
    <span class="s1">check_order: bool = </span><span class="s0">True,</span>
    <span class="s1">rtol: float = </span><span class="s3">1.0e-5</span><span class="s0">,</span>
    <span class="s1">atol: float = </span><span class="s3">1.0e-8</span><span class="s0">,</span>
    <span class="s1">obj: str = </span><span class="s4">&quot;Index&quot;</span><span class="s0">,</span>
<span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
    <span class="s5">&quot;&quot;&quot; 
    Check that left and right Index are equal. 
 
    Parameters 
    ---------- 
    left : Index 
    right : Index 
    exact : bool or {'equiv'}, default 'equiv' 
        Whether to check the Index class, dtype and inferred_type 
        are identical. If 'equiv', then RangeIndex can be substituted for 
        Int64Index as well. 
    check_names : bool, default True 
        Whether to check the names attribute. 
    check_less_precise : bool or int, default False 
        Specify comparison precision. Only used when check_exact is False. 
        5 digits (False) or 3 digits (True) after decimal points are compared. 
        If int, then specify the digits to compare. 
 
        .. deprecated:: 1.1.0 
           Use `rtol` and `atol` instead to define relative/absolute 
           tolerance, respectively. Similar to :func:`math.isclose`. 
    check_exact : bool, default True 
        Whether to compare number exactly. 
    check_categorical : bool, default True 
        Whether to compare internal Categorical exactly. 
    check_order : bool, default True 
        Whether to compare the order of index entries as well as their values. 
        If True, both indexes must contain the same elements, in the same order. 
        If False, both indexes must contain the same elements, but in any order. 
 
        .. versionadded:: 1.2.0 
    rtol : float, default 1e-5 
        Relative tolerance. Only used when check_exact is False. 
 
        .. versionadded:: 1.1.0 
    atol : float, default 1e-8 
        Absolute tolerance. Only used when check_exact is False. 
 
        .. versionadded:: 1.1.0 
    obj : str, default 'Index' 
        Specify object name being compared, internally used to show appropriate 
        assertion message. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from pandas.testing import assert_index_equal 
    &gt;&gt;&gt; a = pd.Index([1, 2, 3]) 
    &gt;&gt;&gt; b = pd.Index([1, 2, 3]) 
    &gt;&gt;&gt; assert_index_equal(a, b) 
    &quot;&quot;&quot;</span>
    <span class="s1">__tracebackhide__ = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">_check_types(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=</span><span class="s4">&quot;Index&quot;</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">exact:</span>
            <span class="s1">assert_class_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">exact=exact</span><span class="s0">, </span><span class="s1">obj=obj)</span>

            <span class="s2"># Skip exact dtype checking when `check_categorical` is False</span>
            <span class="s0">if </span><span class="s1">check_categorical:</span>
                <span class="s1">assert_attr_equal(</span><span class="s4">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>

            <span class="s2"># allow string-like to have different inferred_types</span>
            <span class="s0">if </span><span class="s1">left.inferred_type </span><span class="s0">in </span><span class="s1">(</span><span class="s4">&quot;string&quot;</span><span class="s1">):</span>
                <span class="s0">assert </span><span class="s1">right.inferred_type </span><span class="s0">in </span><span class="s1">(</span><span class="s4">&quot;string&quot;</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assert_attr_equal(</span><span class="s4">&quot;inferred_type&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>

    <span class="s0">def </span><span class="s1">_get_ilevel_values(index</span><span class="s0">, </span><span class="s1">level):</span>
        <span class="s2"># accept level number only</span>
        <span class="s1">unique = index.levels[level]</span>
        <span class="s1">level_codes = index.codes[level]</span>
        <span class="s1">filled = take_1d(unique._values</span><span class="s0">, </span><span class="s1">level_codes</span><span class="s0">, </span><span class="s1">fill_value=unique._na_value)</span>
        <span class="s0">return </span><span class="s1">unique._shallow_copy(filled</span><span class="s0">, </span><span class="s1">name=index.names[level])</span>

    <span class="s0">if </span><span class="s1">check_less_precise </span><span class="s0">is not </span><span class="s1">no_default:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s4">&quot;The 'check_less_precise' keyword in testing.assert_*_equal &quot;</span>
            <span class="s4">&quot;is deprecated and will be removed in a future version. &quot;</span>
            <span class="s4">&quot;You can stop passing 'check_less_precise' to silence this warning.&quot;</span><span class="s0">,</span>
            <span class="s1">FutureWarning</span><span class="s0">,</span>
            <span class="s1">stacklevel=</span><span class="s3">2</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">rtol = atol = _get_tol_from_less_precise(check_less_precise)</span>

    <span class="s2"># instance validation</span>
    <span class="s1">_check_isinstance(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">Index)</span>

    <span class="s2"># class / dtype comparison</span>
    <span class="s1">_check_types(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>

    <span class="s2"># level comparison</span>
    <span class="s0">if </span><span class="s1">left.nlevels != right.nlevels:</span>
        <span class="s1">msg1 = </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">} </span><span class="s4">levels are different&quot;</span>
        <span class="s1">msg2 = </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">left.nlevels</span><span class="s0">}</span><span class="s4">, </span><span class="s0">{</span><span class="s1">left</span><span class="s0">}</span><span class="s4">&quot;</span>
        <span class="s1">msg3 = </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">right.nlevels</span><span class="s0">}</span><span class="s4">, </span><span class="s0">{</span><span class="s1">right</span><span class="s0">}</span><span class="s4">&quot;</span>
        <span class="s1">raise_assert_detail(obj</span><span class="s0">, </span><span class="s1">msg1</span><span class="s0">, </span><span class="s1">msg2</span><span class="s0">, </span><span class="s1">msg3)</span>

    <span class="s2"># length comparison</span>
    <span class="s0">if </span><span class="s1">len(left) != len(right):</span>
        <span class="s1">msg1 = </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">} </span><span class="s4">length are different&quot;</span>
        <span class="s1">msg2 = </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">len(left)</span><span class="s0">}</span><span class="s4">, </span><span class="s0">{</span><span class="s1">left</span><span class="s0">}</span><span class="s4">&quot;</span>
        <span class="s1">msg3 = </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">len(right)</span><span class="s0">}</span><span class="s4">, </span><span class="s0">{</span><span class="s1">right</span><span class="s0">}</span><span class="s4">&quot;</span>
        <span class="s1">raise_assert_detail(obj</span><span class="s0">, </span><span class="s1">msg1</span><span class="s0">, </span><span class="s1">msg2</span><span class="s0">, </span><span class="s1">msg3)</span>

    <span class="s2"># If order doesn't matter then sort the index entries</span>
    <span class="s0">if not </span><span class="s1">check_order:</span>
        <span class="s1">left = Index(safe_sort(left))</span>
        <span class="s1">right = Index(safe_sort(right))</span>

    <span class="s2"># MultiIndex special comparison for little-friendly error messages</span>
    <span class="s0">if </span><span class="s1">left.nlevels &gt; </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">left = cast(MultiIndex</span><span class="s0">, </span><span class="s1">left)</span>
        <span class="s1">right = cast(MultiIndex</span><span class="s0">, </span><span class="s1">right)</span>

        <span class="s0">for </span><span class="s1">level </span><span class="s0">in </span><span class="s1">range(left.nlevels):</span>
            <span class="s2"># cannot use get_level_values here because it can change dtype</span>
            <span class="s1">llevel = _get_ilevel_values(left</span><span class="s0">, </span><span class="s1">level)</span>
            <span class="s1">rlevel = _get_ilevel_values(right</span><span class="s0">, </span><span class="s1">level)</span>

            <span class="s1">lobj = </span><span class="s4">f&quot;MultiIndex level [</span><span class="s0">{</span><span class="s1">level</span><span class="s0">}</span><span class="s4">]&quot;</span>
            <span class="s1">assert_index_equal(</span>
                <span class="s1">llevel</span><span class="s0">,</span>
                <span class="s1">rlevel</span><span class="s0">,</span>
                <span class="s1">exact=exact</span><span class="s0">,</span>
                <span class="s1">check_names=check_names</span><span class="s0">,</span>
                <span class="s1">check_exact=check_exact</span><span class="s0">,</span>
                <span class="s1">rtol=rtol</span><span class="s0">,</span>
                <span class="s1">atol=atol</span><span class="s0">,</span>
                <span class="s1">obj=lobj</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s2"># get_level_values may change dtype</span>
            <span class="s1">_check_types(left.levels[level]</span><span class="s0">, </span><span class="s1">right.levels[level]</span><span class="s0">, </span><span class="s1">obj=obj)</span>

    <span class="s2"># skip exact index checking when `check_categorical` is False</span>
    <span class="s0">if </span><span class="s1">check_exact </span><span class="s0">and </span><span class="s1">check_categorical:</span>
        <span class="s0">if not </span><span class="s1">left.equals(right):</span>
            <span class="s1">diff = np.sum((left.values != right.values).astype(int)) * </span><span class="s3">100.0 </span><span class="s1">/ len(left)</span>
            <span class="s1">msg = </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">} </span><span class="s4">values are different (</span><span class="s0">{</span><span class="s1">np.round(diff</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">} </span><span class="s4">%)&quot;</span>
            <span class="s1">raise_assert_detail(obj</span><span class="s0">, </span><span class="s1">msg</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">_testing.assert_almost_equal(</span>
            <span class="s1">left.values</span><span class="s0">,</span>
            <span class="s1">right.values</span><span class="s0">,</span>
            <span class="s1">rtol=rtol</span><span class="s0">,</span>
            <span class="s1">atol=atol</span><span class="s0">,</span>
            <span class="s1">check_dtype=exact</span><span class="s0">,</span>
            <span class="s1">obj=obj</span><span class="s0">,</span>
            <span class="s1">lobj=left</span><span class="s0">,</span>
            <span class="s1">robj=right</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s2"># metadata comparison</span>
    <span class="s0">if </span><span class="s1">check_names:</span>
        <span class="s1">assert_attr_equal(</span><span class="s4">&quot;names&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>
    <span class="s0">if </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">pd.PeriodIndex) </span><span class="s0">or </span><span class="s1">isinstance(right</span><span class="s0">, </span><span class="s1">pd.PeriodIndex):</span>
        <span class="s1">assert_attr_equal(</span><span class="s4">&quot;freq&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>
    <span class="s0">if </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">pd.IntervalIndex) </span><span class="s0">or </span><span class="s1">isinstance(right</span><span class="s0">, </span><span class="s1">pd.IntervalIndex):</span>
        <span class="s1">assert_interval_array_equal(left._values</span><span class="s0">, </span><span class="s1">right._values)</span>

    <span class="s0">if </span><span class="s1">check_categorical:</span>
        <span class="s0">if </span><span class="s1">is_categorical_dtype(left.dtype) </span><span class="s0">or </span><span class="s1">is_categorical_dtype(right.dtype):</span>
            <span class="s1">assert_categorical_equal(left._values</span><span class="s0">, </span><span class="s1">right._values</span><span class="s0">, </span><span class="s1">obj=</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">} </span><span class="s4">category&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">assert_class_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">exact: Union[bool</span><span class="s0">, </span><span class="s1">str] = </span><span class="s0">True, </span><span class="s1">obj=</span><span class="s4">&quot;Input&quot;</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Checks classes are equal. 
    &quot;&quot;&quot;</span>
    <span class="s1">__tracebackhide__ = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">repr_class(x):</span>
        <span class="s0">if </span><span class="s1">isinstance(x</span><span class="s0">, </span><span class="s1">Index):</span>
            <span class="s2"># return Index as it is to include values in the error message</span>
            <span class="s0">return </span><span class="s1">x</span>

        <span class="s0">return </span><span class="s1">type(x).__name__</span>

    <span class="s0">if </span><span class="s1">exact == </span><span class="s4">&quot;equiv&quot;</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">type(left) != type(right):</span>
            <span class="s2"># allow equivalence of Int64Index/RangeIndex</span>
            <span class="s1">types = {type(left).__name__</span><span class="s0">, </span><span class="s1">type(right).__name__}</span>
            <span class="s0">if </span><span class="s1">len(types - {</span><span class="s4">&quot;Int64Index&quot;</span><span class="s0">, </span><span class="s4">&quot;RangeIndex&quot;</span><span class="s1">}):</span>
                <span class="s1">msg = </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">} </span><span class="s4">classes are not equivalent&quot;</span>
                <span class="s1">raise_assert_detail(obj</span><span class="s0">, </span><span class="s1">msg</span><span class="s0">, </span><span class="s1">repr_class(left)</span><span class="s0">, </span><span class="s1">repr_class(right))</span>
    <span class="s0">elif </span><span class="s1">exact:</span>
        <span class="s0">if </span><span class="s1">type(left) != type(right):</span>
            <span class="s1">msg = </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">} </span><span class="s4">classes are different&quot;</span>
            <span class="s1">raise_assert_detail(obj</span><span class="s0">, </span><span class="s1">msg</span><span class="s0">, </span><span class="s1">repr_class(left)</span><span class="s0">, </span><span class="s1">repr_class(right))</span>


<span class="s0">def </span><span class="s1">assert_attr_equal(attr: str</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj: str = </span><span class="s4">&quot;Attributes&quot;</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Check attributes are equal. Both objects must have attribute. 
 
    Parameters 
    ---------- 
    attr : str 
        Attribute name being compared. 
    left : object 
    right : object 
    obj : str, default 'Attributes' 
        Specify object name being compared, internally used to show appropriate 
        assertion message 
    &quot;&quot;&quot;</span>
    <span class="s1">__tracebackhide__ = </span><span class="s0">True</span>

    <span class="s1">left_attr = getattr(left</span><span class="s0">, </span><span class="s1">attr)</span>
    <span class="s1">right_attr = getattr(right</span><span class="s0">, </span><span class="s1">attr)</span>

    <span class="s0">if </span><span class="s1">left_attr </span><span class="s0">is </span><span class="s1">right_attr:</span>
        <span class="s0">return True</span>
    <span class="s0">elif </span><span class="s1">(</span>
        <span class="s1">is_number(left_attr)</span>
        <span class="s0">and </span><span class="s1">np.isnan(left_attr)</span>
        <span class="s0">and </span><span class="s1">is_number(right_attr)</span>
        <span class="s0">and </span><span class="s1">np.isnan(right_attr)</span>
    <span class="s1">):</span>
        <span class="s2"># np.nan</span>
        <span class="s0">return True</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">result = left_attr == right_attr</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s2"># datetimetz on rhs may raise TypeError</span>
        <span class="s1">result = </span><span class="s0">False</span>
    <span class="s0">if not </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">bool):</span>
        <span class="s1">result = result.all()</span>

    <span class="s0">if </span><span class="s1">result:</span>
        <span class="s0">return True</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">msg = </span><span class="s4">f'Attribute &quot;</span><span class="s0">{</span><span class="s1">attr</span><span class="s0">}</span><span class="s4">&quot; are different'</span>
        <span class="s1">raise_assert_detail(obj</span><span class="s0">, </span><span class="s1">msg</span><span class="s0">, </span><span class="s1">left_attr</span><span class="s0">, </span><span class="s1">right_attr)</span>


<span class="s0">def </span><span class="s1">assert_is_valid_plot_return_object(objs):</span>
    <span class="s0">import </span><span class="s1">matplotlib.pyplot </span><span class="s0">as </span><span class="s1">plt</span>

    <span class="s0">if </span><span class="s1">isinstance(objs</span><span class="s0">, </span><span class="s1">(pd.Series</span><span class="s0">, </span><span class="s1">np.ndarray)):</span>
        <span class="s0">for </span><span class="s1">el </span><span class="s0">in </span><span class="s1">objs.ravel():</span>
            <span class="s1">msg = (</span>
                <span class="s4">&quot;one of 'objs' is not a matplotlib Axes instance, &quot;</span>
                <span class="s4">f&quot;type encountered </span><span class="s0">{</span><span class="s1">repr(type(el).__name__)</span><span class="s0">}</span><span class="s4">&quot;</span>
            <span class="s1">)</span>
            <span class="s0">assert </span><span class="s1">isinstance(el</span><span class="s0">, </span><span class="s1">(plt.Axes</span><span class="s0">, </span><span class="s1">dict))</span><span class="s0">, </span><span class="s1">msg</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">msg = (</span>
            <span class="s4">&quot;objs is neither an ndarray of Artist instances nor a single &quot;</span>
            <span class="s4">&quot;ArtistArtist instance, tuple, or dict, 'objs' is a &quot;</span>
            <span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">repr(type(objs).__name__)</span><span class="s0">}</span><span class="s4">&quot;</span>
        <span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">isinstance(objs</span><span class="s0">, </span><span class="s1">(plt.Artist</span><span class="s0">, </span><span class="s1">tuple</span><span class="s0">, </span><span class="s1">dict))</span><span class="s0">, </span><span class="s1">msg</span>


<span class="s0">def </span><span class="s1">assert_is_sorted(seq):</span>
    <span class="s5">&quot;&quot;&quot;Assert that the sequence is sorted.&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance(seq</span><span class="s0">, </span><span class="s1">(Index</span><span class="s0">, </span><span class="s1">Series)):</span>
        <span class="s1">seq = seq.values</span>
    <span class="s2"># sorting does not change precisions</span>
    <span class="s1">assert_numpy_array_equal(seq</span><span class="s0">, </span><span class="s1">np.sort(np.array(seq)))</span>


<span class="s0">def </span><span class="s1">assert_categorical_equal(</span>
    <span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">check_dtype=</span><span class="s0">True, </span><span class="s1">check_category_order=</span><span class="s0">True, </span><span class="s1">obj=</span><span class="s4">&quot;Categorical&quot;</span>
<span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Test that Categoricals are equivalent. 
 
    Parameters 
    ---------- 
    left : Categorical 
    right : Categorical 
    check_dtype : bool, default True 
        Check that integer dtype of the codes are the same 
    check_category_order : bool, default True 
        Whether the order of the categories should be compared, which 
        implies identical integer codes.  If False, only the resulting 
        values are compared.  The ordered attribute is 
        checked regardless. 
    obj : str, default 'Categorical' 
        Specify object name being compared, internally used to show appropriate 
        assertion message 
    &quot;&quot;&quot;</span>
    <span class="s1">_check_isinstance(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">Categorical)</span>

    <span class="s0">if </span><span class="s1">check_category_order:</span>
        <span class="s1">assert_index_equal(left.categories</span><span class="s0">, </span><span class="s1">right.categories</span><span class="s0">, </span><span class="s1">obj=</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s4">.categories&quot;</span><span class="s1">)</span>
        <span class="s1">assert_numpy_array_equal(</span>
            <span class="s1">left.codes</span><span class="s0">, </span><span class="s1">right.codes</span><span class="s0">, </span><span class="s1">check_dtype=check_dtype</span><span class="s0">, </span><span class="s1">obj=</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s4">.codes&quot;</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">lc = left.categories.sort_values()</span>
            <span class="s1">rc = right.categories.sort_values()</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s2"># e.g. '&lt;' not supported between instances of 'int' and 'str'</span>
            <span class="s1">lc</span><span class="s0">, </span><span class="s1">rc = left.categories</span><span class="s0">, </span><span class="s1">right.categories</span>
        <span class="s1">assert_index_equal(lc</span><span class="s0">, </span><span class="s1">rc</span><span class="s0">, </span><span class="s1">obj=</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s4">.categories&quot;</span><span class="s1">)</span>
        <span class="s1">assert_index_equal(</span>
            <span class="s1">left.categories.take(left.codes)</span><span class="s0">,</span>
            <span class="s1">right.categories.take(right.codes)</span><span class="s0">,</span>
            <span class="s1">obj=</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s4">.values&quot;</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s1">assert_attr_equal(</span><span class="s4">&quot;ordered&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>


<span class="s0">def </span><span class="s1">assert_interval_array_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">exact=</span><span class="s4">&quot;equiv&quot;</span><span class="s0">, </span><span class="s1">obj=</span><span class="s4">&quot;IntervalArray&quot;</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Test that two IntervalArrays are equivalent. 
 
    Parameters 
    ---------- 
    left, right : IntervalArray 
        The IntervalArrays to compare. 
    exact : bool or {'equiv'}, default 'equiv' 
        Whether to check the Index class, dtype and inferred_type 
        are identical. If 'equiv', then RangeIndex can be substituted for 
        Int64Index as well. 
    obj : str, default 'IntervalArray' 
        Specify object name being compared, internally used to show appropriate 
        assertion message 
    &quot;&quot;&quot;</span>
    <span class="s1">_check_isinstance(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">IntervalArray)</span>

    <span class="s1">kwargs = {}</span>
    <span class="s0">if </span><span class="s1">left._left.dtype.kind </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;m&quot;</span><span class="s0">, </span><span class="s4">&quot;M&quot;</span><span class="s1">]:</span>
        <span class="s2"># We have a DatetimeArray or TimedeltaArray</span>
        <span class="s1">kwargs[</span><span class="s4">&quot;check_freq&quot;</span><span class="s1">] = </span><span class="s0">False</span>

    <span class="s1">assert_equal(left._left</span><span class="s0">, </span><span class="s1">right._left</span><span class="s0">, </span><span class="s1">obj=</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s4">.left&quot;</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s1">assert_equal(left._right</span><span class="s0">, </span><span class="s1">right._right</span><span class="s0">, </span><span class="s1">obj=</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s4">.left&quot;</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s1">assert_attr_equal(</span><span class="s4">&quot;closed&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>


<span class="s0">def </span><span class="s1">assert_period_array_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=</span><span class="s4">&quot;PeriodArray&quot;</span><span class="s1">):</span>
    <span class="s1">_check_isinstance(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">PeriodArray)</span>

    <span class="s1">assert_numpy_array_equal(left._data</span><span class="s0">, </span><span class="s1">right._data</span><span class="s0">, </span><span class="s1">obj=</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s4">._data&quot;</span><span class="s1">)</span>
    <span class="s1">assert_attr_equal(</span><span class="s4">&quot;freq&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>


<span class="s0">def </span><span class="s1">assert_datetime_array_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=</span><span class="s4">&quot;DatetimeArray&quot;</span><span class="s0">, </span><span class="s1">check_freq=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s1">__tracebackhide__ = </span><span class="s0">True</span>
    <span class="s1">_check_isinstance(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">DatetimeArray)</span>

    <span class="s1">assert_numpy_array_equal(left._data</span><span class="s0">, </span><span class="s1">right._data</span><span class="s0">, </span><span class="s1">obj=</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s4">._data&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">check_freq:</span>
        <span class="s1">assert_attr_equal(</span><span class="s4">&quot;freq&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>
    <span class="s1">assert_attr_equal(</span><span class="s4">&quot;tz&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>


<span class="s0">def </span><span class="s1">assert_timedelta_array_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=</span><span class="s4">&quot;TimedeltaArray&quot;</span><span class="s0">, </span><span class="s1">check_freq=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s1">__tracebackhide__ = </span><span class="s0">True</span>
    <span class="s1">_check_isinstance(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">TimedeltaArray)</span>
    <span class="s1">assert_numpy_array_equal(left._data</span><span class="s0">, </span><span class="s1">right._data</span><span class="s0">, </span><span class="s1">obj=</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s4">._data&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">check_freq:</span>
        <span class="s1">assert_attr_equal(</span><span class="s4">&quot;freq&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>


<span class="s0">def </span><span class="s1">raise_assert_detail(obj</span><span class="s0">, </span><span class="s1">message</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">diff=</span><span class="s0">None, </span><span class="s1">index_values=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s1">__tracebackhide__ = </span><span class="s0">True</span>

    <span class="s1">msg = </span><span class="s4">f&quot;&quot;&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">} </span><span class="s4">are different</span>

<span class="s0">{</span><span class="s1">message</span><span class="s0">}</span><span class="s4">&quot;&quot;&quot;</span>

    <span class="s0">if </span><span class="s1">isinstance(index_values</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
        <span class="s1">msg += </span><span class="s4">f&quot;</span><span class="s0">\n</span><span class="s4">[index]: </span><span class="s0">{</span><span class="s1">pprint_thing(index_values)</span><span class="s0">}</span><span class="s4">&quot;</span>

    <span class="s0">if </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
        <span class="s1">left = pprint_thing(left)</span>
    <span class="s0">elif </span><span class="s1">is_categorical_dtype(left):</span>
        <span class="s1">left = repr(left)</span>

    <span class="s0">if </span><span class="s1">isinstance(right</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
        <span class="s1">right = pprint_thing(right)</span>
    <span class="s0">elif </span><span class="s1">is_categorical_dtype(right):</span>
        <span class="s1">right = repr(right)</span>

    <span class="s1">msg += </span><span class="s4">f&quot;&quot;&quot;</span>
<span class="s4">[left]:  </span><span class="s0">{</span><span class="s1">left</span><span class="s0">}</span>
<span class="s4">[right]: </span><span class="s0">{</span><span class="s1">right</span><span class="s0">}</span><span class="s4">&quot;&quot;&quot;</span>

    <span class="s0">if </span><span class="s1">diff </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">msg += </span><span class="s4">f&quot;</span><span class="s0">\n</span><span class="s4">[diff]: </span><span class="s0">{</span><span class="s1">diff</span><span class="s0">}</span><span class="s4">&quot;</span>

    <span class="s0">raise </span><span class="s1">AssertionError(msg)</span>


<span class="s0">def </span><span class="s1">assert_numpy_array_equal(</span>
    <span class="s1">left</span><span class="s0">,</span>
    <span class="s1">right</span><span class="s0">,</span>
    <span class="s1">strict_nan=</span><span class="s0">False,</span>
    <span class="s1">check_dtype=</span><span class="s0">True,</span>
    <span class="s1">err_msg=</span><span class="s0">None,</span>
    <span class="s1">check_same=</span><span class="s0">None,</span>
    <span class="s1">obj=</span><span class="s4">&quot;numpy array&quot;</span><span class="s0">,</span>
    <span class="s1">index_values=</span><span class="s0">None,</span>
<span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Check that 'np.ndarray' is equivalent. 
 
    Parameters 
    ---------- 
    left, right : numpy.ndarray or iterable 
        The two arrays to be compared. 
    strict_nan : bool, default False 
        If True, consider NaN and None to be different. 
    check_dtype : bool, default True 
        Check dtype if both a and b are np.ndarray. 
    err_msg : str, default None 
        If provided, used as assertion message. 
    check_same : None|'copy'|'same', default None 
        Ensure left and right refer/do not refer to the same memory area. 
    obj : str, default 'numpy array' 
        Specify object name being compared, internally used to show appropriate 
        assertion message. 
    index_values : numpy.ndarray, default None 
        optional index (shared by both left and right), used in output. 
    &quot;&quot;&quot;</span>
    <span class="s1">__tracebackhide__ = </span><span class="s0">True</span>

    <span class="s2"># instance validation</span>
    <span class="s2"># Show a detailed error message when classes are different</span>
    <span class="s1">assert_class_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>
    <span class="s2"># both classes must be an np.ndarray</span>
    <span class="s1">_check_isinstance(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">np.ndarray)</span>

    <span class="s0">def </span><span class="s1">_get_base(obj):</span>
        <span class="s0">return </span><span class="s1">obj.base </span><span class="s0">if </span><span class="s1">getattr(obj</span><span class="s0">, </span><span class="s4">&quot;base&quot;</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is not None else </span><span class="s1">obj</span>

    <span class="s1">left_base = _get_base(left)</span>
    <span class="s1">right_base = _get_base(right)</span>

    <span class="s0">if </span><span class="s1">check_same == </span><span class="s4">&quot;same&quot;</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">left_base </span><span class="s0">is not </span><span class="s1">right_base:</span>
            <span class="s0">raise </span><span class="s1">AssertionError(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">repr(left_base)</span><span class="s0">} </span><span class="s4">is not </span><span class="s0">{</span><span class="s1">repr(right_base)</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">check_same == </span><span class="s4">&quot;copy&quot;</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">left_base </span><span class="s0">is </span><span class="s1">right_base:</span>
            <span class="s0">raise </span><span class="s1">AssertionError(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">repr(left_base)</span><span class="s0">} </span><span class="s4">is </span><span class="s0">{</span><span class="s1">repr(right_base)</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_raise(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">err_msg):</span>
        <span class="s0">if </span><span class="s1">err_msg </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">left.shape != right.shape:</span>
                <span class="s1">raise_assert_detail(</span>
                    <span class="s1">obj</span><span class="s0">, </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">} </span><span class="s4">shapes are different&quot;</span><span class="s0">, </span><span class="s1">left.shape</span><span class="s0">, </span><span class="s1">right.shape</span>
                <span class="s1">)</span>

            <span class="s1">diff = </span><span class="s3">0</span>
            <span class="s0">for </span><span class="s1">left_arr</span><span class="s0">, </span><span class="s1">right_arr </span><span class="s0">in </span><span class="s1">zip(left</span><span class="s0">, </span><span class="s1">right):</span>
                <span class="s2"># count up differences</span>
                <span class="s0">if not </span><span class="s1">array_equivalent(left_arr</span><span class="s0">, </span><span class="s1">right_arr</span><span class="s0">, </span><span class="s1">strict_nan=strict_nan):</span>
                    <span class="s1">diff += </span><span class="s3">1</span>

            <span class="s1">diff = diff * </span><span class="s3">100.0 </span><span class="s1">/ left.size</span>
            <span class="s1">msg = </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">} </span><span class="s4">values are different (</span><span class="s0">{</span><span class="s1">np.round(diff</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">} </span><span class="s4">%)&quot;</span>
            <span class="s1">raise_assert_detail(obj</span><span class="s0">, </span><span class="s1">msg</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">index_values=index_values)</span>

        <span class="s0">raise </span><span class="s1">AssertionError(err_msg)</span>

    <span class="s2"># compare shape and values</span>
    <span class="s0">if not </span><span class="s1">array_equivalent(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">strict_nan=strict_nan):</span>
        <span class="s1">_raise(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">err_msg)</span>

    <span class="s0">if </span><span class="s1">check_dtype:</span>
        <span class="s0">if </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">and </span><span class="s1">isinstance(right</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
            <span class="s1">assert_attr_equal(</span><span class="s4">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>


<span class="s0">def </span><span class="s1">assert_extension_array_equal(</span>
    <span class="s1">left</span><span class="s0">,</span>
    <span class="s1">right</span><span class="s0">,</span>
    <span class="s1">check_dtype=</span><span class="s0">True,</span>
    <span class="s1">index_values=</span><span class="s0">None,</span>
    <span class="s1">check_less_precise=no_default</span><span class="s0">,</span>
    <span class="s1">check_exact=</span><span class="s0">False,</span>
    <span class="s1">rtol: float = </span><span class="s3">1.0e-5</span><span class="s0">,</span>
    <span class="s1">atol: float = </span><span class="s3">1.0e-8</span><span class="s0">,</span>
<span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Check that left and right ExtensionArrays are equal. 
 
    Parameters 
    ---------- 
    left, right : ExtensionArray 
        The two arrays to compare. 
    check_dtype : bool, default True 
        Whether to check if the ExtensionArray dtypes are identical. 
    index_values : numpy.ndarray, default None 
        Optional index (shared by both left and right), used in output. 
    check_less_precise : bool or int, default False 
        Specify comparison precision. Only used when check_exact is False. 
        5 digits (False) or 3 digits (True) after decimal points are compared. 
        If int, then specify the digits to compare. 
 
        .. deprecated:: 1.1.0 
           Use `rtol` and `atol` instead to define relative/absolute 
           tolerance, respectively. Similar to :func:`math.isclose`. 
    check_exact : bool, default False 
        Whether to compare number exactly. 
    rtol : float, default 1e-5 
        Relative tolerance. Only used when check_exact is False. 
 
        .. versionadded:: 1.1.0 
    atol : float, default 1e-8 
        Absolute tolerance. Only used when check_exact is False. 
 
        .. versionadded:: 1.1.0 
 
    Notes 
    ----- 
    Missing values are checked separately from valid values. 
    A mask of missing values is computed for each and checked to match. 
    The remaining all-valid values are cast to object dtype and checked. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from pandas.testing import assert_extension_array_equal 
    &gt;&gt;&gt; a = pd.Series([1, 2, 3, 4]) 
    &gt;&gt;&gt; b, c = a.array, a.array 
    &gt;&gt;&gt; assert_extension_array_equal(b, c) 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">check_less_precise </span><span class="s0">is not </span><span class="s1">no_default:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s4">&quot;The 'check_less_precise' keyword in testing.assert_*_equal &quot;</span>
            <span class="s4">&quot;is deprecated and will be removed in a future version. &quot;</span>
            <span class="s4">&quot;You can stop passing 'check_less_precise' to silence this warning.&quot;</span><span class="s0">,</span>
            <span class="s1">FutureWarning</span><span class="s0">,</span>
            <span class="s1">stacklevel=</span><span class="s3">2</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">rtol = atol = _get_tol_from_less_precise(check_less_precise)</span>

    <span class="s0">assert </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">ExtensionArray)</span><span class="s0">, </span><span class="s4">&quot;left is not an ExtensionArray&quot;</span>
    <span class="s0">assert </span><span class="s1">isinstance(right</span><span class="s0">, </span><span class="s1">ExtensionArray)</span><span class="s0">, </span><span class="s4">&quot;right is not an ExtensionArray&quot;</span>
    <span class="s0">if </span><span class="s1">check_dtype:</span>
        <span class="s1">assert_attr_equal(</span><span class="s4">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=</span><span class="s4">&quot;ExtensionArray&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">(</span>
        <span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">DatetimeLikeArrayMixin)</span>
        <span class="s0">and </span><span class="s1">isinstance(right</span><span class="s0">, </span><span class="s1">DatetimeLikeArrayMixin)</span>
        <span class="s0">and </span><span class="s1">type(right) == type(left)</span>
    <span class="s1">):</span>
        <span class="s2"># Avoid slow object-dtype comparisons</span>
        <span class="s2"># np.asarray for case where we have a np.MaskedArray</span>
        <span class="s1">assert_numpy_array_equal(</span>
            <span class="s1">np.asarray(left.asi8)</span><span class="s0">, </span><span class="s1">np.asarray(right.asi8)</span><span class="s0">, </span><span class="s1">index_values=index_values</span>
        <span class="s1">)</span>
        <span class="s0">return</span>

    <span class="s1">left_na = np.asarray(left.isna())</span>
    <span class="s1">right_na = np.asarray(right.isna())</span>
    <span class="s1">assert_numpy_array_equal(</span>
        <span class="s1">left_na</span><span class="s0">, </span><span class="s1">right_na</span><span class="s0">, </span><span class="s1">obj=</span><span class="s4">&quot;ExtensionArray NA mask&quot;</span><span class="s0">, </span><span class="s1">index_values=index_values</span>
    <span class="s1">)</span>

    <span class="s1">left_valid = np.asarray(left[~left_na].astype(object))</span>
    <span class="s1">right_valid = np.asarray(right[~right_na].astype(object))</span>
    <span class="s0">if </span><span class="s1">check_exact:</span>
        <span class="s1">assert_numpy_array_equal(</span>
            <span class="s1">left_valid</span><span class="s0">, </span><span class="s1">right_valid</span><span class="s0">, </span><span class="s1">obj=</span><span class="s4">&quot;ExtensionArray&quot;</span><span class="s0">, </span><span class="s1">index_values=index_values</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">_testing.assert_almost_equal(</span>
            <span class="s1">left_valid</span><span class="s0">,</span>
            <span class="s1">right_valid</span><span class="s0">,</span>
            <span class="s1">check_dtype=check_dtype</span><span class="s0">,</span>
            <span class="s1">rtol=rtol</span><span class="s0">,</span>
            <span class="s1">atol=atol</span><span class="s0">,</span>
            <span class="s1">obj=</span><span class="s4">&quot;ExtensionArray&quot;</span><span class="s0">,</span>
            <span class="s1">index_values=index_values</span><span class="s0">,</span>
        <span class="s1">)</span>


<span class="s2"># This could be refactored to use the NDFrame.equals method</span>
<span class="s0">def </span><span class="s1">assert_series_equal(</span>
    <span class="s1">left</span><span class="s0">,</span>
    <span class="s1">right</span><span class="s0">,</span>
    <span class="s1">check_dtype=</span><span class="s0">True,</span>
    <span class="s1">check_index_type=</span><span class="s4">&quot;equiv&quot;</span><span class="s0">,</span>
    <span class="s1">check_series_type=</span><span class="s0">True,</span>
    <span class="s1">check_less_precise=no_default</span><span class="s0">,</span>
    <span class="s1">check_names=</span><span class="s0">True,</span>
    <span class="s1">check_exact=</span><span class="s0">False,</span>
    <span class="s1">check_datetimelike_compat=</span><span class="s0">False,</span>
    <span class="s1">check_categorical=</span><span class="s0">True,</span>
    <span class="s1">check_category_order=</span><span class="s0">True,</span>
    <span class="s1">check_freq=</span><span class="s0">True,</span>
    <span class="s1">check_flags=</span><span class="s0">True,</span>
    <span class="s1">rtol=</span><span class="s3">1.0e-5</span><span class="s0">,</span>
    <span class="s1">atol=</span><span class="s3">1.0e-8</span><span class="s0">,</span>
    <span class="s1">obj=</span><span class="s4">&quot;Series&quot;</span><span class="s0">,</span>
<span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Check that left and right Series are equal. 
 
    Parameters 
    ---------- 
    left : Series 
    right : Series 
    check_dtype : bool, default True 
        Whether to check the Series dtype is identical. 
    check_index_type : bool or {'equiv'}, default 'equiv' 
        Whether to check the Index class, dtype and inferred_type 
        are identical. 
    check_series_type : bool, default True 
         Whether to check the Series class is identical. 
    check_less_precise : bool or int, default False 
        Specify comparison precision. Only used when check_exact is False. 
        5 digits (False) or 3 digits (True) after decimal points are compared. 
        If int, then specify the digits to compare. 
 
        When comparing two numbers, if the first number has magnitude less 
        than 1e-5, we compare the two numbers directly and check whether 
        they are equivalent within the specified precision. Otherwise, we 
        compare the **ratio** of the second number to the first number and 
        check whether it is equivalent to 1 within the specified precision. 
 
        .. deprecated:: 1.1.0 
           Use `rtol` and `atol` instead to define relative/absolute 
           tolerance, respectively. Similar to :func:`math.isclose`. 
    check_names : bool, default True 
        Whether to check the Series and Index names attribute. 
    check_exact : bool, default False 
        Whether to compare number exactly. 
    check_datetimelike_compat : bool, default False 
        Compare datetime-like which is comparable ignoring dtype. 
    check_categorical : bool, default True 
        Whether to compare internal Categorical exactly. 
    check_category_order : bool, default True 
        Whether to compare category order of internal Categoricals. 
 
        .. versionadded:: 1.0.2 
    check_freq : bool, default True 
        Whether to check the `freq` attribute on a DatetimeIndex or TimedeltaIndex. 
 
        .. versionadded:: 1.1.0 
    check_flags : bool, default True 
        Whether to check the `flags` attribute. 
 
        .. versionadded:: 1.2.0 
 
    rtol : float, default 1e-5 
        Relative tolerance. Only used when check_exact is False. 
 
        .. versionadded:: 1.1.0 
    atol : float, default 1e-8 
        Absolute tolerance. Only used when check_exact is False. 
 
        .. versionadded:: 1.1.0 
    obj : str, default 'Series' 
        Specify object name being compared, internally used to show appropriate 
        assertion message. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from pandas.testing import assert_series_equal 
    &gt;&gt;&gt; a = pd.Series([1, 2, 3, 4]) 
    &gt;&gt;&gt; b = pd.Series([1, 2, 3, 4]) 
    &gt;&gt;&gt; assert_series_equal(a, b) 
    &quot;&quot;&quot;</span>
    <span class="s1">__tracebackhide__ = </span><span class="s0">True</span>

    <span class="s0">if </span><span class="s1">check_less_precise </span><span class="s0">is not </span><span class="s1">no_default:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s4">&quot;The 'check_less_precise' keyword in testing.assert_*_equal &quot;</span>
            <span class="s4">&quot;is deprecated and will be removed in a future version. &quot;</span>
            <span class="s4">&quot;You can stop passing 'check_less_precise' to silence this warning.&quot;</span><span class="s0">,</span>
            <span class="s1">FutureWarning</span><span class="s0">,</span>
            <span class="s1">stacklevel=</span><span class="s3">2</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">rtol = atol = _get_tol_from_less_precise(check_less_precise)</span>

    <span class="s2"># instance validation</span>
    <span class="s1">_check_isinstance(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">Series)</span>

    <span class="s0">if </span><span class="s1">check_series_type:</span>
        <span class="s1">assert_class_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>

    <span class="s2"># length comparison</span>
    <span class="s0">if </span><span class="s1">len(left) != len(right):</span>
        <span class="s1">msg1 = </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">len(left)</span><span class="s0">}</span><span class="s4">, </span><span class="s0">{</span><span class="s1">left.index</span><span class="s0">}</span><span class="s4">&quot;</span>
        <span class="s1">msg2 = </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">len(right)</span><span class="s0">}</span><span class="s4">, </span><span class="s0">{</span><span class="s1">right.index</span><span class="s0">}</span><span class="s4">&quot;</span>
        <span class="s1">raise_assert_detail(obj</span><span class="s0">, </span><span class="s4">&quot;Series length are different&quot;</span><span class="s0">, </span><span class="s1">msg1</span><span class="s0">, </span><span class="s1">msg2)</span>

    <span class="s0">if </span><span class="s1">check_flags:</span>
        <span class="s0">assert </span><span class="s1">left.flags == right.flags</span><span class="s0">, </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">repr(left.flags)</span><span class="s0">} </span><span class="s4">!= </span><span class="s0">{</span><span class="s1">repr(right.flags)</span><span class="s0">}</span><span class="s4">&quot;</span>

    <span class="s2"># index comparison</span>
    <span class="s1">assert_index_equal(</span>
        <span class="s1">left.index</span><span class="s0">,</span>
        <span class="s1">right.index</span><span class="s0">,</span>
        <span class="s1">exact=check_index_type</span><span class="s0">,</span>
        <span class="s1">check_names=check_names</span><span class="s0">,</span>
        <span class="s1">check_exact=check_exact</span><span class="s0">,</span>
        <span class="s1">check_categorical=check_categorical</span><span class="s0">,</span>
        <span class="s1">rtol=rtol</span><span class="s0">,</span>
        <span class="s1">atol=atol</span><span class="s0">,</span>
        <span class="s1">obj=</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s4">.index&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">if </span><span class="s1">check_freq </span><span class="s0">and </span><span class="s1">isinstance(left.index</span><span class="s0">, </span><span class="s1">(pd.DatetimeIndex</span><span class="s0">, </span><span class="s1">pd.TimedeltaIndex)):</span>
        <span class="s1">lidx = left.index</span>
        <span class="s1">ridx = right.index</span>
        <span class="s0">assert </span><span class="s1">lidx.freq == ridx.freq</span><span class="s0">, </span><span class="s1">(lidx.freq</span><span class="s0">, </span><span class="s1">ridx.freq)</span>

    <span class="s0">if </span><span class="s1">check_dtype:</span>
        <span class="s2"># We want to skip exact dtype checking when `check_categorical`</span>
        <span class="s2"># is False. We'll still raise if only one is a `Categorical`,</span>
        <span class="s2"># regardless of `check_categorical`</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">is_categorical_dtype(left.dtype)</span>
            <span class="s0">and </span><span class="s1">is_categorical_dtype(right.dtype)</span>
            <span class="s0">and not </span><span class="s1">check_categorical</span>
        <span class="s1">):</span>
            <span class="s0">pass</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">assert_attr_equal(</span><span class="s4">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=</span><span class="s4">f&quot;Attributes of </span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">check_exact </span><span class="s0">and </span><span class="s1">is_numeric_dtype(left.dtype) </span><span class="s0">and </span><span class="s1">is_numeric_dtype(right.dtype):</span>
        <span class="s1">left_values = left._values</span>
        <span class="s1">right_values = right._values</span>
        <span class="s2"># Only check exact if dtype is numeric</span>
        <span class="s0">if </span><span class="s1">is_extension_array_dtype(left_values) </span><span class="s0">and </span><span class="s1">is_extension_array_dtype(</span>
            <span class="s1">right_values</span>
        <span class="s1">):</span>
            <span class="s1">assert_extension_array_equal(</span>
                <span class="s1">left_values</span><span class="s0">,</span>
                <span class="s1">right_values</span><span class="s0">,</span>
                <span class="s1">check_dtype=check_dtype</span><span class="s0">,</span>
                <span class="s1">index_values=np.asarray(left.index)</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">assert_numpy_array_equal(</span>
                <span class="s1">left_values</span><span class="s0">,</span>
                <span class="s1">right_values</span><span class="s0">,</span>
                <span class="s1">check_dtype=check_dtype</span><span class="s0">,</span>
                <span class="s1">obj=str(obj)</span><span class="s0">,</span>
                <span class="s1">index_values=np.asarray(left.index)</span><span class="s0">,</span>
            <span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">check_datetimelike_compat </span><span class="s0">and </span><span class="s1">(</span>
        <span class="s1">needs_i8_conversion(left.dtype) </span><span class="s0">or </span><span class="s1">needs_i8_conversion(right.dtype)</span>
    <span class="s1">):</span>
        <span class="s2"># we want to check only if we have compat dtypes</span>
        <span class="s2"># e.g. integer and M|m are NOT compat, but we can simply check</span>
        <span class="s2"># the values in that case</span>

        <span class="s2"># datetimelike may have different objects (e.g. datetime.datetime</span>
        <span class="s2"># vs Timestamp) but will compare equal</span>
        <span class="s0">if not </span><span class="s1">Index(left._values).equals(Index(right._values)):</span>
            <span class="s1">msg = (</span>
                <span class="s4">f&quot;[datetimelike_compat=True] </span><span class="s0">{</span><span class="s1">left._values</span><span class="s0">} </span><span class="s4">&quot;</span>
                <span class="s4">f&quot;is not equal to </span><span class="s0">{</span><span class="s1">right._values</span><span class="s0">}</span><span class="s4">.&quot;</span>
            <span class="s1">)</span>
            <span class="s0">raise </span><span class="s1">AssertionError(msg)</span>
    <span class="s0">elif </span><span class="s1">is_interval_dtype(left.dtype) </span><span class="s0">and </span><span class="s1">is_interval_dtype(right.dtype):</span>
        <span class="s1">assert_interval_array_equal(left.array</span><span class="s0">, </span><span class="s1">right.array)</span>
    <span class="s0">elif </span><span class="s1">is_categorical_dtype(left.dtype) </span><span class="s0">or </span><span class="s1">is_categorical_dtype(right.dtype):</span>
        <span class="s1">_testing.assert_almost_equal(</span>
            <span class="s1">left._values</span><span class="s0">,</span>
            <span class="s1">right._values</span><span class="s0">,</span>
            <span class="s1">rtol=rtol</span><span class="s0">,</span>
            <span class="s1">atol=atol</span><span class="s0">,</span>
            <span class="s1">check_dtype=check_dtype</span><span class="s0">,</span>
            <span class="s1">obj=str(obj)</span><span class="s0">,</span>
            <span class="s1">index_values=np.asarray(left.index)</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">is_extension_array_dtype(left.dtype) </span><span class="s0">and </span><span class="s1">is_extension_array_dtype(right.dtype):</span>
        <span class="s1">assert_extension_array_equal(</span>
            <span class="s1">left._values</span><span class="s0">,</span>
            <span class="s1">right._values</span><span class="s0">,</span>
            <span class="s1">check_dtype=check_dtype</span><span class="s0">,</span>
            <span class="s1">index_values=np.asarray(left.index)</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">is_extension_array_dtype_and_needs_i8_conversion(</span>
        <span class="s1">left.dtype</span><span class="s0">, </span><span class="s1">right.dtype</span>
    <span class="s1">) </span><span class="s0">or </span><span class="s1">is_extension_array_dtype_and_needs_i8_conversion(right.dtype</span><span class="s0">, </span><span class="s1">left.dtype):</span>
        <span class="s1">assert_extension_array_equal(</span>
            <span class="s1">left._values</span><span class="s0">,</span>
            <span class="s1">right._values</span><span class="s0">,</span>
            <span class="s1">check_dtype=check_dtype</span><span class="s0">,</span>
            <span class="s1">index_values=np.asarray(left.index)</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">needs_i8_conversion(left.dtype) </span><span class="s0">and </span><span class="s1">needs_i8_conversion(right.dtype):</span>
        <span class="s2"># DatetimeArray or TimedeltaArray</span>
        <span class="s1">assert_extension_array_equal(</span>
            <span class="s1">left._values</span><span class="s0">,</span>
            <span class="s1">right._values</span><span class="s0">,</span>
            <span class="s1">check_dtype=check_dtype</span><span class="s0">,</span>
            <span class="s1">index_values=np.asarray(left.index)</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">_testing.assert_almost_equal(</span>
            <span class="s1">left._values</span><span class="s0">,</span>
            <span class="s1">right._values</span><span class="s0">,</span>
            <span class="s1">rtol=rtol</span><span class="s0">,</span>
            <span class="s1">atol=atol</span><span class="s0">,</span>
            <span class="s1">check_dtype=check_dtype</span><span class="s0">,</span>
            <span class="s1">obj=str(obj)</span><span class="s0">,</span>
            <span class="s1">index_values=np.asarray(left.index)</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s2"># metadata comparison</span>
    <span class="s0">if </span><span class="s1">check_names:</span>
        <span class="s1">assert_attr_equal(</span><span class="s4">&quot;name&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>

    <span class="s0">if </span><span class="s1">check_categorical:</span>
        <span class="s0">if </span><span class="s1">is_categorical_dtype(left.dtype) </span><span class="s0">or </span><span class="s1">is_categorical_dtype(right.dtype):</span>
            <span class="s1">assert_categorical_equal(</span>
                <span class="s1">left._values</span><span class="s0">,</span>
                <span class="s1">right._values</span><span class="s0">,</span>
                <span class="s1">obj=</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">} </span><span class="s4">category&quot;</span><span class="s0">,</span>
                <span class="s1">check_category_order=check_category_order</span><span class="s0">,</span>
            <span class="s1">)</span>


<span class="s2"># This could be refactored to use the NDFrame.equals method</span>
<span class="s0">def </span><span class="s1">assert_frame_equal(</span>
    <span class="s1">left</span><span class="s0">,</span>
    <span class="s1">right</span><span class="s0">,</span>
    <span class="s1">check_dtype=</span><span class="s0">True,</span>
    <span class="s1">check_index_type=</span><span class="s4">&quot;equiv&quot;</span><span class="s0">,</span>
    <span class="s1">check_column_type=</span><span class="s4">&quot;equiv&quot;</span><span class="s0">,</span>
    <span class="s1">check_frame_type=</span><span class="s0">True,</span>
    <span class="s1">check_less_precise=no_default</span><span class="s0">,</span>
    <span class="s1">check_names=</span><span class="s0">True,</span>
    <span class="s1">by_blocks=</span><span class="s0">False,</span>
    <span class="s1">check_exact=</span><span class="s0">False,</span>
    <span class="s1">check_datetimelike_compat=</span><span class="s0">False,</span>
    <span class="s1">check_categorical=</span><span class="s0">True,</span>
    <span class="s1">check_like=</span><span class="s0">False,</span>
    <span class="s1">check_freq=</span><span class="s0">True,</span>
    <span class="s1">check_flags=</span><span class="s0">True,</span>
    <span class="s1">rtol=</span><span class="s3">1.0e-5</span><span class="s0">,</span>
    <span class="s1">atol=</span><span class="s3">1.0e-8</span><span class="s0">,</span>
    <span class="s1">obj=</span><span class="s4">&quot;DataFrame&quot;</span><span class="s0">,</span>
<span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Check that left and right DataFrame are equal. 
 
    This function is intended to compare two DataFrames and output any 
    differences. Is is mostly intended for use in unit tests. 
    Additional parameters allow varying the strictness of the 
    equality checks performed. 
 
    Parameters 
    ---------- 
    left : DataFrame 
        First DataFrame to compare. 
    right : DataFrame 
        Second DataFrame to compare. 
    check_dtype : bool, default True 
        Whether to check the DataFrame dtype is identical. 
    check_index_type : bool or {'equiv'}, default 'equiv' 
        Whether to check the Index class, dtype and inferred_type 
        are identical. 
    check_column_type : bool or {'equiv'}, default 'equiv' 
        Whether to check the columns class, dtype and inferred_type 
        are identical. Is passed as the ``exact`` argument of 
        :func:`assert_index_equal`. 
    check_frame_type : bool, default True 
        Whether to check the DataFrame class is identical. 
    check_less_precise : bool or int, default False 
        Specify comparison precision. Only used when check_exact is False. 
        5 digits (False) or 3 digits (True) after decimal points are compared. 
        If int, then specify the digits to compare. 
 
        When comparing two numbers, if the first number has magnitude less 
        than 1e-5, we compare the two numbers directly and check whether 
        they are equivalent within the specified precision. Otherwise, we 
        compare the **ratio** of the second number to the first number and 
        check whether it is equivalent to 1 within the specified precision. 
 
        .. deprecated:: 1.1.0 
           Use `rtol` and `atol` instead to define relative/absolute 
           tolerance, respectively. Similar to :func:`math.isclose`. 
    check_names : bool, default True 
        Whether to check that the `names` attribute for both the `index` 
        and `column` attributes of the DataFrame is identical. 
    by_blocks : bool, default False 
        Specify how to compare internal data. If False, compare by columns. 
        If True, compare by blocks. 
    check_exact : bool, default False 
        Whether to compare number exactly. 
    check_datetimelike_compat : bool, default False 
        Compare datetime-like which is comparable ignoring dtype. 
    check_categorical : bool, default True 
        Whether to compare internal Categorical exactly. 
    check_like : bool, default False 
        If True, ignore the order of index &amp; columns. 
        Note: index labels must match their respective rows 
        (same as in columns) - same labels must be with the same data. 
    check_freq : bool, default True 
        Whether to check the `freq` attribute on a DatetimeIndex or TimedeltaIndex. 
 
        .. versionadded:: 1.1.0 
    check_flags : bool, default True 
        Whether to check the `flags` attribute. 
    rtol : float, default 1e-5 
        Relative tolerance. Only used when check_exact is False. 
 
        .. versionadded:: 1.1.0 
    atol : float, default 1e-8 
        Absolute tolerance. Only used when check_exact is False. 
 
        .. versionadded:: 1.1.0 
    obj : str, default 'DataFrame' 
        Specify object name being compared, internally used to show appropriate 
        assertion message. 
 
    See Also 
    -------- 
    assert_series_equal : Equivalent method for asserting Series equality. 
    DataFrame.equals : Check DataFrame equality. 
 
    Examples 
    -------- 
    This example shows comparing two DataFrames that are equal 
    but with columns of differing dtypes. 
 
    &gt;&gt;&gt; from pandas._testing import assert_frame_equal 
    &gt;&gt;&gt; df1 = pd.DataFrame({'a': [1, 2], 'b': [3, 4]}) 
    &gt;&gt;&gt; df2 = pd.DataFrame({'a': [1, 2], 'b': [3.0, 4.0]}) 
 
    df1 equals itself. 
 
    &gt;&gt;&gt; assert_frame_equal(df1, df1) 
 
    df1 differs from df2 as column 'b' is of a different type. 
 
    &gt;&gt;&gt; assert_frame_equal(df1, df2) 
    Traceback (most recent call last): 
    ... 
    AssertionError: Attributes of DataFrame.iloc[:, 1] (column name=&quot;b&quot;) are different 
 
    Attribute &quot;dtype&quot; are different 
    [left]:  int64 
    [right]: float64 
 
    Ignore differing dtypes in columns with check_dtype. 
 
    &gt;&gt;&gt; assert_frame_equal(df1, df2, check_dtype=False) 
    &quot;&quot;&quot;</span>
    <span class="s1">__tracebackhide__ = </span><span class="s0">True</span>

    <span class="s0">if </span><span class="s1">check_less_precise </span><span class="s0">is not </span><span class="s1">no_default:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s4">&quot;The 'check_less_precise' keyword in testing.assert_*_equal &quot;</span>
            <span class="s4">&quot;is deprecated and will be removed in a future version. &quot;</span>
            <span class="s4">&quot;You can stop passing 'check_less_precise' to silence this warning.&quot;</span><span class="s0">,</span>
            <span class="s1">FutureWarning</span><span class="s0">,</span>
            <span class="s1">stacklevel=</span><span class="s3">2</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">rtol = atol = _get_tol_from_less_precise(check_less_precise)</span>

    <span class="s2"># instance validation</span>
    <span class="s1">_check_isinstance(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">DataFrame)</span>

    <span class="s0">if </span><span class="s1">check_frame_type:</span>
        <span class="s0">assert </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">type(right))</span>
        <span class="s2"># assert_class_equal(left, right, obj=obj)</span>

    <span class="s2"># shape comparison</span>
    <span class="s0">if </span><span class="s1">left.shape != right.shape:</span>
        <span class="s1">raise_assert_detail(</span>
            <span class="s1">obj</span><span class="s0">, </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">} </span><span class="s4">shape mismatch&quot;</span><span class="s0">, </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">repr(left.shape)</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s0">, </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">repr(right.shape)</span><span class="s0">}</span><span class="s4">&quot;</span>
        <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">check_flags:</span>
        <span class="s0">assert </span><span class="s1">left.flags == right.flags</span><span class="s0">, </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">repr(left.flags)</span><span class="s0">} </span><span class="s4">!= </span><span class="s0">{</span><span class="s1">repr(right.flags)</span><span class="s0">}</span><span class="s4">&quot;</span>

    <span class="s2"># index comparison</span>
    <span class="s1">assert_index_equal(</span>
        <span class="s1">left.index</span><span class="s0">,</span>
        <span class="s1">right.index</span><span class="s0">,</span>
        <span class="s1">exact=check_index_type</span><span class="s0">,</span>
        <span class="s1">check_names=check_names</span><span class="s0">,</span>
        <span class="s1">check_exact=check_exact</span><span class="s0">,</span>
        <span class="s1">check_categorical=check_categorical</span><span class="s0">,</span>
        <span class="s1">check_order=</span><span class="s0">not </span><span class="s1">check_like</span><span class="s0">,</span>
        <span class="s1">rtol=rtol</span><span class="s0">,</span>
        <span class="s1">atol=atol</span><span class="s0">,</span>
        <span class="s1">obj=</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s4">.index&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s2"># column comparison</span>
    <span class="s1">assert_index_equal(</span>
        <span class="s1">left.columns</span><span class="s0">,</span>
        <span class="s1">right.columns</span><span class="s0">,</span>
        <span class="s1">exact=check_column_type</span><span class="s0">,</span>
        <span class="s1">check_names=check_names</span><span class="s0">,</span>
        <span class="s1">check_exact=check_exact</span><span class="s0">,</span>
        <span class="s1">check_categorical=check_categorical</span><span class="s0">,</span>
        <span class="s1">check_order=</span><span class="s0">not </span><span class="s1">check_like</span><span class="s0">,</span>
        <span class="s1">rtol=rtol</span><span class="s0">,</span>
        <span class="s1">atol=atol</span><span class="s0">,</span>
        <span class="s1">obj=</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s4">.columns&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">check_like:</span>
        <span class="s1">left</span><span class="s0">, </span><span class="s1">right = left.reindex_like(right)</span><span class="s0">, </span><span class="s1">right</span>

    <span class="s2"># compare by blocks</span>
    <span class="s0">if </span><span class="s1">by_blocks:</span>
        <span class="s1">rblocks = right._to_dict_of_blocks()</span>
        <span class="s1">lblocks = left._to_dict_of_blocks()</span>
        <span class="s0">for </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">list(set(list(lblocks.keys()) + list(rblocks.keys()))):</span>
            <span class="s0">assert </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">lblocks</span>
            <span class="s0">assert </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">rblocks</span>
            <span class="s1">assert_frame_equal(</span>
                <span class="s1">lblocks[dtype]</span><span class="s0">, </span><span class="s1">rblocks[dtype]</span><span class="s0">, </span><span class="s1">check_dtype=check_dtype</span><span class="s0">, </span><span class="s1">obj=obj</span>
            <span class="s1">)</span>

    <span class="s2"># compare by columns</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">col </span><span class="s0">in </span><span class="s1">enumerate(left.columns):</span>
            <span class="s0">assert </span><span class="s1">col </span><span class="s0">in </span><span class="s1">right</span>
            <span class="s1">lcol = left.iloc[:</span><span class="s0">, </span><span class="s1">i]</span>
            <span class="s1">rcol = right.iloc[:</span><span class="s0">, </span><span class="s1">i]</span>
            <span class="s1">assert_series_equal(</span>
                <span class="s1">lcol</span><span class="s0">,</span>
                <span class="s1">rcol</span><span class="s0">,</span>
                <span class="s1">check_dtype=check_dtype</span><span class="s0">,</span>
                <span class="s1">check_index_type=check_index_type</span><span class="s0">,</span>
                <span class="s1">check_exact=check_exact</span><span class="s0">,</span>
                <span class="s1">check_names=check_names</span><span class="s0">,</span>
                <span class="s1">check_datetimelike_compat=check_datetimelike_compat</span><span class="s0">,</span>
                <span class="s1">check_categorical=check_categorical</span><span class="s0">,</span>
                <span class="s1">check_freq=check_freq</span><span class="s0">,</span>
                <span class="s1">obj=</span><span class="s4">f'</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s4">.iloc[:, </span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s4">] (column name=&quot;</span><span class="s0">{</span><span class="s1">col</span><span class="s0">}</span><span class="s4">&quot;)'</span><span class="s0">,</span>
                <span class="s1">rtol=rtol</span><span class="s0">,</span>
                <span class="s1">atol=atol</span><span class="s0">,</span>
            <span class="s1">)</span>


<span class="s0">def </span><span class="s1">assert_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s5">&quot;&quot;&quot; 
    Wrapper for tm.assert_*_equal to dispatch to the appropriate test function. 
 
    Parameters 
    ---------- 
    left, right : Index, Series, DataFrame, ExtensionArray, or np.ndarray 
        The two items to be compared. 
    **kwargs 
        All keyword arguments are passed through to the underlying assert method. 
    &quot;&quot;&quot;</span>
    <span class="s1">__tracebackhide__ = </span><span class="s0">True</span>

    <span class="s0">if </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">pd.Index):</span>
        <span class="s1">assert_index_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">if </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">(pd.DatetimeIndex</span><span class="s0">, </span><span class="s1">pd.TimedeltaIndex)):</span>
            <span class="s0">assert </span><span class="s1">left.freq == right.freq</span><span class="s0">, </span><span class="s1">(left.freq</span><span class="s0">, </span><span class="s1">right.freq)</span>
    <span class="s0">elif </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">pd.Series):</span>
        <span class="s1">assert_series_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">elif </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">pd.DataFrame):</span>
        <span class="s1">assert_frame_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">elif </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">IntervalArray):</span>
        <span class="s1">assert_interval_array_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">elif </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">PeriodArray):</span>
        <span class="s1">assert_period_array_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">elif </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">DatetimeArray):</span>
        <span class="s1">assert_datetime_array_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">elif </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">TimedeltaArray):</span>
        <span class="s1">assert_timedelta_array_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">elif </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">ExtensionArray):</span>
        <span class="s1">assert_extension_array_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">elif </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
        <span class="s1">assert_numpy_array_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">elif </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s0">assert </span><span class="s1">kwargs == {}</span>
        <span class="s0">assert </span><span class="s1">left == right</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(type(left))</span>


<span class="s0">def </span><span class="s1">box_expected(expected</span><span class="s0">, </span><span class="s1">box_cls</span><span class="s0">, </span><span class="s1">transpose=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Helper function to wrap the expected output of a test in a given box_class. 
 
    Parameters 
    ---------- 
    expected : np.ndarray, Index, Series 
    box_cls : {Index, Series, DataFrame} 
 
    Returns 
    ------- 
    subclass of box_cls 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">box_cls </span><span class="s0">is </span><span class="s1">pd.array:</span>
        <span class="s1">expected = pd.array(expected)</span>
    <span class="s0">elif </span><span class="s1">box_cls </span><span class="s0">is </span><span class="s1">pd.Index:</span>
        <span class="s1">expected = pd.Index(expected)</span>
    <span class="s0">elif </span><span class="s1">box_cls </span><span class="s0">is </span><span class="s1">pd.Series:</span>
        <span class="s1">expected = pd.Series(expected)</span>
    <span class="s0">elif </span><span class="s1">box_cls </span><span class="s0">is </span><span class="s1">pd.DataFrame:</span>
        <span class="s1">expected = pd.Series(expected).to_frame()</span>
        <span class="s0">if </span><span class="s1">transpose:</span>
            <span class="s2"># for vector operations, we need a DataFrame to be a single-row,</span>
            <span class="s2">#  not a single-column, in order to operate against non-DataFrame</span>
            <span class="s2">#  vectors of the same length.</span>
            <span class="s1">expected = expected.T</span>
    <span class="s0">elif </span><span class="s1">box_cls </span><span class="s0">is </span><span class="s1">PeriodArray:</span>
        <span class="s2"># the PeriodArray constructor is not as flexible as period_array</span>
        <span class="s1">expected = period_array(expected)</span>
    <span class="s0">elif </span><span class="s1">box_cls </span><span class="s0">is </span><span class="s1">DatetimeArray:</span>
        <span class="s1">expected = DatetimeArray(expected)</span>
    <span class="s0">elif </span><span class="s1">box_cls </span><span class="s0">is </span><span class="s1">TimedeltaArray:</span>
        <span class="s1">expected = TimedeltaArray(expected)</span>
    <span class="s0">elif </span><span class="s1">box_cls </span><span class="s0">is </span><span class="s1">np.ndarray:</span>
        <span class="s1">expected = np.array(expected)</span>
    <span class="s0">elif </span><span class="s1">box_cls </span><span class="s0">is </span><span class="s1">to_array:</span>
        <span class="s1">expected = to_array(expected)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(box_cls)</span>
    <span class="s0">return </span><span class="s1">expected</span>


<span class="s0">def </span><span class="s1">to_array(obj):</span>
    <span class="s2"># temporary implementation until we get pd.array in place</span>
    <span class="s1">dtype = getattr(obj</span><span class="s0">, </span><span class="s4">&quot;dtype&quot;</span><span class="s0">, None</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">is_period_dtype(dtype):</span>
        <span class="s0">return </span><span class="s1">period_array(obj)</span>
    <span class="s0">elif </span><span class="s1">is_datetime64_dtype(dtype) </span><span class="s0">or </span><span class="s1">is_datetime64tz_dtype(dtype):</span>
        <span class="s0">return </span><span class="s1">DatetimeArray._from_sequence(obj)</span>
    <span class="s0">elif </span><span class="s1">is_timedelta64_dtype(dtype):</span>
        <span class="s0">return </span><span class="s1">TimedeltaArray._from_sequence(obj)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">np.array(obj)</span>


<span class="s2"># -----------------------------------------------------------------------------</span>
<span class="s2"># Sparse</span>


<span class="s0">def </span><span class="s1">assert_sp_array_equal(left</span><span class="s0">, </span><span class="s1">right):</span>
    <span class="s5">&quot;&quot;&quot; 
    Check that the left and right SparseArray are equal. 
 
    Parameters 
    ---------- 
    left : SparseArray 
    right : SparseArray 
    &quot;&quot;&quot;</span>
    <span class="s1">_check_isinstance(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">pd.arrays.SparseArray)</span>

    <span class="s1">assert_numpy_array_equal(left.sp_values</span><span class="s0">, </span><span class="s1">right.sp_values)</span>

    <span class="s2"># SparseIndex comparison</span>
    <span class="s0">assert </span><span class="s1">isinstance(left.sp_index</span><span class="s0">, </span><span class="s1">pd._libs.sparse.SparseIndex)</span>
    <span class="s0">assert </span><span class="s1">isinstance(right.sp_index</span><span class="s0">, </span><span class="s1">pd._libs.sparse.SparseIndex)</span>

    <span class="s1">left_index = left.sp_index</span>
    <span class="s1">right_index = right.sp_index</span>

    <span class="s0">if not </span><span class="s1">left_index.equals(right_index):</span>
        <span class="s1">raise_assert_detail(</span>
            <span class="s4">&quot;SparseArray.index&quot;</span><span class="s0">, </span><span class="s4">&quot;index are not equal&quot;</span><span class="s0">, </span><span class="s1">left_index</span><span class="s0">, </span><span class="s1">right_index</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s2"># Just ensure a</span>
        <span class="s0">pass</span>

    <span class="s1">assert_attr_equal(</span><span class="s4">&quot;fill_value&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right)</span>
    <span class="s1">assert_attr_equal(</span><span class="s4">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right)</span>
    <span class="s1">assert_numpy_array_equal(left.to_dense()</span><span class="s0">, </span><span class="s1">right.to_dense())</span>


<span class="s2"># -----------------------------------------------------------------------------</span>
<span class="s2"># Others</span>


<span class="s0">def </span><span class="s1">assert_contains_all(iterable</span><span class="s0">, </span><span class="s1">dic):</span>
    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">iterable:</span>
        <span class="s0">assert </span><span class="s1">k </span><span class="s0">in </span><span class="s1">dic</span><span class="s0">, </span><span class="s4">f&quot;Did not contain item: </span><span class="s0">{</span><span class="s1">repr(k)</span><span class="s0">}</span><span class="s4">&quot;</span>


<span class="s0">def </span><span class="s1">assert_copy(iter1</span><span class="s0">, </span><span class="s1">iter2</span><span class="s0">, </span><span class="s1">**eql_kwargs):</span>
    <span class="s5">&quot;&quot;&quot; 
    iter1, iter2: iterables that produce elements 
    comparable with assert_almost_equal 
 
    Checks that the elements are equal, but not 
    the same object. (Does not check that items 
    in sequences are also not the same object) 
    &quot;&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">elem1</span><span class="s0">, </span><span class="s1">elem2 </span><span class="s0">in </span><span class="s1">zip(iter1</span><span class="s0">, </span><span class="s1">iter2):</span>
        <span class="s1">assert_almost_equal(elem1</span><span class="s0">, </span><span class="s1">elem2</span><span class="s0">, </span><span class="s1">**eql_kwargs)</span>
        <span class="s1">msg = (</span>
            <span class="s4">f&quot;Expected object </span><span class="s0">{</span><span class="s1">repr(type(elem1))</span><span class="s0">} </span><span class="s4">and object </span><span class="s0">{</span><span class="s1">repr(type(elem2))</span><span class="s0">} </span><span class="s4">to be &quot;</span>
            <span class="s4">&quot;different objects, but they were the same object.&quot;</span>
        <span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">elem1 </span><span class="s0">is not </span><span class="s1">elem2</span><span class="s0">, </span><span class="s1">msg</span>


<span class="s0">def </span><span class="s1">is_extension_array_dtype_and_needs_i8_conversion(left_dtype</span><span class="s0">, </span><span class="s1">right_dtype) -&gt; bool:</span>
    <span class="s5">&quot;&quot;&quot; 
    Checks that we have the combination of an ExtensionArraydtype and 
    a dtype that should be converted to int64 
 
    Returns 
    ------- 
    bool 
 
    Related to issue #37609 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">is_extension_array_dtype(left_dtype) </span><span class="s0">and </span><span class="s1">needs_i8_conversion(right_dtype)</span>


<span class="s0">def </span><span class="s1">getCols(k):</span>
    <span class="s0">return </span><span class="s1">string.ascii_uppercase[:k]</span>


<span class="s2"># make index</span>
<span class="s0">def </span><span class="s1">makeStringIndex(k=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">name=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">return </span><span class="s1">Index(rands_array(nchars=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">size=k)</span><span class="s0">, </span><span class="s1">name=name)</span>


<span class="s0">def </span><span class="s1">makeUnicodeIndex(k=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">name=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">return </span><span class="s1">Index(randu_array(nchars=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">size=k)</span><span class="s0">, </span><span class="s1">name=name)</span>


<span class="s0">def </span><span class="s1">makeCategoricalIndex(k=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">name=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
    <span class="s5">&quot;&quot;&quot; make a length k index or n categories &quot;&quot;&quot;</span>
    <span class="s1">x = rands_array(nchars=</span><span class="s3">4</span><span class="s0">, </span><span class="s1">size=n)</span>
    <span class="s0">return </span><span class="s1">CategoricalIndex(</span>
        <span class="s1">Categorical.from_codes(np.arange(k) % n</span><span class="s0">, </span><span class="s1">categories=x)</span><span class="s0">, </span><span class="s1">name=name</span><span class="s0">, </span><span class="s1">**kwargs</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">makeIntervalIndex(k=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">name=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
    <span class="s5">&quot;&quot;&quot; make a length k IntervalIndex &quot;&quot;&quot;</span>
    <span class="s1">x = np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">100</span><span class="s0">, </span><span class="s1">num=(k + </span><span class="s3">1</span><span class="s1">))</span>
    <span class="s0">return </span><span class="s1">IntervalIndex.from_breaks(x</span><span class="s0">, </span><span class="s1">name=name</span><span class="s0">, </span><span class="s1">**kwargs)</span>


<span class="s0">def </span><span class="s1">makeBoolIndex(k=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">name=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">if </span><span class="s1">k == </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">Index([</span><span class="s0">True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=name)</span>
    <span class="s0">elif </span><span class="s1">k == </span><span class="s3">2</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">Index([</span><span class="s0">False, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=name)</span>
    <span class="s0">return </span><span class="s1">Index([</span><span class="s0">False, True</span><span class="s1">] + [</span><span class="s0">False</span><span class="s1">] * (k - </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=name)</span>


<span class="s0">def </span><span class="s1">makeIntIndex(k=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">name=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">return </span><span class="s1">Index(list(range(k))</span><span class="s0">, </span><span class="s1">name=name)</span>


<span class="s0">def </span><span class="s1">makeUIntIndex(k=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">name=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">return </span><span class="s1">Index([</span><span class="s3">2 </span><span class="s1">** </span><span class="s3">63 </span><span class="s1">+ i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(k)]</span><span class="s0">, </span><span class="s1">name=name)</span>


<span class="s0">def </span><span class="s1">makeRangeIndex(k=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">name=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
    <span class="s0">return </span><span class="s1">RangeIndex(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">name=name</span><span class="s0">, </span><span class="s1">**kwargs)</span>


<span class="s0">def </span><span class="s1">makeFloatIndex(k=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">name=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s1">values = sorted(np.random.random_sample(k)) - np.random.random_sample(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Index(values * (</span><span class="s3">10 </span><span class="s1">** np.random.randint(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">9</span><span class="s1">))</span><span class="s0">, </span><span class="s1">name=name)</span>


<span class="s0">def </span><span class="s1">makeDateIndex(k=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">freq=</span><span class="s4">&quot;B&quot;</span><span class="s0">, </span><span class="s1">name=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
    <span class="s1">dt = datetime(</span><span class="s3">2000</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">dr = bdate_range(dt</span><span class="s0">, </span><span class="s1">periods=k</span><span class="s0">, </span><span class="s1">freq=freq</span><span class="s0">, </span><span class="s1">name=name)</span>
    <span class="s0">return </span><span class="s1">DatetimeIndex(dr</span><span class="s0">, </span><span class="s1">name=name</span><span class="s0">, </span><span class="s1">**kwargs)</span>


<span class="s0">def </span><span class="s1">makeTimedeltaIndex(k=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">freq=</span><span class="s4">&quot;D&quot;</span><span class="s0">, </span><span class="s1">name=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
    <span class="s0">return </span><span class="s1">pd.timedelta_range(start=</span><span class="s4">&quot;1 day&quot;</span><span class="s0">, </span><span class="s1">periods=k</span><span class="s0">, </span><span class="s1">freq=freq</span><span class="s0">, </span><span class="s1">name=name</span><span class="s0">, </span><span class="s1">**kwargs)</span>


<span class="s0">def </span><span class="s1">makePeriodIndex(k=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">name=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
    <span class="s1">dt = datetime(</span><span class="s3">2000</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">pd.period_range(start=dt</span><span class="s0">, </span><span class="s1">periods=k</span><span class="s0">, </span><span class="s1">freq=</span><span class="s4">&quot;B&quot;</span><span class="s0">, </span><span class="s1">name=name</span><span class="s0">, </span><span class="s1">**kwargs)</span>


<span class="s0">def </span><span class="s1">makeMultiIndex(k=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">names=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
    <span class="s0">return </span><span class="s1">MultiIndex.from_product(((</span><span class="s4">&quot;foo&quot;</span><span class="s0">, </span><span class="s4">&quot;bar&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">names=names</span><span class="s0">, </span><span class="s1">**kwargs)</span>


<span class="s1">_names = [</span>
    <span class="s4">&quot;Alice&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Bob&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Charlie&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Dan&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Edith&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Frank&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;George&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Hannah&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Ingrid&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Jerry&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Kevin&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Laura&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Michael&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Norbert&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Oliver&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Patricia&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Quinn&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Ray&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Sarah&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Tim&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Ursula&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Victor&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Wendy&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Xavier&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Yvonne&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Zelda&quot;</span><span class="s0">,</span>
<span class="s1">]</span>


<span class="s0">def </span><span class="s1">_make_timeseries(start=</span><span class="s4">&quot;2000-01-01&quot;</span><span class="s0">, </span><span class="s1">end=</span><span class="s4">&quot;2000-12-31&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s4">&quot;1D&quot;</span><span class="s0">, </span><span class="s1">seed=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Make a DataFrame with a DatetimeIndex 
 
    Parameters 
    ---------- 
    start : str or Timestamp, default &quot;2000-01-01&quot; 
        The start of the index. Passed to date_range with `freq`. 
    end : str or Timestamp, default &quot;2000-12-31&quot; 
        The end of the index. Passed to date_range with `freq`. 
    freq : str or Freq 
        The frequency to use for the DatetimeIndex 
    seed : int, optional 
        The random state seed. 
 
        * name : object dtype with string names 
        * id : int dtype with 
        * x, y : float dtype 
 
    Examples 
    -------- 
    &gt;&gt;&gt; _make_timeseries() 
                  id    name         x         y 
    timestamp 
    2000-01-01   982   Frank  0.031261  0.986727 
    2000-01-02  1025   Edith -0.086358 -0.032920 
    2000-01-03   982   Edith  0.473177  0.298654 
    2000-01-04  1009   Sarah  0.534344 -0.750377 
    2000-01-05   963   Zelda -0.271573  0.054424 
    ...          ...     ...       ...       ... 
    2000-12-27   980  Ingrid -0.132333 -0.422195 
    2000-12-28   972   Frank -0.376007 -0.298687 
    2000-12-29  1009  Ursula -0.865047 -0.503133 
    2000-12-30  1000  Hannah -0.063757 -0.507336 
    2000-12-31   972     Tim -0.869120  0.531685 
    &quot;&quot;&quot;</span>
    <span class="s1">index = pd.date_range(start=start</span><span class="s0">, </span><span class="s1">end=end</span><span class="s0">, </span><span class="s1">freq=freq</span><span class="s0">, </span><span class="s1">name=</span><span class="s4">&quot;timestamp&quot;</span><span class="s1">)</span>
    <span class="s1">n = len(index)</span>
    <span class="s1">state = np.random.RandomState(seed)</span>
    <span class="s1">columns = {</span>
        <span class="s4">&quot;name&quot;</span><span class="s1">: state.choice(_names</span><span class="s0">, </span><span class="s1">size=n)</span><span class="s0">,</span>
        <span class="s4">&quot;id&quot;</span><span class="s1">: state.poisson(</span><span class="s3">1000</span><span class="s0">, </span><span class="s1">size=n)</span><span class="s0">,</span>
        <span class="s4">&quot;x&quot;</span><span class="s1">: state.rand(n) * </span><span class="s3">2 </span><span class="s1">- </span><span class="s3">1</span><span class="s0">,</span>
        <span class="s4">&quot;y&quot;</span><span class="s1">: state.rand(n) * </span><span class="s3">2 </span><span class="s1">- </span><span class="s3">1</span><span class="s0">,</span>
    <span class="s1">}</span>
    <span class="s1">df = pd.DataFrame(columns</span><span class="s0">, </span><span class="s1">index=index</span><span class="s0">, </span><span class="s1">columns=sorted(columns))</span>
    <span class="s0">if </span><span class="s1">df.index[-</span><span class="s3">1</span><span class="s1">] == end:</span>
        <span class="s1">df = df.iloc[:-</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s0">return </span><span class="s1">df</span>


<span class="s0">def </span><span class="s1">index_subclass_makers_generator():</span>
    <span class="s1">make_index_funcs = [</span>
        <span class="s1">makeDateIndex</span><span class="s0">,</span>
        <span class="s1">makePeriodIndex</span><span class="s0">,</span>
        <span class="s1">makeTimedeltaIndex</span><span class="s0">,</span>
        <span class="s1">makeRangeIndex</span><span class="s0">,</span>
        <span class="s1">makeIntervalIndex</span><span class="s0">,</span>
        <span class="s1">makeCategoricalIndex</span><span class="s0">,</span>
        <span class="s1">makeMultiIndex</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s0">yield from </span><span class="s1">make_index_funcs</span>


<span class="s0">def </span><span class="s1">all_timeseries_index_generator(k=</span><span class="s3">10</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Generator which can be iterated over to get instances of all the classes 
    which represent time-series. 
 
    Parameters 
    ---------- 
    k: length of each of the index instances 
    &quot;&quot;&quot;</span>
    <span class="s1">make_index_funcs = [makeDateIndex</span><span class="s0">, </span><span class="s1">makePeriodIndex</span><span class="s0">, </span><span class="s1">makeTimedeltaIndex]</span>
    <span class="s0">for </span><span class="s1">make_index_func </span><span class="s0">in </span><span class="s1">make_index_funcs:</span>
        <span class="s2"># pandas\_testing.py:1986: error: Cannot call function of unknown type</span>
        <span class="s0">yield </span><span class="s1">make_index_func(k=k)  </span><span class="s2"># type: ignore[operator]</span>


<span class="s2"># make series</span>
<span class="s0">def </span><span class="s1">makeFloatSeries(name=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s1">index = makeStringIndex(_N)</span>
    <span class="s0">return </span><span class="s1">Series(randn(_N)</span><span class="s0">, </span><span class="s1">index=index</span><span class="s0">, </span><span class="s1">name=name)</span>


<span class="s0">def </span><span class="s1">makeStringSeries(name=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s1">index = makeStringIndex(_N)</span>
    <span class="s0">return </span><span class="s1">Series(randn(_N)</span><span class="s0">, </span><span class="s1">index=index</span><span class="s0">, </span><span class="s1">name=name)</span>


<span class="s0">def </span><span class="s1">makeObjectSeries(name=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s1">data = makeStringIndex(_N)</span>
    <span class="s1">data = Index(data</span><span class="s0">, </span><span class="s1">dtype=object)</span>
    <span class="s1">index = makeStringIndex(_N)</span>
    <span class="s0">return </span><span class="s1">Series(data</span><span class="s0">, </span><span class="s1">index=index</span><span class="s0">, </span><span class="s1">name=name)</span>


<span class="s0">def </span><span class="s1">getSeriesData():</span>
    <span class="s1">index = makeStringIndex(_N)</span>
    <span class="s0">return </span><span class="s1">{c: Series(randn(_N)</span><span class="s0">, </span><span class="s1">index=index) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">getCols(_K)}</span>


<span class="s0">def </span><span class="s1">makeTimeSeries(nper=</span><span class="s0">None, </span><span class="s1">freq=</span><span class="s4">&quot;B&quot;</span><span class="s0">, </span><span class="s1">name=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">if </span><span class="s1">nper </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">nper = _N</span>
    <span class="s0">return </span><span class="s1">Series(randn(nper)</span><span class="s0">, </span><span class="s1">index=makeDateIndex(nper</span><span class="s0">, </span><span class="s1">freq=freq)</span><span class="s0">, </span><span class="s1">name=name)</span>


<span class="s0">def </span><span class="s1">makePeriodSeries(nper=</span><span class="s0">None, </span><span class="s1">name=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">if </span><span class="s1">nper </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">nper = _N</span>
    <span class="s0">return </span><span class="s1">Series(randn(nper)</span><span class="s0">, </span><span class="s1">index=makePeriodIndex(nper)</span><span class="s0">, </span><span class="s1">name=name)</span>


<span class="s0">def </span><span class="s1">getTimeSeriesData(nper=</span><span class="s0">None, </span><span class="s1">freq=</span><span class="s4">&quot;B&quot;</span><span class="s1">):</span>
    <span class="s0">return </span><span class="s1">{c: makeTimeSeries(nper</span><span class="s0">, </span><span class="s1">freq) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">getCols(_K)}</span>


<span class="s0">def </span><span class="s1">getPeriodData(nper=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">return </span><span class="s1">{c: makePeriodSeries(nper) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">getCols(_K)}</span>


<span class="s2"># make frame</span>
<span class="s0">def </span><span class="s1">makeTimeDataFrame(nper=</span><span class="s0">None, </span><span class="s1">freq=</span><span class="s4">&quot;B&quot;</span><span class="s1">):</span>
    <span class="s1">data = getTimeSeriesData(nper</span><span class="s0">, </span><span class="s1">freq)</span>
    <span class="s0">return </span><span class="s1">DataFrame(data)</span>


<span class="s0">def </span><span class="s1">makeDataFrame():</span>
    <span class="s1">data = getSeriesData()</span>
    <span class="s0">return </span><span class="s1">DataFrame(data)</span>


<span class="s0">def </span><span class="s1">getMixedTypeDict():</span>
    <span class="s1">index = Index([</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s4">&quot;c&quot;</span><span class="s0">, </span><span class="s4">&quot;d&quot;</span><span class="s0">, </span><span class="s4">&quot;e&quot;</span><span class="s1">])</span>

    <span class="s1">data = {</span>
        <span class="s4">&quot;A&quot;</span><span class="s1">: [</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">3.0</span><span class="s0">, </span><span class="s3">4.0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s4">&quot;B&quot;</span><span class="s1">: [</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s4">&quot;C&quot;</span><span class="s1">: [</span><span class="s4">&quot;foo1&quot;</span><span class="s0">, </span><span class="s4">&quot;foo2&quot;</span><span class="s0">, </span><span class="s4">&quot;foo3&quot;</span><span class="s0">, </span><span class="s4">&quot;foo4&quot;</span><span class="s0">, </span><span class="s4">&quot;foo5&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s4">&quot;D&quot;</span><span class="s1">: bdate_range(</span><span class="s4">&quot;1/1/2009&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">5</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">}</span>

    <span class="s0">return </span><span class="s1">index</span><span class="s0">, </span><span class="s1">data</span>


<span class="s0">def </span><span class="s1">makeMixedDataFrame():</span>
    <span class="s0">return </span><span class="s1">DataFrame(getMixedTypeDict()[</span><span class="s3">1</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">makePeriodFrame(nper=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s1">data = getPeriodData(nper)</span>
    <span class="s0">return </span><span class="s1">DataFrame(data)</span>


<span class="s0">def </span><span class="s1">makeCustomIndex(</span>
    <span class="s1">nentries</span><span class="s0">, </span><span class="s1">nlevels</span><span class="s0">, </span><span class="s1">prefix=</span><span class="s4">&quot;#&quot;</span><span class="s0">, </span><span class="s1">names=</span><span class="s0">False, </span><span class="s1">ndupe_l=</span><span class="s0">None, </span><span class="s1">idx_type=</span><span class="s0">None</span>
<span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Create an index/multindex with given dimensions, levels, names, etc' 
 
    nentries - number of entries in index 
    nlevels - number of levels (&gt; 1 produces multindex) 
    prefix - a string prefix for labels 
    names - (Optional), bool or list of strings. if True will use default 
       names, if false will use no names, if a list is given, the name of 
       each level in the index will be taken from the list. 
    ndupe_l - (Optional), list of ints, the number of rows for which the 
       label will repeated at the corresponding level, you can specify just 
       the first few, the rest will use the default ndupe_l of 1. 
       len(ndupe_l) &lt;= nlevels. 
    idx_type - &quot;i&quot;/&quot;f&quot;/&quot;s&quot;/&quot;u&quot;/&quot;dt&quot;/&quot;p&quot;/&quot;td&quot;. 
       If idx_type is not None, `idx_nlevels` must be 1. 
       &quot;i&quot;/&quot;f&quot; creates an integer/float index, 
       &quot;s&quot;/&quot;u&quot; creates a string/unicode index 
       &quot;dt&quot; create a datetime index. 
       &quot;td&quot; create a datetime index. 
 
        if unspecified, string labels will be generated. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">ndupe_l </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">ndupe_l = [</span><span class="s3">1</span><span class="s1">] * nlevels</span>
    <span class="s0">assert </span><span class="s1">is_sequence(ndupe_l) </span><span class="s0">and </span><span class="s1">len(ndupe_l) &lt;= nlevels</span>
    <span class="s0">assert </span><span class="s1">names </span><span class="s0">is None or </span><span class="s1">names </span><span class="s0">is False or </span><span class="s1">names </span><span class="s0">is True or </span><span class="s1">len(names) </span><span class="s0">is </span><span class="s1">nlevels</span>
    <span class="s0">assert </span><span class="s1">idx_type </span><span class="s0">is None or </span><span class="s1">(</span>
        <span class="s1">idx_type </span><span class="s0">in </span><span class="s1">(</span><span class="s4">&quot;i&quot;</span><span class="s0">, </span><span class="s4">&quot;f&quot;</span><span class="s0">, </span><span class="s4">&quot;s&quot;</span><span class="s0">, </span><span class="s4">&quot;u&quot;</span><span class="s0">, </span><span class="s4">&quot;dt&quot;</span><span class="s0">, </span><span class="s4">&quot;p&quot;</span><span class="s0">, </span><span class="s4">&quot;td&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">nlevels == </span><span class="s3">1</span>
    <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">names </span><span class="s0">is True</span><span class="s1">:</span>
        <span class="s2"># build default names</span>
        <span class="s1">names = [prefix + str(i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(nlevels)]</span>
    <span class="s0">if </span><span class="s1">names </span><span class="s0">is False</span><span class="s1">:</span>
        <span class="s2"># pass None to index constructor for no name</span>
        <span class="s1">names = </span><span class="s0">None</span>

    <span class="s2"># make singleton case uniform</span>
    <span class="s0">if </span><span class="s1">isinstance(names</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">and </span><span class="s1">nlevels == </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">names = [names]</span>

    <span class="s2"># specific 1D index type requested?</span>
    <span class="s1">idx_func = {</span>
        <span class="s4">&quot;i&quot;</span><span class="s1">: makeIntIndex</span><span class="s0">,</span>
        <span class="s4">&quot;f&quot;</span><span class="s1">: makeFloatIndex</span><span class="s0">,</span>
        <span class="s4">&quot;s&quot;</span><span class="s1">: makeStringIndex</span><span class="s0">,</span>
        <span class="s4">&quot;u&quot;</span><span class="s1">: makeUnicodeIndex</span><span class="s0">,</span>
        <span class="s4">&quot;dt&quot;</span><span class="s1">: makeDateIndex</span><span class="s0">,</span>
        <span class="s4">&quot;td&quot;</span><span class="s1">: makeTimedeltaIndex</span><span class="s0">,</span>
        <span class="s4">&quot;p&quot;</span><span class="s1">: makePeriodIndex</span><span class="s0">,</span>
    <span class="s1">}.get(idx_type)</span>
    <span class="s0">if </span><span class="s1">idx_func:</span>
        <span class="s2"># pandas\_testing.py:2120: error: Cannot call function of unknown type</span>
        <span class="s1">idx = idx_func(nentries)  </span><span class="s2"># type: ignore[operator]</span>
        <span class="s2"># but we need to fill in the name</span>
        <span class="s0">if </span><span class="s1">names:</span>
            <span class="s1">idx.name = names[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">idx</span>
    <span class="s0">elif </span><span class="s1">idx_type </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">repr(idx_type)</span><span class="s0">} </span><span class="s4">is not a legal value for `idx_type`, &quot;</span>
            <span class="s4">&quot;use  'i'/'f'/'s'/'u'/'dt'/'p'/'td'.&quot;</span>
        <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">len(ndupe_l) &lt; nlevels:</span>
        <span class="s1">ndupe_l.extend([</span><span class="s3">1</span><span class="s1">] * (nlevels - len(ndupe_l)))</span>
    <span class="s0">assert </span><span class="s1">len(ndupe_l) == nlevels</span>

    <span class="s0">assert </span><span class="s1">all(x &gt; </span><span class="s3">0 </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">ndupe_l)</span>

    <span class="s1">tuples = []</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(nlevels):</span>

        <span class="s0">def </span><span class="s1">keyfunc(x):</span>
            <span class="s0">import </span><span class="s1">re</span>

            <span class="s1">numeric_tuple = re.sub(</span><span class="s4">r&quot;[^\d_]_?&quot;</span><span class="s0">, </span><span class="s4">&quot;&quot;</span><span class="s0">, </span><span class="s1">x).split(</span><span class="s4">&quot;_&quot;</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">[int(num) </span><span class="s0">for </span><span class="s1">num </span><span class="s0">in </span><span class="s1">numeric_tuple]</span>

        <span class="s2"># build a list of lists to create the index from</span>
        <span class="s1">div_factor = nentries // ndupe_l[i] + </span><span class="s3">1</span>
        <span class="s2"># pandas\_testing.py:2148: error: Need type annotation for 'cnt'</span>
        <span class="s1">cnt = Counter()  </span><span class="s2"># type: ignore[var-annotated]</span>
        <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(div_factor):</span>
            <span class="s1">label = </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">prefix</span><span class="s0">}</span><span class="s4">_l</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s4">_g</span><span class="s0">{</span><span class="s1">j</span><span class="s0">}</span><span class="s4">&quot;</span>
            <span class="s1">cnt[label] = ndupe_l[i]</span>
        <span class="s2"># cute Counter trick</span>
        <span class="s1">result = sorted(cnt.elements()</span><span class="s0">, </span><span class="s1">key=keyfunc)[:nentries]</span>
        <span class="s1">tuples.append(result)</span>

    <span class="s1">tuples = list(zip(*tuples))</span>

    <span class="s2"># convert tuples to index</span>
    <span class="s0">if </span><span class="s1">nentries == </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s2"># we have a single level of tuples, i.e. a regular Index</span>
        <span class="s1">index = Index(tuples[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=names[</span><span class="s3">0</span><span class="s1">])</span>
    <span class="s0">elif </span><span class="s1">nlevels == </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">name = </span><span class="s0">None if </span><span class="s1">names </span><span class="s0">is None else </span><span class="s1">names[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">index = Index((x[</span><span class="s3">0</span><span class="s1">] </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">tuples)</span><span class="s0">, </span><span class="s1">name=name)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">index = MultiIndex.from_tuples(tuples</span><span class="s0">, </span><span class="s1">names=names)</span>
    <span class="s0">return </span><span class="s1">index</span>


<span class="s0">def </span><span class="s1">makeCustomDataframe(</span>
    <span class="s1">nrows</span><span class="s0">,</span>
    <span class="s1">ncols</span><span class="s0">,</span>
    <span class="s1">c_idx_names=</span><span class="s0">True,</span>
    <span class="s1">r_idx_names=</span><span class="s0">True,</span>
    <span class="s1">c_idx_nlevels=</span><span class="s3">1</span><span class="s0">,</span>
    <span class="s1">r_idx_nlevels=</span><span class="s3">1</span><span class="s0">,</span>
    <span class="s1">data_gen_f=</span><span class="s0">None,</span>
    <span class="s1">c_ndupe_l=</span><span class="s0">None,</span>
    <span class="s1">r_ndupe_l=</span><span class="s0">None,</span>
    <span class="s1">dtype=</span><span class="s0">None,</span>
    <span class="s1">c_idx_type=</span><span class="s0">None,</span>
    <span class="s1">r_idx_type=</span><span class="s0">None,</span>
<span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Create a DataFrame using supplied parameters. 
 
    Parameters 
    ---------- 
    nrows,  ncols - number of data rows/cols 
    c_idx_names, idx_names  - False/True/list of strings,  yields No names , 
            default names or uses the provided names for the levels of the 
            corresponding index. You can provide a single string when 
            c_idx_nlevels ==1. 
    c_idx_nlevels - number of levels in columns index. &gt; 1 will yield MultiIndex 
    r_idx_nlevels - number of levels in rows index. &gt; 1 will yield MultiIndex 
    data_gen_f - a function f(row,col) which return the data value 
            at that position, the default generator used yields values of the form 
            &quot;RxCy&quot; based on position. 
    c_ndupe_l, r_ndupe_l - list of integers, determines the number 
            of duplicates for each label at a given level of the corresponding 
            index. The default `None` value produces a multiplicity of 1 across 
            all levels, i.e. a unique index. Will accept a partial list of length 
            N &lt; idx_nlevels, for just the first N levels. If ndupe doesn't divide 
            nrows/ncol, the last label might have lower multiplicity. 
    dtype - passed to the DataFrame constructor as is, in case you wish to 
            have more control in conjunction with a custom `data_gen_f` 
    r_idx_type, c_idx_type -  &quot;i&quot;/&quot;f&quot;/&quot;s&quot;/&quot;u&quot;/&quot;dt&quot;/&quot;td&quot;. 
        If idx_type is not None, `idx_nlevels` must be 1. 
        &quot;i&quot;/&quot;f&quot; creates an integer/float index, 
        &quot;s&quot;/&quot;u&quot; creates a string/unicode index 
        &quot;dt&quot; create a datetime index. 
        &quot;td&quot; create a timedelta index. 
 
            if unspecified, string labels will be generated. 
 
    Examples 
    -------- 
    # 5 row, 3 columns, default names on both, single index on both axis 
    &gt;&gt; makeCustomDataframe(5,3) 
 
    # make the data a random int between 1 and 100 
    &gt;&gt; mkdf(5,3,data_gen_f=lambda r,c:randint(1,100)) 
 
    # 2-level multiindex on rows with each label duplicated 
    # twice on first level, default names on both axis, single 
    # index on both axis 
    &gt;&gt; a=makeCustomDataframe(5,3,r_idx_nlevels=2,r_ndupe_l=[2]) 
 
    # DatetimeIndex on row, index with unicode labels on columns 
    # no names on either axis 
    &gt;&gt; a=makeCustomDataframe(5,3,c_idx_names=False,r_idx_names=False, 
                             r_idx_type=&quot;dt&quot;,c_idx_type=&quot;u&quot;) 
 
    # 4-level multindex on rows with names provided, 2-level multindex 
    # on columns with default labels and default names. 
    &gt;&gt; a=makeCustomDataframe(5,3,r_idx_nlevels=4, 
                             r_idx_names=[&quot;FEE&quot;,&quot;FI&quot;,&quot;FO&quot;,&quot;FAM&quot;], 
                             c_idx_nlevels=2) 
 
    &gt;&gt; a=mkdf(5,3,r_idx_nlevels=2,c_idx_nlevels=4) 
    &quot;&quot;&quot;</span>
    <span class="s0">assert </span><span class="s1">c_idx_nlevels &gt; </span><span class="s3">0</span>
    <span class="s0">assert </span><span class="s1">r_idx_nlevels &gt; </span><span class="s3">0</span>
    <span class="s0">assert </span><span class="s1">r_idx_type </span><span class="s0">is None or </span><span class="s1">(</span>
        <span class="s1">r_idx_type </span><span class="s0">in </span><span class="s1">(</span><span class="s4">&quot;i&quot;</span><span class="s0">, </span><span class="s4">&quot;f&quot;</span><span class="s0">, </span><span class="s4">&quot;s&quot;</span><span class="s0">, </span><span class="s4">&quot;u&quot;</span><span class="s0">, </span><span class="s4">&quot;dt&quot;</span><span class="s0">, </span><span class="s4">&quot;p&quot;</span><span class="s0">, </span><span class="s4">&quot;td&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">r_idx_nlevels == </span><span class="s3">1</span>
    <span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">c_idx_type </span><span class="s0">is None or </span><span class="s1">(</span>
        <span class="s1">c_idx_type </span><span class="s0">in </span><span class="s1">(</span><span class="s4">&quot;i&quot;</span><span class="s0">, </span><span class="s4">&quot;f&quot;</span><span class="s0">, </span><span class="s4">&quot;s&quot;</span><span class="s0">, </span><span class="s4">&quot;u&quot;</span><span class="s0">, </span><span class="s4">&quot;dt&quot;</span><span class="s0">, </span><span class="s4">&quot;p&quot;</span><span class="s0">, </span><span class="s4">&quot;td&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">c_idx_nlevels == </span><span class="s3">1</span>
    <span class="s1">)</span>

    <span class="s1">columns = makeCustomIndex(</span>
        <span class="s1">ncols</span><span class="s0">,</span>
        <span class="s1">nlevels=c_idx_nlevels</span><span class="s0">,</span>
        <span class="s1">prefix=</span><span class="s4">&quot;C&quot;</span><span class="s0">,</span>
        <span class="s1">names=c_idx_names</span><span class="s0">,</span>
        <span class="s1">ndupe_l=c_ndupe_l</span><span class="s0">,</span>
        <span class="s1">idx_type=c_idx_type</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">index = makeCustomIndex(</span>
        <span class="s1">nrows</span><span class="s0">,</span>
        <span class="s1">nlevels=r_idx_nlevels</span><span class="s0">,</span>
        <span class="s1">prefix=</span><span class="s4">&quot;R&quot;</span><span class="s0">,</span>
        <span class="s1">names=r_idx_names</span><span class="s0">,</span>
        <span class="s1">ndupe_l=r_ndupe_l</span><span class="s0">,</span>
        <span class="s1">idx_type=r_idx_type</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s2"># by default, generate data based on location</span>
    <span class="s0">if </span><span class="s1">data_gen_f </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">data_gen_f = </span><span class="s0">lambda </span><span class="s1">r</span><span class="s0">, </span><span class="s1">c: </span><span class="s4">f&quot;R</span><span class="s0">{</span><span class="s1">r</span><span class="s0">}</span><span class="s4">C</span><span class="s0">{</span><span class="s1">c</span><span class="s0">}</span><span class="s4">&quot;</span>

    <span class="s1">data = [[data_gen_f(r</span><span class="s0">, </span><span class="s1">c) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">range(ncols)] </span><span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">range(nrows)]</span>

    <span class="s0">return </span><span class="s1">DataFrame(data</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">columns</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>


<span class="s0">def </span><span class="s1">_create_missing_idx(nrows</span><span class="s0">, </span><span class="s1">ncols</span><span class="s0">, </span><span class="s1">density</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">if </span><span class="s1">random_state </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">random_state = np.random</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">random_state = np.random.RandomState(random_state)</span>

    <span class="s2"># below is cribbed from scipy.sparse</span>
    <span class="s1">size = int(np.round((</span><span class="s3">1 </span><span class="s1">- density) * nrows * ncols))</span>
    <span class="s2"># generate a few more to ensure unique values</span>
    <span class="s1">min_rows = </span><span class="s3">5</span>
    <span class="s1">fac = </span><span class="s3">1.02</span>
    <span class="s1">extra_size = min(size + min_rows</span><span class="s0">, </span><span class="s1">fac * size)</span>

    <span class="s0">def </span><span class="s1">_gen_unique_rand(rng</span><span class="s0">, </span><span class="s1">_extra_size):</span>
        <span class="s1">ind = rng.rand(int(_extra_size))</span>
        <span class="s0">return </span><span class="s1">np.unique(np.floor(ind * nrows * ncols))[:size]</span>

    <span class="s1">ind = _gen_unique_rand(random_state</span><span class="s0">, </span><span class="s1">extra_size)</span>
    <span class="s0">while </span><span class="s1">ind.size &lt; size:</span>
        <span class="s1">extra_size *= </span><span class="s3">1.05</span>
        <span class="s1">ind = _gen_unique_rand(random_state</span><span class="s0">, </span><span class="s1">extra_size)</span>

    <span class="s1">j = np.floor(ind * </span><span class="s3">1.0 </span><span class="s1">/ nrows).astype(int)</span>
    <span class="s1">i = (ind - j * nrows).astype(int)</span>
    <span class="s0">return </span><span class="s1">i.tolist()</span><span class="s0">, </span><span class="s1">j.tolist()</span>


<span class="s0">def </span><span class="s1">makeMissingDataframe(density=</span><span class="s3">0.9</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s1">df = makeDataFrame()</span>
    <span class="s2"># pandas\_testing.py:2306: error: &quot;_create_missing_idx&quot; gets multiple</span>
    <span class="s2"># values for keyword argument &quot;density&quot;  [misc]</span>

    <span class="s2"># pandas\_testing.py:2306: error: &quot;_create_missing_idx&quot; gets multiple</span>
    <span class="s2"># values for keyword argument &quot;random_state&quot;  [misc]</span>
    <span class="s1">i</span><span class="s0">, </span><span class="s1">j = _create_missing_idx(  </span><span class="s2"># type: ignore[misc]</span>
        <span class="s1">*df.shape</span><span class="s0">, </span><span class="s1">density=density</span><span class="s0">, </span><span class="s1">random_state=random_state</span>
    <span class="s1">)</span>
    <span class="s1">df.values[i</span><span class="s0">, </span><span class="s1">j] = np.nan</span>
    <span class="s0">return </span><span class="s1">df</span>


<span class="s0">def </span><span class="s1">optional_args(decorator):</span>
    <span class="s5">&quot;&quot;&quot; 
    allows a decorator to take optional positional and keyword arguments. 
    Assumes that taking a single, callable, positional argument means that 
    it is decorating a function, i.e. something like this:: 
 
        @my_decorator 
        def function(): pass 
 
    Calls decorator with decorator(f, *args, **kwargs) 
    &quot;&quot;&quot;</span>

    <span class="s1">@wraps(decorator)</span>
    <span class="s0">def </span><span class="s1">wrapper(*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">def </span><span class="s1">dec(f):</span>
            <span class="s0">return </span><span class="s1">decorator(f</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s1">is_decorating = </span><span class="s0">not </span><span class="s1">kwargs </span><span class="s0">and </span><span class="s1">len(args) == </span><span class="s3">1 </span><span class="s0">and </span><span class="s1">callable(args[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s0">if </span><span class="s1">is_decorating:</span>
            <span class="s1">f = args[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s2"># pandas\_testing.py:2331: error: Incompatible types in assignment</span>
            <span class="s2"># (expression has type &quot;List[&lt;nothing&gt;]&quot;, variable has type</span>
            <span class="s2"># &quot;Tuple[Any, ...]&quot;)</span>
            <span class="s1">args = []  </span><span class="s2"># type: ignore[assignment]</span>
            <span class="s0">return </span><span class="s1">dec(f)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">dec</span>

    <span class="s0">return </span><span class="s1">wrapper</span>


<span class="s2"># skip tests on exceptions with this message</span>
<span class="s1">_network_error_messages = (</span>
    <span class="s2"># 'urlopen error timed out',</span>
    <span class="s2"># 'timeout: timed out',</span>
    <span class="s2"># 'socket.timeout: timed out',</span>
    <span class="s4">&quot;timed out&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Server Hangup&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;HTTP Error 503: Service Unavailable&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;502: Proxy Error&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;HTTP Error 502: internal error&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;HTTP Error 502&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;HTTP Error 503&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;HTTP Error 403&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;HTTP Error 400&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Temporary failure in name resolution&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Name or service not known&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Connection refused&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;certificate verify&quot;</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s2"># or this e.errno/e.reason.errno</span>
<span class="s1">_network_errno_vals = (</span>
    <span class="s3">101</span><span class="s0">,  </span><span class="s2"># Network is unreachable</span>
    <span class="s3">111</span><span class="s0">,  </span><span class="s2"># Connection refused</span>
    <span class="s3">110</span><span class="s0">,  </span><span class="s2"># Connection timed out</span>
    <span class="s3">104</span><span class="s0">,  </span><span class="s2"># Connection reset Error</span>
    <span class="s3">54</span><span class="s0">,  </span><span class="s2"># Connection reset by peer</span>
    <span class="s3">60</span><span class="s0">,  </span><span class="s2"># urllib.error.URLError: [Errno 60] Connection timed out</span>
<span class="s1">)</span>

<span class="s2"># Both of the above shouldn't mask real issues such as 404's</span>
<span class="s2"># or refused connections (changed DNS).</span>
<span class="s2"># But some tests (test_data yahoo) contact incredibly flakey</span>
<span class="s2"># servers.</span>

<span class="s2"># and conditionally raise on exception types in _get_default_network_errors</span>


<span class="s0">def </span><span class="s1">_get_default_network_errors():</span>
    <span class="s2"># Lazy import for http.client because it imports many things from the stdlib</span>
    <span class="s0">import </span><span class="s1">http.client</span>

    <span class="s0">return </span><span class="s1">(IOError</span><span class="s0">, </span><span class="s1">http.client.HTTPException</span><span class="s0">, </span><span class="s1">TimeoutError)</span>


<span class="s0">def </span><span class="s1">can_connect(url</span><span class="s0">, </span><span class="s1">error_classes=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Try to connect to the given url. True if succeeds, False if IOError 
    raised 
 
    Parameters 
    ---------- 
    url : basestring 
        The URL to try to connect to 
 
    Returns 
    ------- 
    connectable : bool 
        Return True if no IOError (unable to connect) or URLError (bad url) was 
        raised 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">error_classes </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">error_classes = _get_default_network_errors()</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">with </span><span class="s1">urlopen(url):</span>
            <span class="s0">pass</span>
    <span class="s0">except </span><span class="s1">error_classes:</span>
        <span class="s0">return False</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return True</span>


<span class="s1">@optional_args</span>
<span class="s0">def </span><span class="s1">network(</span>
    <span class="s1">t</span><span class="s0">,</span>
    <span class="s1">url=</span><span class="s4">&quot;https://www.google.com&quot;</span><span class="s0">,</span>
    <span class="s1">raise_on_error=_RAISE_NETWORK_ERROR_DEFAULT</span><span class="s0">,</span>
    <span class="s1">check_before_test=</span><span class="s0">False,</span>
    <span class="s1">error_classes=</span><span class="s0">None,</span>
    <span class="s1">skip_errnos=_network_errno_vals</span><span class="s0">,</span>
    <span class="s1">_skip_on_messages=_network_error_messages</span><span class="s0">,</span>
<span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Label a test as requiring network connection and, if an error is 
    encountered, only raise if it does not find a network connection. 
 
    In comparison to ``network``, this assumes an added contract to your test: 
    you must assert that, under normal conditions, your test will ONLY fail if 
    it does not have network connectivity. 
 
    You can call this in 3 ways: as a standard decorator, with keyword 
    arguments, or with a positional argument that is the url to check. 
 
    Parameters 
    ---------- 
    t : callable 
        The test requiring network connectivity. 
    url : path 
        The url to test via ``pandas.io.common.urlopen`` to check 
        for connectivity. Defaults to 'https://www.google.com'. 
    raise_on_error : bool 
        If True, never catches errors. 
    check_before_test : bool 
        If True, checks connectivity before running the test case. 
    error_classes : tuple or Exception 
        error classes to ignore. If not in ``error_classes``, raises the error. 
        defaults to IOError. Be careful about changing the error classes here. 
    skip_errnos : iterable of int 
        Any exception that has .errno or .reason.erno set to one 
        of these values will be skipped with an appropriate 
        message. 
    _skip_on_messages: iterable of string 
        any exception e for which one of the strings is 
        a substring of str(e) will be skipped with an appropriate 
        message. Intended to suppress errors where an errno isn't available. 
 
    Notes 
    ----- 
    * ``raise_on_error`` supersedes ``check_before_test`` 
 
    Returns 
    ------- 
    t : callable 
        The decorated test ``t``, with checks for connectivity errors. 
 
    Example 
    ------- 
 
    Tests decorated with @network will fail if it's possible to make a network 
    connection to another URL (defaults to google.com):: 
 
      &gt;&gt;&gt; from pandas._testing import network 
      &gt;&gt;&gt; from pandas.io.common import urlopen 
      &gt;&gt;&gt; @network 
      ... def test_network(): 
      ...     with urlopen(&quot;rabbit://bonanza.com&quot;): 
      ...         pass 
      Traceback 
         ... 
      URLError: &lt;urlopen error unknown url type: rabit&gt; 
 
      You can specify alternative URLs:: 
 
        &gt;&gt;&gt; @network(&quot;https://www.yahoo.com&quot;) 
        ... def test_something_with_yahoo(): 
        ...    raise IOError(&quot;Failure Message&quot;) 
        &gt;&gt;&gt; test_something_with_yahoo() 
        Traceback (most recent call last): 
            ... 
        IOError: Failure Message 
 
    If you set check_before_test, it will check the url first and not run the 
    test on failure:: 
 
        &gt;&gt;&gt; @network(&quot;failing://url.blaher&quot;, check_before_test=True) 
        ... def test_something(): 
        ...     print(&quot;I ran!&quot;) 
        ...     raise ValueError(&quot;Failure&quot;) 
        &gt;&gt;&gt; test_something() 
        Traceback (most recent call last): 
            ... 
 
    Errors not related to networking will always be raised. 
    &quot;&quot;&quot;</span>
    <span class="s0">from </span><span class="s1">pytest </span><span class="s0">import </span><span class="s1">skip</span>

    <span class="s0">if </span><span class="s1">error_classes </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">error_classes = _get_default_network_errors()</span>

    <span class="s1">t.network = </span><span class="s0">True</span>

    <span class="s1">@wraps(t)</span>
    <span class="s0">def </span><span class="s1">wrapper(*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">check_before_test</span>
            <span class="s0">and not </span><span class="s1">raise_on_error</span>
            <span class="s0">and not </span><span class="s1">can_connect(url</span><span class="s0">, </span><span class="s1">error_classes)</span>
        <span class="s1">):</span>
            <span class="s1">skip()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">t(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">err:</span>
            <span class="s1">errno = getattr(err</span><span class="s0">, </span><span class="s4">&quot;errno&quot;</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s0">if not </span><span class="s1">errno </span><span class="s0">and </span><span class="s1">hasattr(errno</span><span class="s0">, </span><span class="s4">&quot;reason&quot;</span><span class="s1">):</span>
                <span class="s2"># pandas\_testing.py:2521: error: &quot;Exception&quot; has no attribute</span>
                <span class="s2"># &quot;reason&quot;</span>
                <span class="s1">errno = getattr(err.reason</span><span class="s0">, </span><span class="s4">&quot;errno&quot;</span><span class="s0">, None</span><span class="s1">)  </span><span class="s2"># type: ignore[attr-defined]</span>

            <span class="s0">if </span><span class="s1">errno </span><span class="s0">in </span><span class="s1">skip_errnos:</span>
                <span class="s1">skip(</span><span class="s4">f&quot;Skipping test due to known errno and error </span><span class="s0">{</span><span class="s1">err</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>

            <span class="s1">e_str = str(err)</span>

            <span class="s0">if </span><span class="s1">any(m.lower() </span><span class="s0">in </span><span class="s1">e_str.lower() </span><span class="s0">for </span><span class="s1">m </span><span class="s0">in </span><span class="s1">_skip_on_messages):</span>
                <span class="s1">skip(</span>
                    <span class="s4">f&quot;Skipping test because exception message is known and error </span><span class="s0">{</span><span class="s1">err</span><span class="s0">}</span><span class="s4">&quot;</span>
                <span class="s1">)</span>

            <span class="s0">if not </span><span class="s1">isinstance(err</span><span class="s0">, </span><span class="s1">error_classes):</span>
                <span class="s0">raise</span>

            <span class="s0">if </span><span class="s1">raise_on_error </span><span class="s0">or </span><span class="s1">can_connect(url</span><span class="s0">, </span><span class="s1">error_classes):</span>
                <span class="s0">raise</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">skip(</span><span class="s4">f&quot;Skipping test due to lack of connectivity and error </span><span class="s0">{</span><span class="s1">err</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">wrapper</span>


<span class="s1">with_connectivity_check = network</span>


<span class="s1">@contextmanager</span>
<span class="s0">def </span><span class="s1">assert_produces_warning(</span>
    <span class="s1">expected_warning: Optional[Union[Type[Warning]</span><span class="s0">, </span><span class="s1">bool]] = Warning</span><span class="s0">,</span>
    <span class="s1">filter_level=</span><span class="s4">&quot;always&quot;</span><span class="s0">,</span>
    <span class="s1">check_stacklevel: bool = </span><span class="s0">True,</span>
    <span class="s1">raise_on_extra_warnings: bool = </span><span class="s0">True,</span>
    <span class="s1">match: Optional[str] = </span><span class="s0">None,</span>
<span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Context manager for running code expected to either raise a specific 
    warning, or not raise any warnings. Verifies that the code raises the 
    expected warning, and that it does not raise any other unexpected 
    warnings. It is basically a wrapper around ``warnings.catch_warnings``. 
 
    Parameters 
    ---------- 
    expected_warning : {Warning, False, None}, default Warning 
        The type of Exception raised. ``exception.Warning`` is the base 
        class for all warnings. To check that no warning is returned, 
        specify ``False`` or ``None``. 
    filter_level : str or None, default &quot;always&quot; 
        Specifies whether warnings are ignored, displayed, or turned 
        into errors. 
        Valid values are: 
 
        * &quot;error&quot; - turns matching warnings into exceptions 
        * &quot;ignore&quot; - discard the warning 
        * &quot;always&quot; - always emit a warning 
        * &quot;default&quot; - print the warning the first time it is generated 
          from each location 
        * &quot;module&quot; - print the warning the first time it is generated 
          from each module 
        * &quot;once&quot; - print the warning the first time it is generated 
 
    check_stacklevel : bool, default True 
        If True, displays the line that called the function containing 
        the warning to show were the function is called. Otherwise, the 
        line that implements the function is displayed. 
    raise_on_extra_warnings : bool, default True 
        Whether extra warnings not of the type `expected_warning` should 
        cause the test to fail. 
    match : str, optional 
        Match warning message. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import warnings 
    &gt;&gt;&gt; with assert_produces_warning(): 
    ...     warnings.warn(UserWarning()) 
    ... 
    &gt;&gt;&gt; with assert_produces_warning(False): 
    ...     warnings.warn(RuntimeWarning()) 
    ... 
    Traceback (most recent call last): 
        ... 
    AssertionError: Caused unexpected warning(s): ['RuntimeWarning']. 
    &gt;&gt;&gt; with assert_produces_warning(UserWarning): 
    ...     warnings.warn(RuntimeWarning()) 
    Traceback (most recent call last): 
        ... 
    AssertionError: Did not see expected warning of class 'UserWarning'. 
 
    ..warn:: This is *not* thread-safe. 
    &quot;&quot;&quot;</span>
    <span class="s1">__tracebackhide__ = </span><span class="s0">True</span>

    <span class="s0">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">as </span><span class="s1">w:</span>

        <span class="s1">saw_warning = </span><span class="s0">False</span>
        <span class="s1">matched_message = </span><span class="s0">False</span>

        <span class="s1">warnings.simplefilter(filter_level)</span>
        <span class="s0">yield </span><span class="s1">w</span>
        <span class="s1">extra_warnings = []</span>

        <span class="s0">for </span><span class="s1">actual_warning </span><span class="s0">in </span><span class="s1">w:</span>
            <span class="s0">if not </span><span class="s1">expected_warning:</span>
                <span class="s0">continue</span>

            <span class="s1">expected_warning = cast(Type[Warning]</span><span class="s0">, </span><span class="s1">expected_warning)</span>
            <span class="s0">if </span><span class="s1">issubclass(actual_warning.category</span><span class="s0">, </span><span class="s1">expected_warning):</span>
                <span class="s1">saw_warning = </span><span class="s0">True</span>

                <span class="s0">if </span><span class="s1">check_stacklevel </span><span class="s0">and </span><span class="s1">issubclass(</span>
                    <span class="s1">actual_warning.category</span><span class="s0">, </span><span class="s1">(FutureWarning</span><span class="s0">, </span><span class="s1">DeprecationWarning)</span>
                <span class="s1">):</span>
                    <span class="s1">_assert_raised_with_correct_stacklevel(actual_warning)</span>

                <span class="s0">if </span><span class="s1">match </span><span class="s0">is not None and </span><span class="s1">re.search(match</span><span class="s0">, </span><span class="s1">str(actual_warning.message)):</span>
                    <span class="s1">matched_message = </span><span class="s0">True</span>

            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">extra_warnings.append(</span>
                    <span class="s1">(</span>
                        <span class="s1">actual_warning.category.__name__</span><span class="s0">,</span>
                        <span class="s1">actual_warning.message</span><span class="s0">,</span>
                        <span class="s1">actual_warning.filename</span><span class="s0">,</span>
                        <span class="s1">actual_warning.lineno</span><span class="s0">,</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">expected_warning:</span>
            <span class="s1">expected_warning = cast(Type[Warning]</span><span class="s0">, </span><span class="s1">expected_warning)</span>
            <span class="s0">if not </span><span class="s1">saw_warning:</span>
                <span class="s0">raise </span><span class="s1">AssertionError(</span>
                    <span class="s4">f&quot;Did not see expected warning of class &quot;</span>
                    <span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">repr(expected_warning.__name__)</span><span class="s0">}</span><span class="s4">&quot;</span>
                <span class="s1">)</span>

            <span class="s0">if </span><span class="s1">match </span><span class="s0">and not </span><span class="s1">matched_message:</span>
                <span class="s0">raise </span><span class="s1">AssertionError(</span>
                    <span class="s4">f&quot;Did not see warning </span><span class="s0">{</span><span class="s1">repr(expected_warning.__name__)</span><span class="s0">} </span><span class="s4">&quot;</span>
                    <span class="s4">f&quot;matching </span><span class="s0">{</span><span class="s1">match</span><span class="s0">}</span><span class="s4">&quot;</span>
                <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">raise_on_extra_warnings </span><span class="s0">and </span><span class="s1">extra_warnings:</span>
            <span class="s0">raise </span><span class="s1">AssertionError(</span>
                <span class="s4">f&quot;Caused unexpected warning(s): </span><span class="s0">{</span><span class="s1">repr(extra_warnings)</span><span class="s0">}</span><span class="s4">&quot;</span>
            <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_assert_raised_with_correct_stacklevel(</span>
    <span class="s1">actual_warning: warnings.WarningMessage</span><span class="s0">,</span>
<span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
    <span class="s0">from </span><span class="s1">inspect </span><span class="s0">import </span><span class="s1">getframeinfo</span><span class="s0">, </span><span class="s1">stack</span>

    <span class="s1">caller = getframeinfo(stack()[</span><span class="s3">3</span><span class="s1">][</span><span class="s3">0</span><span class="s1">])</span>
    <span class="s1">msg = (</span>
        <span class="s4">&quot;Warning not set with correct stacklevel. &quot;</span>
        <span class="s4">f&quot;File where warning is raised: </span><span class="s0">{</span><span class="s1">actual_warning.filename</span><span class="s0">} </span><span class="s4">!= &quot;</span>
        <span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">caller.filename</span><span class="s0">}</span><span class="s4">. Warning message: </span><span class="s0">{</span><span class="s1">actual_warning.message</span><span class="s0">}</span><span class="s4">&quot;</span>
    <span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">actual_warning.filename == caller.filename</span><span class="s0">, </span><span class="s1">msg</span>


<span class="s0">class </span><span class="s1">RNGContext:</span>
    <span class="s5">&quot;&quot;&quot; 
    Context manager to set the numpy random number generator speed. Returns 
    to the original value upon exiting the context manager. 
 
    Parameters 
    ---------- 
    seed : int 
        Seed for numpy.random.seed 
 
    Examples 
    -------- 
    with RNGContext(42): 
        np.random.randn() 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">seed):</span>
        <span class="s1">self.seed = seed</span>

    <span class="s0">def </span><span class="s1">__enter__(self):</span>

        <span class="s1">self.start_state = np.random.get_state()</span>
        <span class="s1">np.random.seed(self.seed)</span>

    <span class="s0">def </span><span class="s1">__exit__(self</span><span class="s0">, </span><span class="s1">exc_type</span><span class="s0">, </span><span class="s1">exc_value</span><span class="s0">, </span><span class="s1">traceback):</span>

        <span class="s1">np.random.set_state(self.start_state)</span>


<span class="s1">@contextmanager</span>
<span class="s0">def </span><span class="s1">with_csv_dialect(name</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s5">&quot;&quot;&quot; 
    Context manager to temporarily register a CSV dialect for parsing CSV. 
 
    Parameters 
    ---------- 
    name : str 
        The name of the dialect. 
    kwargs : mapping 
        The parameters for the dialect. 
 
    Raises 
    ------ 
    ValueError : the name of the dialect conflicts with a builtin one. 
 
    See Also 
    -------- 
    csv : Python's CSV library. 
    &quot;&quot;&quot;</span>
    <span class="s0">import </span><span class="s1">csv</span>

    <span class="s1">_BUILTIN_DIALECTS = {</span><span class="s4">&quot;excel&quot;</span><span class="s0">, </span><span class="s4">&quot;excel-tab&quot;</span><span class="s0">, </span><span class="s4">&quot;unix&quot;</span><span class="s1">}</span>

    <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">_BUILTIN_DIALECTS:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Cannot override builtin dialect.&quot;</span><span class="s1">)</span>

    <span class="s1">csv.register_dialect(name</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">yield</span>
    <span class="s1">csv.unregister_dialect(name)</span>


<span class="s1">@contextmanager</span>
<span class="s0">def </span><span class="s1">use_numexpr(use</span><span class="s0">, </span><span class="s1">min_elements=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">from </span><span class="s1">pandas.core.computation </span><span class="s0">import </span><span class="s1">expressions </span><span class="s0">as </span><span class="s1">expr</span>

    <span class="s0">if </span><span class="s1">min_elements </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">min_elements = expr._MIN_ELEMENTS</span>

    <span class="s1">olduse = expr.USE_NUMEXPR</span>
    <span class="s1">oldmin = expr._MIN_ELEMENTS</span>
    <span class="s1">expr.set_use_numexpr(use)</span>
    <span class="s1">expr._MIN_ELEMENTS = min_elements</span>
    <span class="s0">yield</span>
    <span class="s1">expr._MIN_ELEMENTS = oldmin</span>
    <span class="s1">expr.set_use_numexpr(olduse)</span>


<span class="s0">def </span><span class="s1">test_parallel(num_threads=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">kwargs_list=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Decorator to run the same function multiple times in parallel. 
 
    Parameters 
    ---------- 
    num_threads : int, optional 
        The number of times the function is run in parallel. 
    kwargs_list : list of dicts, optional 
        The list of kwargs to update original 
        function kwargs on different threads. 
 
    Notes 
    ----- 
    This decorator does not pass the return value of the decorated function. 
 
    Original from scikit-image: 
 
    https://github.com/scikit-image/scikit-image/pull/1519 
 
    &quot;&quot;&quot;</span>
    <span class="s0">assert </span><span class="s1">num_threads &gt; </span><span class="s3">0</span>
    <span class="s1">has_kwargs_list = kwargs_list </span><span class="s0">is not None</span>
    <span class="s0">if </span><span class="s1">has_kwargs_list:</span>
        <span class="s0">assert </span><span class="s1">len(kwargs_list) == num_threads</span>
    <span class="s0">import </span><span class="s1">threading</span>

    <span class="s0">def </span><span class="s1">wrapper(func):</span>
        <span class="s1">@wraps(func)</span>
        <span class="s0">def </span><span class="s1">inner(*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s0">if </span><span class="s1">has_kwargs_list:</span>
                <span class="s1">update_kwargs = </span><span class="s0">lambda </span><span class="s1">i: dict(kwargs</span><span class="s0">, </span><span class="s1">**kwargs_list[i])</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">update_kwargs = </span><span class="s0">lambda </span><span class="s1">i: kwargs</span>
            <span class="s1">threads = []</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(num_threads):</span>
                <span class="s1">updated_kwargs = update_kwargs(i)</span>
                <span class="s1">thread = threading.Thread(target=func</span><span class="s0">, </span><span class="s1">args=args</span><span class="s0">, </span><span class="s1">kwargs=updated_kwargs)</span>
                <span class="s1">threads.append(thread)</span>
            <span class="s0">for </span><span class="s1">thread </span><span class="s0">in </span><span class="s1">threads:</span>
                <span class="s1">thread.start()</span>
            <span class="s0">for </span><span class="s1">thread </span><span class="s0">in </span><span class="s1">threads:</span>
                <span class="s1">thread.join()</span>

        <span class="s0">return </span><span class="s1">inner</span>

    <span class="s0">return </span><span class="s1">wrapper</span>


<span class="s0">class </span><span class="s1">SubclassedSeries(Series):</span>
    <span class="s1">_metadata = [</span><span class="s4">&quot;testattr&quot;</span><span class="s0">, </span><span class="s4">&quot;name&quot;</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_constructor(self):</span>
        <span class="s0">return </span><span class="s1">SubclassedSeries</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_constructor_expanddim(self):</span>
        <span class="s0">return </span><span class="s1">SubclassedDataFrame</span>


<span class="s0">class </span><span class="s1">SubclassedDataFrame(DataFrame):</span>
    <span class="s1">_metadata = [</span><span class="s4">&quot;testattr&quot;</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_constructor(self):</span>
        <span class="s0">return </span><span class="s1">SubclassedDataFrame</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_constructor_sliced(self):</span>
        <span class="s0">return </span><span class="s1">SubclassedSeries</span>


<span class="s0">class </span><span class="s1">SubclassedCategorical(Categorical):</span>
    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_constructor(self):</span>
        <span class="s0">return </span><span class="s1">SubclassedCategorical</span>


<span class="s1">@contextmanager</span>
<span class="s0">def </span><span class="s1">set_timezone(tz: str):</span>
    <span class="s5">&quot;&quot;&quot; 
    Context manager for temporarily setting a timezone. 
 
    Parameters 
    ---------- 
    tz : str 
        A string representing a valid timezone. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from datetime import datetime 
    &gt;&gt;&gt; from dateutil.tz import tzlocal 
    &gt;&gt;&gt; tzlocal().tzname(datetime.now()) 
    'IST' 
 
    &gt;&gt;&gt; with set_timezone('US/Eastern'): 
    ...     tzlocal().tzname(datetime.now()) 
    ... 
    'EDT' 
    &quot;&quot;&quot;</span>
    <span class="s0">import </span><span class="s1">os</span>
    <span class="s0">import </span><span class="s1">time</span>

    <span class="s0">def </span><span class="s1">setTZ(tz):</span>
        <span class="s0">if </span><span class="s1">tz </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">del </span><span class="s1">os.environ[</span><span class="s4">&quot;TZ&quot;</span><span class="s1">]</span>
            <span class="s0">except </span><span class="s1">KeyError:</span>
                <span class="s0">pass</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">os.environ[</span><span class="s4">&quot;TZ&quot;</span><span class="s1">] = tz</span>
            <span class="s1">time.tzset()</span>

    <span class="s1">orig_tz = os.environ.get(</span><span class="s4">&quot;TZ&quot;</span><span class="s1">)</span>
    <span class="s1">setTZ(tz)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">yield</span>
    <span class="s0">finally</span><span class="s1">:</span>
        <span class="s1">setTZ(orig_tz)</span>


<span class="s0">def </span><span class="s1">_make_skipna_wrapper(alternative</span><span class="s0">, </span><span class="s1">skipna_alternative=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Create a function for calling on an array. 
 
    Parameters 
    ---------- 
    alternative : function 
        The function to be called on the array with no NaNs. 
        Only used when 'skipna_alternative' is None. 
    skipna_alternative : function 
        The function to be called on the original array 
 
    Returns 
    ------- 
    function 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">skipna_alternative:</span>

        <span class="s0">def </span><span class="s1">skipna_wrapper(x):</span>
            <span class="s0">return </span><span class="s1">skipna_alternative(x.values)</span>

    <span class="s0">else</span><span class="s1">:</span>

        <span class="s0">def </span><span class="s1">skipna_wrapper(x):</span>
            <span class="s1">nona = x.dropna()</span>
            <span class="s0">if </span><span class="s1">len(nona) == </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">np.nan</span>
            <span class="s0">return </span><span class="s1">alternative(nona)</span>

    <span class="s0">return </span><span class="s1">skipna_wrapper</span>


<span class="s0">def </span><span class="s1">convert_rows_list_to_csv_str(rows_list: List[str]):</span>
    <span class="s5">&quot;&quot;&quot; 
    Convert list of CSV rows to single CSV-formatted string for current OS. 
 
    This method is used for creating expected value of to_csv() method. 
 
    Parameters 
    ---------- 
    rows_list : List[str] 
        Each element represents the row of csv. 
 
    Returns 
    ------- 
    str 
        Expected output of to_csv() in current OS. 
    &quot;&quot;&quot;</span>
    <span class="s1">sep = os.linesep</span>
    <span class="s0">return </span><span class="s1">sep.join(rows_list) + sep</span>


<span class="s0">def </span><span class="s1">external_error_raised(expected_exception: Type[Exception]) -&gt; ContextManager:</span>
    <span class="s5">&quot;&quot;&quot; 
    Helper function to mark pytest.raises that have an external error message. 
 
    Parameters 
    ---------- 
    expected_exception : Exception 
        Expected error to raise. 
 
    Returns 
    ------- 
    Callable 
        Regular `pytest.raises` function with `match` equal to `None`. 
    &quot;&quot;&quot;</span>
    <span class="s0">import </span><span class="s1">pytest</span>

    <span class="s0">return </span><span class="s1">pytest.raises(expected_exception</span><span class="s0">, </span><span class="s1">match=</span><span class="s0">None</span><span class="s1">)</span>


<span class="s1">cython_table = pd.core.base.SelectionMixin._cython_table.items()</span>


<span class="s0">def </span><span class="s1">get_cython_table_params(ndframe</span><span class="s0">, </span><span class="s1">func_names_and_expected):</span>
    <span class="s5">&quot;&quot;&quot; 
    Combine frame, functions from SelectionMixin._cython_table 
    keys and expected result. 
 
    Parameters 
    ---------- 
    ndframe : DataFrame or Series 
    func_names_and_expected : Sequence of two items 
        The first item is a name of a NDFrame method ('sum', 'prod') etc. 
        The second item is the expected return value. 
 
    Returns 
    ------- 
    list 
        List of three items (DataFrame, function, expected result) 
    &quot;&quot;&quot;</span>
    <span class="s1">results = []</span>
    <span class="s0">for </span><span class="s1">func_name</span><span class="s0">, </span><span class="s1">expected </span><span class="s0">in </span><span class="s1">func_names_and_expected:</span>
        <span class="s1">results.append((ndframe</span><span class="s0">, </span><span class="s1">func_name</span><span class="s0">, </span><span class="s1">expected))</span>
        <span class="s1">results += [</span>
            <span class="s1">(ndframe</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">expected)</span>
            <span class="s0">for </span><span class="s1">func</span><span class="s0">, </span><span class="s1">name </span><span class="s0">in </span><span class="s1">cython_table</span>
            <span class="s0">if </span><span class="s1">name == func_name</span>
        <span class="s1">]</span>
    <span class="s0">return </span><span class="s1">results</span>


<span class="s0">def </span><span class="s1">get_op_from_name(op_name: str) -&gt; Callable:</span>
    <span class="s5">&quot;&quot;&quot; 
    The operator function for a given op name. 
 
    Parameters 
    ---------- 
    op_name : string 
        The op name, in form of &quot;add&quot; or &quot;__add__&quot;. 
 
    Returns 
    ------- 
    function 
        A function performing the operation. 
    &quot;&quot;&quot;</span>
    <span class="s1">short_opname = op_name.strip(</span><span class="s4">&quot;_&quot;</span><span class="s1">)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">op = getattr(operator</span><span class="s0">, </span><span class="s1">short_opname)</span>
    <span class="s0">except </span><span class="s1">AttributeError:</span>
        <span class="s2"># Assume it is the reverse operator</span>
        <span class="s1">rop = getattr(operator</span><span class="s0">, </span><span class="s1">short_opname[</span><span class="s3">1</span><span class="s1">:])</span>
        <span class="s1">op = </span><span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y: rop(y</span><span class="s0">, </span><span class="s1">x)</span>

    <span class="s0">return </span><span class="s1">op</span>
</pre>
</body>
</html>