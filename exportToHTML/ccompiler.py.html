<html>
<head>
<title>ccompiler.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ccompiler.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">shlex</span>
<span class="s0">import </span><span class="s1">time</span>
<span class="s0">import </span><span class="s1">subprocess</span>
<span class="s0">from </span><span class="s1">copy </span><span class="s0">import </span><span class="s1">copy</span>
<span class="s0">from </span><span class="s1">distutils </span><span class="s0">import </span><span class="s1">ccompiler</span>
<span class="s0">from </span><span class="s1">distutils.ccompiler </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">compiler_class</span><span class="s0">, </span><span class="s1">gen_lib_options</span><span class="s0">, </span><span class="s1">get_default_compiler</span><span class="s0">, </span><span class="s1">new_compiler</span><span class="s0">,</span>
    <span class="s1">CCompiler</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">distutils.errors </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DistutilsExecError</span><span class="s0">, </span><span class="s1">DistutilsModuleError</span><span class="s0">, </span><span class="s1">DistutilsPlatformError</span><span class="s0">,</span>
    <span class="s1">CompileError</span><span class="s0">, </span><span class="s1">UnknownFileError</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">distutils.sysconfig </span><span class="s0">import </span><span class="s1">customize_compiler</span>
<span class="s0">from </span><span class="s1">distutils.version </span><span class="s0">import </span><span class="s1">LooseVersion</span>

<span class="s0">from </span><span class="s1">numpy.distutils </span><span class="s0">import </span><span class="s1">log</span>
<span class="s0">from </span><span class="s1">numpy.distutils.exec_command </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">filepath_from_subprocess_output</span><span class="s0">, </span><span class="s1">forward_bytes_to_stdout</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">numpy.distutils.misc_util </span><span class="s0">import </span><span class="s1">cyg2win32</span><span class="s0">, </span><span class="s1">is_sequence</span><span class="s0">, </span><span class="s1">mingw32</span><span class="s0">, </span><span class="s1">\</span>
                                      <span class="s1">get_num_build_jobs</span><span class="s0">, </span><span class="s1">\</span>
                                      <span class="s1">_commandline_dep_string</span>

<span class="s2"># globals for parallel build management</span>
<span class="s0">try</span><span class="s1">:</span>
    <span class="s0">import </span><span class="s1">threading</span>
<span class="s0">except </span><span class="s1">ImportError:</span>
    <span class="s0">import </span><span class="s1">dummy_threading </span><span class="s0">as </span><span class="s1">threading</span>
<span class="s1">_job_semaphore = </span><span class="s0">None</span>
<span class="s1">_global_lock = threading.Lock()</span>
<span class="s1">_processing_files = set()</span>


<span class="s0">def </span><span class="s1">_needs_build(obj</span><span class="s0">, </span><span class="s1">cc_args</span><span class="s0">, </span><span class="s1">extra_postargs</span><span class="s0">, </span><span class="s1">pp_opts):</span>
    <span class="s3">&quot;&quot;&quot; 
    Check if an objects needs to be rebuild based on its dependencies 
 
    Parameters 
    ---------- 
    obj : str 
        object file 
 
    Returns 
    ------- 
    bool 
    &quot;&quot;&quot;</span>
    <span class="s2"># defined in unixcompiler.py</span>
    <span class="s1">dep_file = obj + </span><span class="s4">'.d'</span>
    <span class="s0">if not </span><span class="s1">os.path.exists(dep_file):</span>
        <span class="s0">return True</span>

    <span class="s2"># dep_file is a makefile containing 'object: dependencies'</span>
    <span class="s2"># formatted like posix shell (spaces escaped, \ line continuations)</span>
    <span class="s2"># the last line contains the compiler commandline arguments as some</span>
    <span class="s2"># projects may compile an extension multiple times with different</span>
    <span class="s2"># arguments</span>
    <span class="s0">with </span><span class="s1">open(dep_file</span><span class="s0">, </span><span class="s4">&quot;r&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f:</span>
        <span class="s1">lines = f.readlines()</span>

    <span class="s1">cmdline =_commandline_dep_string(cc_args</span><span class="s0">, </span><span class="s1">extra_postargs</span><span class="s0">, </span><span class="s1">pp_opts)</span>
    <span class="s1">last_cmdline = lines[-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s0">if </span><span class="s1">last_cmdline != cmdline:</span>
        <span class="s0">return True</span>

    <span class="s1">contents = </span><span class="s4">''</span><span class="s1">.join(lines[:-</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">deps = [x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">shlex.split(contents</span><span class="s0">, </span><span class="s1">posix=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">x != </span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot; </span><span class="s0">and not </span><span class="s1">x.endswith(</span><span class="s4">&quot;:&quot;</span><span class="s1">)]</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">t_obj = os.stat(obj).st_mtime</span>

        <span class="s2"># check if any of the dependencies is newer than the object</span>
        <span class="s2"># the dependencies includes the source used to create the object</span>
        <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">deps:</span>
            <span class="s0">if </span><span class="s1">os.stat(f).st_mtime &gt; t_obj:</span>
                <span class="s0">return True</span>
    <span class="s0">except </span><span class="s1">OSError:</span>
        <span class="s2"># no object counts as newer (shouldn't happen if dep_file exists)</span>
        <span class="s0">return True</span>

    <span class="s0">return False</span>


<span class="s0">def </span><span class="s1">replace_method(klass</span><span class="s0">, </span><span class="s1">method_name</span><span class="s0">, </span><span class="s1">func):</span>
    <span class="s2"># Py3k does not have unbound method anymore, MethodType does not work</span>
    <span class="s1">m = </span><span class="s0">lambda </span><span class="s1">self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kw: func(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kw)</span>
    <span class="s1">setattr(klass</span><span class="s0">, </span><span class="s1">method_name</span><span class="s0">, </span><span class="s1">m)</span>


<span class="s2">######################################################################</span>
<span class="s2">## Method that subclasses may redefine. But don't call this method,</span>
<span class="s2">## it i private to CCompiler class and may return unexpected</span>
<span class="s2">## results if used elsewhere. So, you have been warned..</span>

<span class="s0">def </span><span class="s1">CCompiler_find_executables(self):</span>
    <span class="s3">&quot;&quot;&quot; 
    Does nothing here, but is called by the get_version method and can be 
    overridden by subclasses. In particular it is redefined in the `FCompiler` 
    class where more documentation can be found. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">pass</span>


<span class="s1">replace_method(CCompiler</span><span class="s0">, </span><span class="s4">'find_executables'</span><span class="s0">, </span><span class="s1">CCompiler_find_executables)</span>


<span class="s2"># Using customized CCompiler.spawn.</span>
<span class="s0">def </span><span class="s1">CCompiler_spawn(self</span><span class="s0">, </span><span class="s1">cmd</span><span class="s0">, </span><span class="s1">display=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Execute a command in a sub-process. 
 
    Parameters 
    ---------- 
    cmd : str 
        The command to execute. 
    display : str or sequence of str, optional 
        The text to add to the log file kept by `numpy.distutils`. 
        If not given, `display` is equal to `cmd`. 
 
    Returns 
    ------- 
    None 
 
    Raises 
    ------ 
    DistutilsExecError 
        If the command failed, i.e. the exit status was not 0. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">display </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">display = cmd</span>
        <span class="s0">if </span><span class="s1">is_sequence(display):</span>
            <span class="s1">display = </span><span class="s4">' '</span><span class="s1">.join(list(display))</span>
    <span class="s1">log.info(display)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">self.verbose:</span>
            <span class="s1">subprocess.check_output(cmd)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">subprocess.check_output(cmd</span><span class="s0">, </span><span class="s1">stderr=subprocess.STDOUT)</span>
    <span class="s0">except </span><span class="s1">subprocess.CalledProcessError </span><span class="s0">as </span><span class="s1">exc:</span>
        <span class="s1">o = exc.output</span>
        <span class="s1">s = exc.returncode</span>
    <span class="s0">except </span><span class="s1">OSError:</span>
        <span class="s2"># OSError doesn't have the same hooks for the exception</span>
        <span class="s2"># output, but exec_command() historically would use an</span>
        <span class="s2"># empty string for EnvironmentError (base class for</span>
        <span class="s2"># OSError)</span>
        <span class="s1">o = </span><span class="s6">b''</span>
        <span class="s2"># status previously used by exec_command() for parent</span>
        <span class="s2"># of OSError</span>
        <span class="s1">s = </span><span class="s5">127</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s2"># use a convenience return here so that any kind of</span>
        <span class="s2"># caught exception will execute the default code after the</span>
        <span class="s2"># try / except block, which handles various exceptions</span>
        <span class="s0">return None</span>

    <span class="s0">if </span><span class="s1">is_sequence(cmd):</span>
        <span class="s1">cmd = </span><span class="s4">' '</span><span class="s1">.join(list(cmd))</span>

    <span class="s0">if </span><span class="s1">self.verbose:</span>
        <span class="s1">forward_bytes_to_stdout(o)</span>

    <span class="s0">if </span><span class="s1">re.search(</span><span class="s6">b'Too many open files'</span><span class="s0">, </span><span class="s1">o):</span>
        <span class="s1">msg = </span><span class="s4">'</span><span class="s0">\n</span><span class="s4">Try rerunning setup command until build succeeds.'</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">msg = </span><span class="s4">''</span>
    <span class="s0">raise </span><span class="s1">DistutilsExecError(</span><span class="s4">'Command &quot;%s&quot; failed with exit status %d%s' </span><span class="s1">%</span>
                            <span class="s1">(cmd</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">msg))</span>

<span class="s1">replace_method(CCompiler</span><span class="s0">, </span><span class="s4">'spawn'</span><span class="s0">, </span><span class="s1">CCompiler_spawn)</span>

<span class="s0">def </span><span class="s1">CCompiler_object_filenames(self</span><span class="s0">, </span><span class="s1">source_filenames</span><span class="s0">, </span><span class="s1">strip_dir=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">output_dir=</span><span class="s4">''</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Return the name of the object files for the given source files. 
 
    Parameters 
    ---------- 
    source_filenames : list of str 
        The list of paths to source files. Paths can be either relative or 
        absolute, this is handled transparently. 
    strip_dir : bool, optional 
        Whether to strip the directory from the returned paths. If True, 
        the file name prepended by `output_dir` is returned. Default is False. 
    output_dir : str, optional 
        If given, this path is prepended to the returned paths to the 
        object files. 
 
    Returns 
    ------- 
    obj_names : list of str 
        The list of paths to the object files corresponding to the source 
        files in `source_filenames`. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">output_dir </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">output_dir = </span><span class="s4">''</span>
    <span class="s1">obj_names = []</span>
    <span class="s0">for </span><span class="s1">src_name </span><span class="s0">in </span><span class="s1">source_filenames:</span>
        <span class="s1">base</span><span class="s0">, </span><span class="s1">ext = os.path.splitext(os.path.normpath(src_name))</span>
        <span class="s1">base = os.path.splitdrive(base)[</span><span class="s5">1</span><span class="s1">] </span><span class="s2"># Chop off the drive</span>
        <span class="s1">base = base[os.path.isabs(base):]  </span><span class="s2"># If abs, chop off leading /</span>
        <span class="s0">if </span><span class="s1">base.startswith(</span><span class="s4">'..'</span><span class="s1">):</span>
            <span class="s2"># Resolve starting relative path components, middle ones</span>
            <span class="s2"># (if any) have been handled by os.path.normpath above.</span>
            <span class="s1">i = base.rfind(</span><span class="s4">'..'</span><span class="s1">)+</span><span class="s5">2</span>
            <span class="s1">d = base[:i]</span>
            <span class="s1">d = os.path.basename(os.path.abspath(d))</span>
            <span class="s1">base = d + base[i:]</span>
        <span class="s0">if </span><span class="s1">ext </span><span class="s0">not in </span><span class="s1">self.src_extensions:</span>
            <span class="s0">raise </span><span class="s1">UnknownFileError(</span><span class="s4">&quot;unknown file type '%s' (from '%s')&quot; </span><span class="s1">% (ext</span><span class="s0">, </span><span class="s1">src_name))</span>
        <span class="s0">if </span><span class="s1">strip_dir:</span>
            <span class="s1">base = os.path.basename(base)</span>
        <span class="s1">obj_name = os.path.join(output_dir</span><span class="s0">, </span><span class="s1">base + self.obj_extension)</span>
        <span class="s1">obj_names.append(obj_name)</span>
    <span class="s0">return </span><span class="s1">obj_names</span>

<span class="s1">replace_method(CCompiler</span><span class="s0">, </span><span class="s4">'object_filenames'</span><span class="s0">, </span><span class="s1">CCompiler_object_filenames)</span>

<span class="s0">def </span><span class="s1">CCompiler_compile(self</span><span class="s0">, </span><span class="s1">sources</span><span class="s0">, </span><span class="s1">output_dir=</span><span class="s0">None, </span><span class="s1">macros=</span><span class="s0">None,</span>
                      <span class="s1">include_dirs=</span><span class="s0">None, </span><span class="s1">debug=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">extra_preargs=</span><span class="s0">None,</span>
                      <span class="s1">extra_postargs=</span><span class="s0">None, </span><span class="s1">depends=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Compile one or more source files. 
 
    Please refer to the Python distutils API reference for more details. 
 
    Parameters 
    ---------- 
    sources : list of str 
        A list of filenames 
    output_dir : str, optional 
        Path to the output directory. 
    macros : list of tuples 
        A list of macro definitions. 
    include_dirs : list of str, optional 
        The directories to add to the default include file search path for 
        this compilation only. 
    debug : bool, optional 
        Whether or not to output debug symbols in or alongside the object 
        file(s). 
    extra_preargs, extra_postargs : ? 
        Extra pre- and post-arguments. 
    depends : list of str, optional 
        A list of file names that all targets depend on. 
 
    Returns 
    ------- 
    objects : list of str 
        A list of object file names, one per source file `sources`. 
 
    Raises 
    ------ 
    CompileError 
        If compilation fails. 
 
    &quot;&quot;&quot;</span>
    <span class="s2"># This method is effective only with Python &gt;=2.3 distutils.</span>
    <span class="s2"># Any changes here should be applied also to fcompiler.compile</span>
    <span class="s2"># method to support pre Python 2.3 distutils.</span>
    <span class="s0">global </span><span class="s1">_job_semaphore</span>

    <span class="s1">jobs = get_num_build_jobs()</span>

    <span class="s2"># setup semaphore to not exceed number of compile jobs when parallelized at</span>
    <span class="s2"># extension level (python &gt;= 3.5)</span>
    <span class="s0">with </span><span class="s1">_global_lock:</span>
        <span class="s0">if </span><span class="s1">_job_semaphore </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">_job_semaphore = threading.Semaphore(jobs)</span>

    <span class="s0">if not </span><span class="s1">sources:</span>
        <span class="s0">return </span><span class="s1">[]</span>
    <span class="s0">from </span><span class="s1">numpy.distutils.fcompiler </span><span class="s0">import </span><span class="s1">(FCompiler</span><span class="s0">, </span><span class="s1">is_f_file</span><span class="s0">,</span>
                                           <span class="s1">has_f90_header)</span>
    <span class="s0">if </span><span class="s1">isinstance(self</span><span class="s0">, </span><span class="s1">FCompiler):</span>
        <span class="s1">display = []</span>
        <span class="s0">for </span><span class="s1">fc </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'f77'</span><span class="s0">, </span><span class="s4">'f90'</span><span class="s0">, </span><span class="s4">'fix'</span><span class="s1">]:</span>
            <span class="s1">fcomp = getattr(self</span><span class="s0">, </span><span class="s4">'compiler_'</span><span class="s1">+fc)</span>
            <span class="s0">if </span><span class="s1">fcomp </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">continue</span>
            <span class="s1">display.append(</span><span class="s4">&quot;Fortran %s compiler: %s&quot; </span><span class="s1">% (fc</span><span class="s0">, </span><span class="s4">' '</span><span class="s1">.join(fcomp)))</span>
        <span class="s1">display = </span><span class="s4">'</span><span class="s0">\n</span><span class="s4">'</span><span class="s1">.join(display)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">ccomp = self.compiler_so</span>
        <span class="s1">display = </span><span class="s4">&quot;C compiler: %s</span><span class="s0">\n</span><span class="s4">&quot; </span><span class="s1">% (</span><span class="s4">' '</span><span class="s1">.join(ccomp)</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s1">log.info(display)</span>
    <span class="s1">macros</span><span class="s0">, </span><span class="s1">objects</span><span class="s0">, </span><span class="s1">extra_postargs</span><span class="s0">, </span><span class="s1">pp_opts</span><span class="s0">, </span><span class="s1">build = \</span>
            <span class="s1">self._setup_compile(output_dir</span><span class="s0">, </span><span class="s1">macros</span><span class="s0">, </span><span class="s1">include_dirs</span><span class="s0">, </span><span class="s1">sources</span><span class="s0">,</span>
                                <span class="s1">depends</span><span class="s0">, </span><span class="s1">extra_postargs)</span>
    <span class="s1">cc_args = self._get_cc_args(pp_opts</span><span class="s0">, </span><span class="s1">debug</span><span class="s0">, </span><span class="s1">extra_preargs)</span>
    <span class="s1">display = </span><span class="s4">&quot;compile options: '%s'&quot; </span><span class="s1">% (</span><span class="s4">' '</span><span class="s1">.join(cc_args))</span>
    <span class="s0">if </span><span class="s1">extra_postargs:</span>
        <span class="s1">display += </span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">extra options: '%s'&quot; </span><span class="s1">% (</span><span class="s4">' '</span><span class="s1">.join(extra_postargs))</span>
    <span class="s1">log.info(display)</span>

    <span class="s0">def </span><span class="s1">single_compile(args):</span>
        <span class="s1">obj</span><span class="s0">, </span><span class="s1">(src</span><span class="s0">, </span><span class="s1">ext) = args</span>
        <span class="s0">if not </span><span class="s1">_needs_build(obj</span><span class="s0">, </span><span class="s1">cc_args</span><span class="s0">, </span><span class="s1">extra_postargs</span><span class="s0">, </span><span class="s1">pp_opts):</span>
            <span class="s0">return</span>

        <span class="s2"># check if we are currently already processing the same object</span>
        <span class="s2"># happens when using the same source in multiple extensions</span>
        <span class="s0">while True</span><span class="s1">:</span>
            <span class="s2"># need explicit lock as there is no atomic check and add with GIL</span>
            <span class="s0">with </span><span class="s1">_global_lock:</span>
                <span class="s2"># file not being worked on, start working</span>
                <span class="s0">if </span><span class="s1">obj </span><span class="s0">not in </span><span class="s1">_processing_files:</span>
                    <span class="s1">_processing_files.add(obj)</span>
                    <span class="s0">break</span>
            <span class="s2"># wait for the processing to end</span>
            <span class="s1">time.sleep(</span><span class="s5">0.1</span><span class="s1">)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s2"># retrieve slot from our #job semaphore and build</span>
            <span class="s0">with </span><span class="s1">_job_semaphore:</span>
                <span class="s1">self._compile(obj</span><span class="s0">, </span><span class="s1">src</span><span class="s0">, </span><span class="s1">ext</span><span class="s0">, </span><span class="s1">cc_args</span><span class="s0">, </span><span class="s1">extra_postargs</span><span class="s0">, </span><span class="s1">pp_opts)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s2"># register being done processing</span>
            <span class="s0">with </span><span class="s1">_global_lock:</span>
                <span class="s1">_processing_files.remove(obj)</span>


    <span class="s0">if </span><span class="s1">isinstance(self</span><span class="s0">, </span><span class="s1">FCompiler):</span>
        <span class="s1">objects_to_build = list(build.keys())</span>
        <span class="s1">f77_objects</span><span class="s0">, </span><span class="s1">other_objects = []</span><span class="s0">, </span><span class="s1">[]</span>
        <span class="s0">for </span><span class="s1">obj </span><span class="s0">in </span><span class="s1">objects:</span>
            <span class="s0">if </span><span class="s1">obj </span><span class="s0">in </span><span class="s1">objects_to_build:</span>
                <span class="s1">src</span><span class="s0">, </span><span class="s1">ext = build[obj]</span>
                <span class="s0">if </span><span class="s1">self.compiler_type==</span><span class="s4">'absoft'</span><span class="s1">:</span>
                    <span class="s1">obj = cyg2win32(obj)</span>
                    <span class="s1">src = cyg2win32(src)</span>
                <span class="s0">if </span><span class="s1">is_f_file(src) </span><span class="s0">and not </span><span class="s1">has_f90_header(src):</span>
                    <span class="s1">f77_objects.append((obj</span><span class="s0">, </span><span class="s1">(src</span><span class="s0">, </span><span class="s1">ext)))</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">other_objects.append((obj</span><span class="s0">, </span><span class="s1">(src</span><span class="s0">, </span><span class="s1">ext)))</span>

        <span class="s2"># f77 objects can be built in parallel</span>
        <span class="s1">build_items = f77_objects</span>
        <span class="s2"># build f90 modules serial, module files are generated during</span>
        <span class="s2"># compilation and may be used by files later in the list so the</span>
        <span class="s2"># ordering is important</span>
        <span class="s0">for </span><span class="s1">o </span><span class="s0">in </span><span class="s1">other_objects:</span>
            <span class="s1">single_compile(o)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">build_items = build.items()</span>

    <span class="s0">if </span><span class="s1">len(build) &gt; </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">jobs &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s2"># build parallel</span>
        <span class="s0">import </span><span class="s1">multiprocessing.pool</span>
        <span class="s1">pool = multiprocessing.pool.ThreadPool(jobs)</span>
        <span class="s1">pool.map(single_compile</span><span class="s0">, </span><span class="s1">build_items)</span>
        <span class="s1">pool.close()</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s2"># build serial</span>
        <span class="s0">for </span><span class="s1">o </span><span class="s0">in </span><span class="s1">build_items:</span>
            <span class="s1">single_compile(o)</span>

    <span class="s2"># Return *all* object filenames, not just the ones we just built.</span>
    <span class="s0">return </span><span class="s1">objects</span>

<span class="s1">replace_method(CCompiler</span><span class="s0">, </span><span class="s4">'compile'</span><span class="s0">, </span><span class="s1">CCompiler_compile)</span>

<span class="s0">def </span><span class="s1">CCompiler_customize_cmd(self</span><span class="s0">, </span><span class="s1">cmd</span><span class="s0">, </span><span class="s1">ignore=()):</span>
    <span class="s3">&quot;&quot;&quot; 
    Customize compiler using distutils command. 
 
    Parameters 
    ---------- 
    cmd : class instance 
        An instance inheriting from `distutils.cmd.Command`. 
    ignore : sequence of str, optional 
        List of `CCompiler` commands (without ``'set_'``) that should not be 
        altered. Strings that are checked for are: 
        ``('include_dirs', 'define', 'undef', 'libraries', 'library_dirs', 
        'rpath', 'link_objects')``. 
 
    Returns 
    ------- 
    None 
 
    &quot;&quot;&quot;</span>
    <span class="s1">log.info(</span><span class="s4">'customize %s using %s' </span><span class="s1">% (self.__class__.__name__</span><span class="s0">,</span>
                                        <span class="s1">cmd.__class__.__name__))</span>
    <span class="s0">def </span><span class="s1">allow(attr):</span>
        <span class="s0">return </span><span class="s1">getattr(cmd</span><span class="s0">, </span><span class="s1">attr</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is not None and </span><span class="s1">attr </span><span class="s0">not in </span><span class="s1">ignore</span>

    <span class="s0">if </span><span class="s1">allow(</span><span class="s4">'include_dirs'</span><span class="s1">):</span>
        <span class="s1">self.set_include_dirs(cmd.include_dirs)</span>
    <span class="s0">if </span><span class="s1">allow(</span><span class="s4">'define'</span><span class="s1">):</span>
        <span class="s0">for </span><span class="s1">(name</span><span class="s0">, </span><span class="s1">value) </span><span class="s0">in </span><span class="s1">cmd.define:</span>
            <span class="s1">self.define_macro(name</span><span class="s0">, </span><span class="s1">value)</span>
    <span class="s0">if </span><span class="s1">allow(</span><span class="s4">'undef'</span><span class="s1">):</span>
        <span class="s0">for </span><span class="s1">macro </span><span class="s0">in </span><span class="s1">cmd.undef:</span>
            <span class="s1">self.undefine_macro(macro)</span>
    <span class="s0">if </span><span class="s1">allow(</span><span class="s4">'libraries'</span><span class="s1">):</span>
        <span class="s1">self.set_libraries(self.libraries + cmd.libraries)</span>
    <span class="s0">if </span><span class="s1">allow(</span><span class="s4">'library_dirs'</span><span class="s1">):</span>
        <span class="s1">self.set_library_dirs(self.library_dirs + cmd.library_dirs)</span>
    <span class="s0">if </span><span class="s1">allow(</span><span class="s4">'rpath'</span><span class="s1">):</span>
        <span class="s1">self.set_runtime_library_dirs(cmd.rpath)</span>
    <span class="s0">if </span><span class="s1">allow(</span><span class="s4">'link_objects'</span><span class="s1">):</span>
        <span class="s1">self.set_link_objects(cmd.link_objects)</span>

<span class="s1">replace_method(CCompiler</span><span class="s0">, </span><span class="s4">'customize_cmd'</span><span class="s0">, </span><span class="s1">CCompiler_customize_cmd)</span>

<span class="s0">def </span><span class="s1">_compiler_to_string(compiler):</span>
    <span class="s1">props = []</span>
    <span class="s1">mx = </span><span class="s5">0</span>
    <span class="s1">keys = list(compiler.executables.keys())</span>
    <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'version'</span><span class="s0">, </span><span class="s4">'libraries'</span><span class="s0">, </span><span class="s4">'library_dirs'</span><span class="s0">,</span>
                <span class="s4">'object_switch'</span><span class="s0">, </span><span class="s4">'compile_switch'</span><span class="s0">,</span>
                <span class="s4">'include_dirs'</span><span class="s0">, </span><span class="s4">'define'</span><span class="s0">, </span><span class="s4">'undef'</span><span class="s0">, </span><span class="s4">'rpath'</span><span class="s0">, </span><span class="s4">'link_objects'</span><span class="s1">]:</span>
        <span class="s0">if </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">keys:</span>
            <span class="s1">keys.append(key)</span>
    <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">keys:</span>
        <span class="s0">if </span><span class="s1">hasattr(compiler</span><span class="s0">, </span><span class="s1">key):</span>
            <span class="s1">v = getattr(compiler</span><span class="s0">, </span><span class="s1">key)</span>
            <span class="s1">mx = max(mx</span><span class="s0">, </span><span class="s1">len(key))</span>
            <span class="s1">props.append((key</span><span class="s0">, </span><span class="s1">repr(v)))</span>
    <span class="s1">fmt = </span><span class="s4">'%-' </span><span class="s1">+ repr(mx+</span><span class="s5">1</span><span class="s1">) + </span><span class="s4">'s = %s'</span>
    <span class="s1">lines = [fmt % prop </span><span class="s0">for </span><span class="s1">prop </span><span class="s0">in </span><span class="s1">props]</span>
    <span class="s0">return </span><span class="s4">'</span><span class="s0">\n</span><span class="s4">'</span><span class="s1">.join(lines)</span>

<span class="s0">def </span><span class="s1">CCompiler_show_customization(self):</span>
    <span class="s3">&quot;&quot;&quot; 
    Print the compiler customizations to stdout. 
 
    Parameters 
    ---------- 
    None 
 
    Returns 
    ------- 
    None 
 
    Notes 
    ----- 
    Printing is only done if the distutils log threshold is &lt; 2. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">self.get_version()</span>
    <span class="s0">except </span><span class="s1">Exception:</span>
        <span class="s0">pass</span>
    <span class="s0">if </span><span class="s1">log._global_log.threshold&lt;</span><span class="s5">2</span><span class="s1">:</span>
        <span class="s1">print(</span><span class="s4">'*'</span><span class="s1">*</span><span class="s5">80</span><span class="s1">)</span>
        <span class="s1">print(self.__class__)</span>
        <span class="s1">print(_compiler_to_string(self))</span>
        <span class="s1">print(</span><span class="s4">'*'</span><span class="s1">*</span><span class="s5">80</span><span class="s1">)</span>

<span class="s1">replace_method(CCompiler</span><span class="s0">, </span><span class="s4">'show_customization'</span><span class="s0">, </span><span class="s1">CCompiler_show_customization)</span>

<span class="s0">def </span><span class="s1">CCompiler_customize(self</span><span class="s0">, </span><span class="s1">dist</span><span class="s0">, </span><span class="s1">need_cxx=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Do any platform-specific customization of a compiler instance. 
 
    This method calls `distutils.sysconfig.customize_compiler` for 
    platform-specific customization, as well as optionally remove a flag 
    to suppress spurious warnings in case C++ code is being compiled. 
 
    Parameters 
    ---------- 
    dist : object 
        This parameter is not used for anything. 
    need_cxx : bool, optional 
        Whether or not C++ has to be compiled. If so (True), the 
        ``&quot;-Wstrict-prototypes&quot;`` option is removed to prevent spurious 
        warnings. Default is False. 
 
    Returns 
    ------- 
    None 
 
    Notes 
    ----- 
    All the default options used by distutils can be extracted with:: 
 
      from distutils import sysconfig 
      sysconfig.get_config_vars('CC', 'CXX', 'OPT', 'BASECFLAGS', 
                                'CCSHARED', 'LDSHARED', 'SO') 
 
    &quot;&quot;&quot;</span>
    <span class="s2"># See FCompiler.customize for suggested usage.</span>
    <span class="s1">log.info(</span><span class="s4">'customize %s' </span><span class="s1">% (self.__class__.__name__))</span>
    <span class="s1">customize_compiler(self)</span>
    <span class="s0">if </span><span class="s1">need_cxx:</span>
        <span class="s2"># In general, distutils uses -Wstrict-prototypes, but this option is</span>
        <span class="s2"># not valid for C++ code, only for C.  Remove it if it's there to</span>
        <span class="s2"># avoid a spurious warning on every compilation.</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self.compiler_so.remove(</span><span class="s4">'-Wstrict-prototypes'</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">(AttributeError</span><span class="s0">, </span><span class="s1">ValueError):</span>
            <span class="s0">pass</span>

        <span class="s0">if </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s4">'compiler'</span><span class="s1">) </span><span class="s0">and </span><span class="s4">'cc' </span><span class="s0">in </span><span class="s1">self.compiler[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s0">if not </span><span class="s1">self.compiler_cxx:</span>
                <span class="s0">if </span><span class="s1">self.compiler[</span><span class="s5">0</span><span class="s1">].startswith(</span><span class="s4">'gcc'</span><span class="s1">):</span>
                    <span class="s1">a</span><span class="s0">, </span><span class="s1">b = </span><span class="s4">'gcc'</span><span class="s0">, </span><span class="s4">'g++'</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">a</span><span class="s0">, </span><span class="s1">b = </span><span class="s4">'cc'</span><span class="s0">, </span><span class="s4">'c++'</span>
                <span class="s1">self.compiler_cxx = [self.compiler[</span><span class="s5">0</span><span class="s1">].replace(a</span><span class="s0">, </span><span class="s1">b)]\</span>
                                    <span class="s1">+ self.compiler[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s4">'compiler'</span><span class="s1">):</span>
                <span class="s1">log.warn(</span><span class="s4">&quot;#### %s #######&quot; </span><span class="s1">% (self.compiler</span><span class="s0">,</span><span class="s1">))</span>
            <span class="s0">if not </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s4">'compiler_cxx'</span><span class="s1">):</span>
                <span class="s1">log.warn(</span><span class="s4">'Missing compiler_cxx fix for ' </span><span class="s1">+ self.__class__.__name__)</span>


    <span class="s2"># check if compiler supports gcc style automatic dependencies</span>
    <span class="s2"># run on every extension so skip for known good compilers</span>
    <span class="s0">if </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s4">'compiler'</span><span class="s1">) </span><span class="s0">and </span><span class="s1">(</span><span class="s4">'gcc' </span><span class="s0">in </span><span class="s1">self.compiler[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">or</span>
                                      <span class="s4">'g++' </span><span class="s0">in </span><span class="s1">self.compiler[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">or</span>
                                      <span class="s4">'clang' </span><span class="s0">in </span><span class="s1">self.compiler[</span><span class="s5">0</span><span class="s1">]):</span>
        <span class="s1">self._auto_depends = </span><span class="s0">True</span>
    <span class="s0">elif </span><span class="s1">os.name == </span><span class="s4">'posix'</span><span class="s1">:</span>
        <span class="s0">import </span><span class="s1">tempfile</span>
        <span class="s0">import </span><span class="s1">shutil</span>
        <span class="s1">tmpdir = tempfile.mkdtemp()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">fn = os.path.join(tmpdir</span><span class="s0">, </span><span class="s4">&quot;file.c&quot;</span><span class="s1">)</span>
            <span class="s0">with </span><span class="s1">open(fn</span><span class="s0">, </span><span class="s4">&quot;w&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f:</span>
                <span class="s1">f.write(</span><span class="s4">&quot;int a;</span><span class="s0">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
            <span class="s1">self.compile([fn]</span><span class="s0">, </span><span class="s1">output_dir=tmpdir</span><span class="s0">,</span>
                         <span class="s1">extra_preargs=[</span><span class="s4">'-MMD'</span><span class="s0">, </span><span class="s4">'-MF'</span><span class="s0">, </span><span class="s1">fn + </span><span class="s4">'.d'</span><span class="s1">])</span>
            <span class="s1">self._auto_depends = </span><span class="s0">True</span>
        <span class="s0">except </span><span class="s1">CompileError:</span>
            <span class="s1">self._auto_depends = </span><span class="s0">False</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">shutil.rmtree(tmpdir)</span>

    <span class="s0">return</span>

<span class="s1">replace_method(CCompiler</span><span class="s0">, </span><span class="s4">'customize'</span><span class="s0">, </span><span class="s1">CCompiler_customize)</span>

<span class="s0">def </span><span class="s1">simple_version_match(pat=</span><span class="s4">r'[-.\d]+'</span><span class="s0">, </span><span class="s1">ignore=</span><span class="s4">''</span><span class="s0">, </span><span class="s1">start=</span><span class="s4">''</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Simple matching of version numbers, for use in CCompiler and FCompiler. 
 
    Parameters 
    ---------- 
    pat : str, optional 
        A regular expression matching version numbers. 
        Default is ``r'[-.\\d]+'``. 
    ignore : str, optional 
        A regular expression matching patterns to skip. 
        Default is ``''``, in which case nothing is skipped. 
    start : str, optional 
        A regular expression matching the start of where to start looking 
        for version numbers. 
        Default is ``''``, in which case searching is started at the 
        beginning of the version string given to `matcher`. 
 
    Returns 
    ------- 
    matcher : callable 
        A function that is appropriate to use as the ``.version_match`` 
        attribute of a `CCompiler` class. `matcher` takes a single parameter, 
        a version string. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">matcher(self</span><span class="s0">, </span><span class="s1">version_string):</span>
        <span class="s2"># version string may appear in the second line, so getting rid</span>
        <span class="s2"># of new lines:</span>
        <span class="s1">version_string = version_string.replace(</span><span class="s4">'</span><span class="s0">\n</span><span class="s4">'</span><span class="s0">, </span><span class="s4">' '</span><span class="s1">)</span>
        <span class="s1">pos = </span><span class="s5">0</span>
        <span class="s0">if </span><span class="s1">start:</span>
            <span class="s1">m = re.match(start</span><span class="s0">, </span><span class="s1">version_string)</span>
            <span class="s0">if not </span><span class="s1">m:</span>
                <span class="s0">return None</span>
            <span class="s1">pos = m.end()</span>
        <span class="s0">while True</span><span class="s1">:</span>
            <span class="s1">m = re.search(pat</span><span class="s0">, </span><span class="s1">version_string[pos:])</span>
            <span class="s0">if not </span><span class="s1">m:</span>
                <span class="s0">return None</span>
            <span class="s0">if </span><span class="s1">ignore </span><span class="s0">and </span><span class="s1">re.match(ignore</span><span class="s0">, </span><span class="s1">m.group(</span><span class="s5">0</span><span class="s1">)):</span>
                <span class="s1">pos = m.end()</span>
                <span class="s0">continue</span>
            <span class="s0">break</span>
        <span class="s0">return </span><span class="s1">m.group(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">matcher</span>

<span class="s0">def </span><span class="s1">CCompiler_get_version(self</span><span class="s0">, </span><span class="s1">force=</span><span class="s0">False, </span><span class="s1">ok_status=[</span><span class="s5">0</span><span class="s1">]):</span>
    <span class="s3">&quot;&quot;&quot; 
    Return compiler version, or None if compiler is not available. 
 
    Parameters 
    ---------- 
    force : bool, optional 
        If True, force a new determination of the version, even if the 
        compiler already has a version attribute. Default is False. 
    ok_status : list of int, optional 
        The list of status values returned by the version look-up process 
        for which a version string is returned. If the status value is not 
        in `ok_status`, None is returned. Default is ``[0]``. 
 
    Returns 
    ------- 
    version : str or None 
        Version string, in the format of `distutils.version.LooseVersion`. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">force </span><span class="s0">and </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s4">'version'</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">self.version</span>
    <span class="s1">self.find_executables()</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">version_cmd = self.version_cmd</span>
    <span class="s0">except </span><span class="s1">AttributeError:</span>
        <span class="s0">return None</span>
    <span class="s0">if not </span><span class="s1">version_cmd </span><span class="s0">or not </span><span class="s1">version_cmd[</span><span class="s5">0</span><span class="s1">]:</span>
        <span class="s0">return None</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">matcher = self.version_match</span>
    <span class="s0">except </span><span class="s1">AttributeError:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">pat = self.version_pattern</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s0">return None</span>
        <span class="s0">def </span><span class="s1">matcher(version_string):</span>
            <span class="s1">m = re.match(pat</span><span class="s0">, </span><span class="s1">version_string)</span>
            <span class="s0">if not </span><span class="s1">m:</span>
                <span class="s0">return None</span>
            <span class="s1">version = m.group(</span><span class="s4">'version'</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">version</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">output = subprocess.check_output(version_cmd</span><span class="s0">, </span><span class="s1">stderr=subprocess.STDOUT)</span>
    <span class="s0">except </span><span class="s1">subprocess.CalledProcessError </span><span class="s0">as </span><span class="s1">exc:</span>
        <span class="s1">output = exc.output</span>
        <span class="s1">status = exc.returncode</span>
    <span class="s0">except </span><span class="s1">OSError:</span>
        <span class="s2"># match the historical returns for a parent</span>
        <span class="s2"># exception class caught by exec_command()</span>
        <span class="s1">status = </span><span class="s5">127</span>
        <span class="s1">output = </span><span class="s6">b''</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s2"># output isn't actually a filepath but we do this</span>
        <span class="s2"># for now to match previous distutils behavior</span>
        <span class="s1">output = filepath_from_subprocess_output(output)</span>
        <span class="s1">status = </span><span class="s5">0</span>

    <span class="s1">version = </span><span class="s0">None</span>
    <span class="s0">if </span><span class="s1">status </span><span class="s0">in </span><span class="s1">ok_status:</span>
        <span class="s1">version = matcher(output)</span>
        <span class="s0">if </span><span class="s1">version:</span>
            <span class="s1">version = LooseVersion(version)</span>
    <span class="s1">self.version = version</span>
    <span class="s0">return </span><span class="s1">version</span>

<span class="s1">replace_method(CCompiler</span><span class="s0">, </span><span class="s4">'get_version'</span><span class="s0">, </span><span class="s1">CCompiler_get_version)</span>

<span class="s0">def </span><span class="s1">CCompiler_cxx_compiler(self):</span>
    <span class="s3">&quot;&quot;&quot; 
    Return the C++ compiler. 
 
    Parameters 
    ---------- 
    None 
 
    Returns 
    ------- 
    cxx : class instance 
        The C++ compiler, as a `CCompiler` instance. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">self.compiler_type </span><span class="s0">in </span><span class="s1">(</span><span class="s4">'msvc'</span><span class="s0">, </span><span class="s4">'intelw'</span><span class="s0">, </span><span class="s4">'intelemw'</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s1">cxx = copy(self)</span>
    <span class="s1">cxx.compiler_so = [cxx.compiler_cxx[</span><span class="s5">0</span><span class="s1">]] + cxx.compiler_so[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s0">if </span><span class="s1">sys.platform.startswith(</span><span class="s4">'aix'</span><span class="s1">) </span><span class="s0">and </span><span class="s4">'ld_so_aix' </span><span class="s0">in </span><span class="s1">cxx.linker_so[</span><span class="s5">0</span><span class="s1">]:</span>
        <span class="s2"># AIX needs the ld_so_aix script included with Python</span>
        <span class="s1">cxx.linker_so = [cxx.linker_so[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">cxx.compiler_cxx[</span><span class="s5">0</span><span class="s1">]] \</span>
                        <span class="s1">+ cxx.linker_so[</span><span class="s5">2</span><span class="s1">:]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">cxx.linker_so = [cxx.compiler_cxx[</span><span class="s5">0</span><span class="s1">]] + cxx.linker_so[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s0">return </span><span class="s1">cxx</span>

<span class="s1">replace_method(CCompiler</span><span class="s0">, </span><span class="s4">'cxx_compiler'</span><span class="s0">, </span><span class="s1">CCompiler_cxx_compiler)</span>

<span class="s1">compiler_class[</span><span class="s4">'intel'</span><span class="s1">] = (</span><span class="s4">'intelccompiler'</span><span class="s0">, </span><span class="s4">'IntelCCompiler'</span><span class="s0">,</span>
                           <span class="s4">&quot;Intel C Compiler for 32-bit applications&quot;</span><span class="s1">)</span>
<span class="s1">compiler_class[</span><span class="s4">'intele'</span><span class="s1">] = (</span><span class="s4">'intelccompiler'</span><span class="s0">, </span><span class="s4">'IntelItaniumCCompiler'</span><span class="s0">,</span>
                            <span class="s4">&quot;Intel C Itanium Compiler for Itanium-based applications&quot;</span><span class="s1">)</span>
<span class="s1">compiler_class[</span><span class="s4">'intelem'</span><span class="s1">] = (</span><span class="s4">'intelccompiler'</span><span class="s0">, </span><span class="s4">'IntelEM64TCCompiler'</span><span class="s0">,</span>
                             <span class="s4">&quot;Intel C Compiler for 64-bit applications&quot;</span><span class="s1">)</span>
<span class="s1">compiler_class[</span><span class="s4">'intelw'</span><span class="s1">] = (</span><span class="s4">'intelccompiler'</span><span class="s0">, </span><span class="s4">'IntelCCompilerW'</span><span class="s0">,</span>
                            <span class="s4">&quot;Intel C Compiler for 32-bit applications on Windows&quot;</span><span class="s1">)</span>
<span class="s1">compiler_class[</span><span class="s4">'intelemw'</span><span class="s1">] = (</span><span class="s4">'intelccompiler'</span><span class="s0">, </span><span class="s4">'IntelEM64TCCompilerW'</span><span class="s0">,</span>
                              <span class="s4">&quot;Intel C Compiler for 64-bit applications on Windows&quot;</span><span class="s1">)</span>
<span class="s1">compiler_class[</span><span class="s4">'pathcc'</span><span class="s1">] = (</span><span class="s4">'pathccompiler'</span><span class="s0">, </span><span class="s4">'PathScaleCCompiler'</span><span class="s0">,</span>
                            <span class="s4">&quot;PathScale Compiler for SiCortex-based applications&quot;</span><span class="s1">)</span>
<span class="s1">ccompiler._default_compilers += ((</span><span class="s4">'linux.*'</span><span class="s0">, </span><span class="s4">'intel'</span><span class="s1">)</span><span class="s0">,</span>
                                 <span class="s1">(</span><span class="s4">'linux.*'</span><span class="s0">, </span><span class="s4">'intele'</span><span class="s1">)</span><span class="s0">,</span>
                                 <span class="s1">(</span><span class="s4">'linux.*'</span><span class="s0">, </span><span class="s4">'intelem'</span><span class="s1">)</span><span class="s0">,</span>
                                 <span class="s1">(</span><span class="s4">'linux.*'</span><span class="s0">, </span><span class="s4">'pathcc'</span><span class="s1">)</span><span class="s0">,</span>
                                 <span class="s1">(</span><span class="s4">'nt'</span><span class="s0">, </span><span class="s4">'intelw'</span><span class="s1">)</span><span class="s0">,</span>
                                 <span class="s1">(</span><span class="s4">'nt'</span><span class="s0">, </span><span class="s4">'intelemw'</span><span class="s1">))</span>

<span class="s0">if </span><span class="s1">sys.platform == </span><span class="s4">'win32'</span><span class="s1">:</span>
    <span class="s1">compiler_class[</span><span class="s4">'mingw32'</span><span class="s1">] = (</span><span class="s4">'mingw32ccompiler'</span><span class="s0">, </span><span class="s4">'Mingw32CCompiler'</span><span class="s0">,</span>
                                 <span class="s4">&quot;Mingw32 port of GNU C Compiler for Win32&quot;</span><span class="s1">\</span>
                                 <span class="s4">&quot;(for MSC built Python)&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">mingw32():</span>
        <span class="s2"># On windows platforms, we want to default to mingw32 (gcc)</span>
        <span class="s2"># because msvc can't build blitz stuff.</span>
        <span class="s1">log.info(</span><span class="s4">'Setting mingw32 as default compiler for nt.'</span><span class="s1">)</span>
        <span class="s1">ccompiler._default_compilers = ((</span><span class="s4">'nt'</span><span class="s0">, </span><span class="s4">'mingw32'</span><span class="s1">)</span><span class="s0">,</span><span class="s1">) \</span>
                                       <span class="s1">+ ccompiler._default_compilers</span>


<span class="s1">_distutils_new_compiler = new_compiler</span>
<span class="s0">def </span><span class="s1">new_compiler (plat=</span><span class="s0">None,</span>
                  <span class="s1">compiler=</span><span class="s0">None,</span>
                  <span class="s1">verbose=</span><span class="s0">None,</span>
                  <span class="s1">dry_run=</span><span class="s5">0</span><span class="s0">,</span>
                  <span class="s1">force=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s2"># Try first C compilers from numpy.distutils.</span>
    <span class="s0">if </span><span class="s1">verbose </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">verbose = log.get_threshold() &lt;= log.INFO</span>
    <span class="s0">if </span><span class="s1">plat </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">plat = os.name</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">compiler </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">compiler = get_default_compiler(plat)</span>
        <span class="s1">(module_name</span><span class="s0">, </span><span class="s1">class_name</span><span class="s0">, </span><span class="s1">long_description) = compiler_class[compiler]</span>
    <span class="s0">except </span><span class="s1">KeyError:</span>
        <span class="s1">msg = </span><span class="s4">&quot;don't know how to compile C/C++ code on platform '%s'&quot; </span><span class="s1">% plat</span>
        <span class="s0">if </span><span class="s1">compiler </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">msg = msg + </span><span class="s4">&quot; with '%s' compiler&quot; </span><span class="s1">% compiler</span>
        <span class="s0">raise </span><span class="s1">DistutilsPlatformError(msg)</span>
    <span class="s1">module_name = </span><span class="s4">&quot;numpy.distutils.&quot; </span><span class="s1">+ module_name</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">__import__ (module_name)</span>
    <span class="s0">except </span><span class="s1">ImportError </span><span class="s0">as </span><span class="s1">e:</span>
        <span class="s1">msg = str(e)</span>
        <span class="s1">log.info(</span><span class="s4">'%s in numpy.distutils; trying from distutils'</span><span class="s0">,</span>
                 <span class="s1">str(msg))</span>
        <span class="s1">module_name = module_name[</span><span class="s5">6</span><span class="s1">:]</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">__import__(module_name)</span>
        <span class="s0">except </span><span class="s1">ImportError </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s1">msg = str(e)</span>
            <span class="s0">raise </span><span class="s1">DistutilsModuleError(</span><span class="s4">&quot;can't compile C/C++ code: unable to load module '%s'&quot; </span><span class="s1">% \</span>
                  <span class="s1">module_name)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">module = sys.modules[module_name]</span>
        <span class="s1">klass = vars(module)[class_name]</span>
    <span class="s0">except </span><span class="s1">KeyError:</span>
        <span class="s0">raise </span><span class="s1">DistutilsModuleError((</span><span class="s4">&quot;can't compile C/C++ code: unable to find class '%s' &quot; </span><span class="s1">+</span>
               <span class="s4">&quot;in module '%s'&quot;</span><span class="s1">) % (class_name</span><span class="s0">, </span><span class="s1">module_name))</span>
    <span class="s1">compiler = klass(</span><span class="s0">None, </span><span class="s1">dry_run</span><span class="s0">, </span><span class="s1">force)</span>
    <span class="s1">compiler.verbose = verbose</span>
    <span class="s1">log.debug(</span><span class="s4">'new_compiler returns %s' </span><span class="s1">% (klass))</span>
    <span class="s0">return </span><span class="s1">compiler</span>

<span class="s1">ccompiler.new_compiler = new_compiler</span>

<span class="s1">_distutils_gen_lib_options = gen_lib_options</span>
<span class="s0">def </span><span class="s1">gen_lib_options(compiler</span><span class="s0">, </span><span class="s1">library_dirs</span><span class="s0">, </span><span class="s1">runtime_library_dirs</span><span class="s0">, </span><span class="s1">libraries):</span>
    <span class="s2"># the version of this function provided by CPython allows the following</span>
    <span class="s2"># to return lists, which are unpacked automatically:</span>
    <span class="s2"># - compiler.runtime_library_dir_option</span>
    <span class="s2"># our version extends the behavior to:</span>
    <span class="s2"># - compiler.library_dir_option</span>
    <span class="s2"># - compiler.library_option</span>
    <span class="s2"># - compiler.find_library_file</span>
    <span class="s1">r = _distutils_gen_lib_options(compiler</span><span class="s0">, </span><span class="s1">library_dirs</span><span class="s0">,</span>
                                   <span class="s1">runtime_library_dirs</span><span class="s0">, </span><span class="s1">libraries)</span>
    <span class="s1">lib_opts = []</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">r:</span>
        <span class="s0">if </span><span class="s1">is_sequence(i):</span>
            <span class="s1">lib_opts.extend(list(i))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">lib_opts.append(i)</span>
    <span class="s0">return </span><span class="s1">lib_opts</span>
<span class="s1">ccompiler.gen_lib_options = gen_lib_options</span>

<span class="s2"># Also fix up the various compiler modules, which do</span>
<span class="s2"># from distutils.ccompiler import gen_lib_options</span>
<span class="s2"># Don't bother with mwerks, as we don't support Classic Mac.</span>
<span class="s0">for </span><span class="s1">_cc </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'msvc9'</span><span class="s0">, </span><span class="s4">'msvc'</span><span class="s0">, </span><span class="s4">'_msvc'</span><span class="s0">, </span><span class="s4">'bcpp'</span><span class="s0">, </span><span class="s4">'cygwinc'</span><span class="s0">, </span><span class="s4">'emxc'</span><span class="s0">, </span><span class="s4">'unixc'</span><span class="s1">]:</span>
    <span class="s1">_m = sys.modules.get(</span><span class="s4">'distutils.' </span><span class="s1">+ _cc + </span><span class="s4">'compiler'</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">_m </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">setattr(_m</span><span class="s0">, </span><span class="s4">'gen_lib_options'</span><span class="s0">, </span><span class="s1">gen_lib_options)</span>

</pre>
</body>
</html>