<html>
<head>
<title>parsers.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
parsers.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Module contains tools for processing files into DataFrames or other objects 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">abc</span><span class="s2">, </span><span class="s1">defaultdict</span>
<span class="s2">import </span><span class="s1">csv</span>
<span class="s2">import </span><span class="s1">datetime</span>
<span class="s2">from </span><span class="s1">io </span><span class="s2">import </span><span class="s1">StringIO</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">from </span><span class="s1">textwrap </span><span class="s2">import </span><span class="s1">fill</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">Dict</span><span class="s2">,</span>
    <span class="s1">Iterable</span><span class="s2">,</span>
    <span class="s1">Iterator</span><span class="s2">,</span>
    <span class="s1">List</span><span class="s2">,</span>
    <span class="s1">Optional</span><span class="s2">,</span>
    <span class="s1">Sequence</span><span class="s2">,</span>
    <span class="s1">Set</span><span class="s2">,</span>
    <span class="s1">Type</span><span class="s2">,</span>
    <span class="s1">cast</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">import </span><span class="s1">pandas._libs.lib </span><span class="s2">as </span><span class="s1">lib</span>
<span class="s2">import </span><span class="s1">pandas._libs.ops </span><span class="s2">as </span><span class="s1">libops</span>
<span class="s2">import </span><span class="s1">pandas._libs.parsers </span><span class="s2">as </span><span class="s1">parsers</span>
<span class="s2">from </span><span class="s1">pandas._libs.parsers </span><span class="s2">import </span><span class="s1">STR_NA_VALUES</span>
<span class="s2">from </span><span class="s1">pandas._libs.tslibs </span><span class="s2">import </span><span class="s1">parsing</span>
<span class="s2">from </span><span class="s1">pandas._typing </span><span class="s2">import </span><span class="s1">FilePathOrBuffer</span><span class="s2">, </span><span class="s1">StorageOptions</span><span class="s2">, </span><span class="s1">Union</span>
<span class="s2">from </span><span class="s1">pandas.errors </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">AbstractMethodError</span><span class="s2">,</span>
    <span class="s1">EmptyDataError</span><span class="s2">,</span>
    <span class="s1">ParserError</span><span class="s2">,</span>
    <span class="s1">ParserWarning</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.util._decorators </span><span class="s2">import </span><span class="s1">Appender</span>

<span class="s2">from </span><span class="s1">pandas.core.dtypes.cast </span><span class="s2">import </span><span class="s1">astype_nansafe</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ensure_object</span><span class="s2">,</span>
    <span class="s1">ensure_str</span><span class="s2">,</span>
    <span class="s1">is_bool_dtype</span><span class="s2">,</span>
    <span class="s1">is_categorical_dtype</span><span class="s2">,</span>
    <span class="s1">is_dict_like</span><span class="s2">,</span>
    <span class="s1">is_dtype_equal</span><span class="s2">,</span>
    <span class="s1">is_extension_array_dtype</span><span class="s2">,</span>
    <span class="s1">is_file_like</span><span class="s2">,</span>
    <span class="s1">is_float</span><span class="s2">,</span>
    <span class="s1">is_integer</span><span class="s2">,</span>
    <span class="s1">is_integer_dtype</span><span class="s2">,</span>
    <span class="s1">is_list_like</span><span class="s2">,</span>
    <span class="s1">is_object_dtype</span><span class="s2">,</span>
    <span class="s1">is_scalar</span><span class="s2">,</span>
    <span class="s1">is_string_dtype</span><span class="s2">,</span>
    <span class="s1">pandas_dtype</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.dtypes </span><span class="s2">import </span><span class="s1">CategoricalDtype</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.missing </span><span class="s2">import </span><span class="s1">isna</span>

<span class="s2">from </span><span class="s1">pandas.core </span><span class="s2">import </span><span class="s1">algorithms</span><span class="s2">, </span><span class="s1">generic</span>
<span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">Categorical</span>
<span class="s2">from </span><span class="s1">pandas.core.frame </span><span class="s2">import </span><span class="s1">DataFrame</span>
<span class="s2">from </span><span class="s1">pandas.core.indexes.api </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Index</span><span class="s2">,</span>
    <span class="s1">MultiIndex</span><span class="s2">,</span>
    <span class="s1">RangeIndex</span><span class="s2">,</span>
    <span class="s1">ensure_index_from_sequences</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.series </span><span class="s2">import </span><span class="s1">Series</span>
<span class="s2">from </span><span class="s1">pandas.core.tools </span><span class="s2">import </span><span class="s1">datetimes </span><span class="s2">as </span><span class="s1">tools</span>

<span class="s2">from </span><span class="s1">pandas.io.common </span><span class="s2">import </span><span class="s1">IOHandles</span><span class="s2">, </span><span class="s1">get_handle</span><span class="s2">, </span><span class="s1">validate_header_arg</span>
<span class="s2">from </span><span class="s1">pandas.io.date_converters </span><span class="s2">import </span><span class="s1">generic_parser</span>

<span class="s3"># BOM character (byte order mark)</span>
<span class="s3"># This exists at the beginning of a file to indicate endianness</span>
<span class="s3"># of a file (stream). Unfortunately, this marker screws up parsing,</span>
<span class="s3"># so we need to remove it if we see it.</span>
<span class="s1">_BOM = </span><span class="s4">&quot;</span><span class="s2">\ufeff</span><span class="s4">&quot;</span>

<span class="s1">_doc_read_csv_and_table = (</span>
    <span class="s4">r&quot;&quot;&quot; 
{summary} 
 
Also supports optionally iterating or breaking of the file 
into chunks. 
 
Additional help can be found in the online docs for 
`IO Tools &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html&gt;`_. 
 
Parameters 
---------- 
filepath_or_buffer : str, path object or file-like object 
    Any valid string path is acceptable. The string could be a URL. Valid 
    URL schemes include http, ftp, s3, gs, and file. For file URLs, a host is 
    expected. A local file could be: file://localhost/path/to/table.csv. 
 
    If you want to pass in a path object, pandas accepts any ``os.PathLike``. 
 
    By file-like object, we refer to objects with a ``read()`` method, such as 
    a file handle (e.g. via builtin ``open`` function) or ``StringIO``. 
sep : str, default {_default_sep} 
    Delimiter to use. If sep is None, the C engine cannot automatically detect 
    the separator, but the Python parsing engine can, meaning the latter will 
    be used and automatically detect the separator by Python's builtin sniffer 
    tool, ``csv.Sniffer``. In addition, separators longer than 1 character and 
    different from ``'\s+'`` will be interpreted as regular expressions and 
    will also force the use of the Python parsing engine. Note that regex 
    delimiters are prone to ignoring quoted data. Regex example: ``'\r\t'``. 
delimiter : str, default ``None`` 
    Alias for sep. 
header : int, list of int, default 'infer' 
    Row number(s) to use as the column names, and the start of the 
    data.  Default behavior is to infer the column names: if no names 
    are passed the behavior is identical to ``header=0`` and column 
    names are inferred from the first line of the file, if column 
    names are passed explicitly then the behavior is identical to 
    ``header=None``. Explicitly pass ``header=0`` to be able to 
    replace existing names. The header can be a list of integers that 
    specify row locations for a multi-index on the columns 
    e.g. [0,1,3]. Intervening rows that are not specified will be 
    skipped (e.g. 2 in this example is skipped). Note that this 
    parameter ignores commented lines and empty lines if 
    ``skip_blank_lines=True``, so ``header=0`` denotes the first line of 
    data rather than the first line of the file. 
names : array-like, optional 
    List of column names to use. If the file contains a header row, 
    then you should explicitly pass ``header=0`` to override the column names. 
    Duplicates in this list are not allowed. 
index_col : int, str, sequence of int / str, or False, default ``None`` 
  Column(s) to use as the row labels of the ``DataFrame``, either given as 
  string name or column index. If a sequence of int / str is given, a 
  MultiIndex is used. 
 
  Note: ``index_col=False`` can be used to force pandas to *not* use the first 
  column as the index, e.g. when you have a malformed file with delimiters at 
  the end of each line. 
usecols : list-like or callable, optional 
    Return a subset of the columns. If list-like, all elements must either 
    be positional (i.e. integer indices into the document columns) or strings 
    that correspond to column names provided either by the user in `names` or 
    inferred from the document header row(s). For example, a valid list-like 
    `usecols` parameter would be ``[0, 1, 2]`` or ``['foo', 'bar', 'baz']``. 
    Element order is ignored, so ``usecols=[0, 1]`` is the same as ``[1, 0]``. 
    To instantiate a DataFrame from ``data`` with element order preserved use 
    ``pd.read_csv(data, usecols=['foo', 'bar'])[['foo', 'bar']]`` for columns 
    in ``['foo', 'bar']`` order or 
    ``pd.read_csv(data, usecols=['foo', 'bar'])[['bar', 'foo']]`` 
    for ``['bar', 'foo']`` order. 
 
    If callable, the callable function will be evaluated against the column 
    names, returning names where the callable function evaluates to True. An 
    example of a valid callable argument would be ``lambda x: x.upper() in 
    ['AAA', 'BBB', 'DDD']``. Using this parameter results in much faster 
    parsing time and lower memory usage. 
squeeze : bool, default False 
    If the parsed data only contains one column then return a Series. 
prefix : str, optional 
    Prefix to add to column numbers when no header, e.g. 'X' for X0, X1, ... 
mangle_dupe_cols : bool, default True 
    Duplicate columns will be specified as 'X', 'X.1', ...'X.N', rather than 
    'X'...'X'. Passing in False will cause data to be overwritten if there 
    are duplicate names in the columns. 
dtype : Type name or dict of column -&gt; type, optional 
    Data type for data or columns. E.g. {{'a': np.float64, 'b': np.int32, 
    'c': 'Int64'}} 
    Use `str` or `object` together with suitable `na_values` settings 
    to preserve and not interpret dtype. 
    If converters are specified, they will be applied INSTEAD 
    of dtype conversion. 
engine : {{'c', 'python'}}, optional 
    Parser engine to use. The C engine is faster while the python engine is 
    currently more feature-complete. 
converters : dict, optional 
    Dict of functions for converting values in certain columns. Keys can either 
    be integers or column labels. 
true_values : list, optional 
    Values to consider as True. 
false_values : list, optional 
    Values to consider as False. 
skipinitialspace : bool, default False 
    Skip spaces after delimiter. 
skiprows : list-like, int or callable, optional 
    Line numbers to skip (0-indexed) or number of lines to skip (int) 
    at the start of the file. 
 
    If callable, the callable function will be evaluated against the row 
    indices, returning True if the row should be skipped and False otherwise. 
    An example of a valid callable argument would be ``lambda x: x in [0, 2]``. 
skipfooter : int, default 0 
    Number of lines at bottom of file to skip (Unsupported with engine='c'). 
nrows : int, optional 
    Number of rows of file to read. Useful for reading pieces of large files. 
na_values : scalar, str, list-like, or dict, optional 
    Additional strings to recognize as NA/NaN. If dict passed, specific 
    per-column NA values.  By default the following values are interpreted as 
    NaN: '&quot;&quot;&quot;</span>
    <span class="s1">+ fill(</span><span class="s4">&quot;', '&quot;</span><span class="s1">.join(sorted(STR_NA_VALUES))</span><span class="s2">, </span><span class="s5">70</span><span class="s2">, </span><span class="s1">subsequent_indent=</span><span class="s4">&quot;    &quot;</span><span class="s1">)</span>
    <span class="s1">+ </span><span class="s4">&quot;&quot;&quot;'. 
keep_default_na : bool, default True 
    Whether or not to include the default NaN values when parsing the data. 
    Depending on whether `na_values` is passed in, the behavior is as follows: 
 
    * If `keep_default_na` is True, and `na_values` are specified, `na_values` 
      is appended to the default NaN values used for parsing. 
    * If `keep_default_na` is True, and `na_values` are not specified, only 
      the default NaN values are used for parsing. 
    * If `keep_default_na` is False, and `na_values` are specified, only 
      the NaN values specified `na_values` are used for parsing. 
    * If `keep_default_na` is False, and `na_values` are not specified, no 
      strings will be parsed as NaN. 
 
    Note that if `na_filter` is passed in as False, the `keep_default_na` and 
    `na_values` parameters will be ignored. 
na_filter : bool, default True 
    Detect missing value markers (empty strings and the value of na_values). In 
    data without any NAs, passing na_filter=False can improve the performance 
    of reading a large file. 
verbose : bool, default False 
    Indicate number of NA values placed in non-numeric columns. 
skip_blank_lines : bool, default True 
    If True, skip over blank lines rather than interpreting as NaN values. 
parse_dates : bool or list of int or names or list of lists or dict, </span><span class="s2">\ 
</span><span class="s4">default False 
    The behavior is as follows: 
 
    * boolean. If True -&gt; try parsing the index. 
    * list of int or names. e.g. If [1, 2, 3] -&gt; try parsing columns 1, 2, 3 
      each as a separate date column. 
    * list of lists. e.g.  If [[1, 3]] -&gt; combine columns 1 and 3 and parse as 
      a single date column. 
    * dict, e.g. {{'foo' : [1, 3]}} -&gt; parse columns 1, 3 as date and call 
      result 'foo' 
 
    If a column or index cannot be represented as an array of datetimes, 
    say because of an unparsable value or a mixture of timezones, the column 
    or index will be returned unaltered as an object data type. For 
    non-standard datetime parsing, use ``pd.to_datetime`` after 
    ``pd.read_csv``. To parse an index or column with a mixture of timezones, 
    specify ``date_parser`` to be a partially-applied 
    :func:`pandas.to_datetime` with ``utc=True``. See 
    :ref:`io.csv.mixed_timezones` for more. 
 
    Note: A fast-path exists for iso8601-formatted dates. 
infer_datetime_format : bool, default False 
    If True and `parse_dates` is enabled, pandas will attempt to infer the 
    format of the datetime strings in the columns, and if it can be inferred, 
    switch to a faster method of parsing them. In some cases this can increase 
    the parsing speed by 5-10x. 
keep_date_col : bool, default False 
    If True and `parse_dates` specifies combining multiple columns then 
    keep the original columns. 
date_parser : function, optional 
    Function to use for converting a sequence of string columns to an array of 
    datetime instances. The default uses ``dateutil.parser.parser`` to do the 
    conversion. Pandas will try to call `date_parser` in three different ways, 
    advancing to the next if an exception occurs: 1) Pass one or more arrays 
    (as defined by `parse_dates`) as arguments; 2) concatenate (row-wise) the 
    string values from the columns defined by `parse_dates` into a single array 
    and pass that; and 3) call `date_parser` once for each row using one or 
    more strings (corresponding to the columns defined by `parse_dates`) as 
    arguments. 
dayfirst : bool, default False 
    DD/MM format dates, international and European format. 
cache_dates : bool, default True 
    If True, use a cache of unique, converted dates to apply the datetime 
    conversion. May produce significant speed-up when parsing duplicate 
    date strings, especially ones with timezone offsets. 
 
    .. versionadded:: 0.25.0 
iterator : bool, default False 
    Return TextFileReader object for iteration or getting chunks with 
    ``get_chunk()``. 
 
    .. versionchanged:: 1.2 
 
       ``TextFileReader`` is a context manager. 
chunksize : int, optional 
    Return TextFileReader object for iteration. 
    See the `IO Tools docs 
    &lt;https://pandas.pydata.org/pandas-docs/stable/io.html#io-chunking&gt;`_ 
    for more information on ``iterator`` and ``chunksize``. 
 
    .. versionchanged:: 1.2 
 
       ``TextFileReader`` is a context manager. 
compression : {{'infer', 'gzip', 'bz2', 'zip', 'xz', None}}, default 'infer' 
    For on-the-fly decompression of on-disk data. If 'infer' and 
    `filepath_or_buffer` is path-like, then detect compression from the 
    following extensions: '.gz', '.bz2', '.zip', or '.xz' (otherwise no 
    decompression). If using 'zip', the ZIP file must contain only one data 
    file to be read in. Set to None for no decompression. 
thousands : str, optional 
    Thousands separator. 
decimal : str, default '.' 
    Character to recognize as decimal point (e.g. use ',' for European data). 
lineterminator : str (length 1), optional 
    Character to break file into lines. Only valid with C parser. 
quotechar : str (length 1), optional 
    The character used to denote the start and end of a quoted item. Quoted 
    items can include the delimiter and it will be ignored. 
quoting : int or csv.QUOTE_* instance, default 0 
    Control field quoting behavior per ``csv.QUOTE_*`` constants. Use one of 
    QUOTE_MINIMAL (0), QUOTE_ALL (1), QUOTE_NONNUMERIC (2) or QUOTE_NONE (3). 
doublequote : bool, default ``True`` 
   When quotechar is specified and quoting is not ``QUOTE_NONE``, indicate 
   whether or not to interpret two consecutive quotechar elements INSIDE a 
   field as a single ``quotechar`` element. 
escapechar : str (length 1), optional 
    One-character string used to escape other characters. 
comment : str, optional 
    Indicates remainder of line should not be parsed. If found at the beginning 
    of a line, the line will be ignored altogether. This parameter must be a 
    single character. Like empty lines (as long as ``skip_blank_lines=True``), 
    fully commented lines are ignored by the parameter `header` but not by 
    `skiprows`. For example, if ``comment='#'``, parsing 
    ``#empty</span><span class="s2">\\</span><span class="s4">na,b,c</span><span class="s2">\\</span><span class="s4">n1,2,3`` with ``header=0`` will result in 'a,b,c' being 
    treated as the header. 
encoding : str, optional 
    Encoding to use for UTF when reading/writing (ex. 'utf-8'). `List of Python 
    standard encodings 
    &lt;https://docs.python.org/3/library/codecs.html#standard-encodings&gt;`_ . 
    .. versionchanged:: 1.2 
 
       When ``encoding`` is ``None``, ``errors=&quot;replace&quot;`` is passed to 
       ``open()``. Otherwise, ``errors=&quot;strict&quot;`` is passed to ``open()``. 
       This behavior was previously only the case for ``engine=&quot;python&quot;``. 
dialect : str or csv.Dialect, optional 
    If provided, this parameter will override values (default or not) for the 
    following parameters: `delimiter`, `doublequote`, `escapechar`, 
    `skipinitialspace`, `quotechar`, and `quoting`. If it is necessary to 
    override values, a ParserWarning will be issued. See csv.Dialect 
    documentation for more details. 
error_bad_lines : bool, default True 
    Lines with too many fields (e.g. a csv line with too many commas) will by 
    default cause an exception to be raised, and no DataFrame will be returned. 
    If False, then these &quot;bad lines&quot; will dropped from the DataFrame that is 
    returned. 
warn_bad_lines : bool, default True 
    If error_bad_lines is False, and warn_bad_lines is True, a warning for each 
    &quot;bad line&quot; will be output. 
delim_whitespace : bool, default False 
    Specifies whether or not whitespace (e.g. ``' '`` or ``'</span><span class="s2">\t</span><span class="s4">'``) will be 
    used as the sep. Equivalent to setting ``sep='</span><span class="s2">\\</span><span class="s4">s+'``. If this option 
    is set to True, nothing should be passed in for the ``delimiter`` 
    parameter. 
low_memory : bool, default True 
    Internally process the file in chunks, resulting in lower memory use 
    while parsing, but possibly mixed type inference.  To ensure no mixed 
    types either set False, or specify the type with the `dtype` parameter. 
    Note that the entire file is read into a single DataFrame regardless, 
    use the `chunksize` or `iterator` parameter to return the data in chunks. 
    (Only valid with C parser). 
memory_map : bool, default False 
    If a filepath is provided for `filepath_or_buffer`, map the file object 
    directly onto memory and access the data directly from there. Using this 
    option can improve performance because there is no longer any I/O overhead. 
float_precision : str, optional 
    Specifies which converter the C engine should use for floating-point 
    values. The options are ``None`` or 'high' for the ordinary converter, 
    'legacy' for the original lower precision pandas converter, and 
    'round_trip' for the round-trip converter. 
 
    .. versionchanged:: 1.2 
 
{storage_options} 
 
    .. versionadded:: 1.2 
 
Returns 
------- 
DataFrame or TextParser 
    A comma-separated values (csv) file is returned as two-dimensional 
    data structure with labeled axes. 
 
See Also 
-------- 
DataFrame.to_csv : Write DataFrame to a comma-separated values (csv) file. 
read_csv : Read a comma-separated values (csv) file into DataFrame. 
read_fwf : Read a table of fixed-width formatted lines into DataFrame. 
 
Examples 
-------- 
&gt;&gt;&gt; pd.{func_name}('data.csv')  # doctest: +SKIP 
&quot;&quot;&quot;</span>
<span class="s1">)</span>


<span class="s2">def </span><span class="s1">validate_integer(name</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">min_val=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Checks whether the 'name' parameter for parsing is either 
    an integer OR float that can SAFELY be cast to an integer 
    without losing accuracy. Raises a ValueError if that is 
    not the case. 
 
    Parameters 
    ---------- 
    name : string 
        Parameter name (used for error reporting) 
    val : int or float 
        The value to check 
    min_val : int 
        Minimum allowed value (val &lt; min_val will result in a ValueError) 
    &quot;&quot;&quot;</span>
    <span class="s1">msg = </span><span class="s4">f&quot;'</span><span class="s2">{</span><span class="s1">name</span><span class="s2">:</span><span class="s4">s</span><span class="s2">}</span><span class="s4">' must be an integer &gt;=</span><span class="s2">{</span><span class="s1">min_val</span><span class="s2">:</span><span class="s4">d</span><span class="s2">}</span><span class="s4">&quot;</span>

    <span class="s2">if </span><span class="s1">val </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">is_float(val):</span>
            <span class="s2">if </span><span class="s1">int(val) != val:</span>
                <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
            <span class="s1">val = int(val)</span>
        <span class="s2">elif not </span><span class="s1">(is_integer(val) </span><span class="s2">and </span><span class="s1">val &gt;= min_val):</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

    <span class="s2">return </span><span class="s1">val</span>


<span class="s2">def </span><span class="s1">_validate_names(names):</span>
    <span class="s0">&quot;&quot;&quot; 
    Raise ValueError if the `names` parameter contains duplicates or has an 
    invalid data type. 
 
    Parameters 
    ---------- 
    names : array-like or None 
        An array containing a list of the names used for the output DataFrame. 
 
    Raises 
    ------ 
    ValueError 
        If names are not unique or are not ordered (e.g. set). 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">names </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">len(names) != len(set(names)):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Duplicate names are not allowed.&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">(</span>
            <span class="s1">is_list_like(names</span><span class="s2">, </span><span class="s1">allow_sets=</span><span class="s2">False</span><span class="s1">) </span><span class="s2">or </span><span class="s1">isinstance(names</span><span class="s2">, </span><span class="s1">abc.KeysView)</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Names should be an ordered collection.&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_read(filepath_or_buffer: FilePathOrBuffer</span><span class="s2">, </span><span class="s1">kwds):</span>
    <span class="s0">&quot;&quot;&quot;Generic reader of line files.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">kwds.get(</span><span class="s4">&quot;date_parser&quot;</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">isinstance(kwds[</span><span class="s4">&quot;parse_dates&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">bool):</span>
            <span class="s1">kwds[</span><span class="s4">&quot;parse_dates&quot;</span><span class="s1">] = </span><span class="s2">True</span>

    <span class="s3"># Extract some of the arguments (pass chunksize on).</span>
    <span class="s1">iterator = kwds.get(</span><span class="s4">&quot;iterator&quot;</span><span class="s2">, False</span><span class="s1">)</span>
    <span class="s1">chunksize = validate_integer(</span><span class="s4">&quot;chunksize&quot;</span><span class="s2">, </span><span class="s1">kwds.get(</span><span class="s4">&quot;chunksize&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">nrows = kwds.get(</span><span class="s4">&quot;nrows&quot;</span><span class="s2">, None</span><span class="s1">)</span>

    <span class="s3"># Check for duplicates in names.</span>
    <span class="s1">_validate_names(kwds.get(</span><span class="s4">&quot;names&quot;</span><span class="s2">, None</span><span class="s1">))</span>

    <span class="s3"># Create the parser.</span>
    <span class="s1">parser = TextFileReader(filepath_or_buffer</span><span class="s2">, </span><span class="s1">**kwds)</span>

    <span class="s2">if </span><span class="s1">chunksize </span><span class="s2">or </span><span class="s1">iterator:</span>
        <span class="s2">return </span><span class="s1">parser</span>

    <span class="s2">with </span><span class="s1">parser:</span>
        <span class="s2">return </span><span class="s1">parser.read(nrows)</span>


<span class="s1">_parser_defaults = {</span>
    <span class="s4">&quot;delimiter&quot;</span><span class="s1">: </span><span class="s2">None,</span>
    <span class="s4">&quot;escapechar&quot;</span><span class="s1">: </span><span class="s2">None,</span>
    <span class="s4">&quot;quotechar&quot;</span><span class="s1">: </span><span class="s4">'&quot;'</span><span class="s2">,</span>
    <span class="s4">&quot;quoting&quot;</span><span class="s1">: csv.QUOTE_MINIMAL</span><span class="s2">,</span>
    <span class="s4">&quot;doublequote&quot;</span><span class="s1">: </span><span class="s2">True,</span>
    <span class="s4">&quot;skipinitialspace&quot;</span><span class="s1">: </span><span class="s2">False,</span>
    <span class="s4">&quot;lineterminator&quot;</span><span class="s1">: </span><span class="s2">None,</span>
    <span class="s4">&quot;header&quot;</span><span class="s1">: </span><span class="s4">&quot;infer&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;index_col&quot;</span><span class="s1">: </span><span class="s2">None,</span>
    <span class="s4">&quot;names&quot;</span><span class="s1">: </span><span class="s2">None,</span>
    <span class="s4">&quot;prefix&quot;</span><span class="s1">: </span><span class="s2">None,</span>
    <span class="s4">&quot;skiprows&quot;</span><span class="s1">: </span><span class="s2">None,</span>
    <span class="s4">&quot;skipfooter&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s4">&quot;nrows&quot;</span><span class="s1">: </span><span class="s2">None,</span>
    <span class="s4">&quot;na_values&quot;</span><span class="s1">: </span><span class="s2">None,</span>
    <span class="s4">&quot;keep_default_na&quot;</span><span class="s1">: </span><span class="s2">True,</span>
    <span class="s4">&quot;true_values&quot;</span><span class="s1">: </span><span class="s2">None,</span>
    <span class="s4">&quot;false_values&quot;</span><span class="s1">: </span><span class="s2">None,</span>
    <span class="s4">&quot;converters&quot;</span><span class="s1">: </span><span class="s2">None,</span>
    <span class="s4">&quot;dtype&quot;</span><span class="s1">: </span><span class="s2">None,</span>
    <span class="s4">&quot;cache_dates&quot;</span><span class="s1">: </span><span class="s2">True,</span>
    <span class="s4">&quot;thousands&quot;</span><span class="s1">: </span><span class="s2">None,</span>
    <span class="s4">&quot;comment&quot;</span><span class="s1">: </span><span class="s2">None,</span>
    <span class="s4">&quot;decimal&quot;</span><span class="s1">: </span><span class="s4">&quot;.&quot;</span><span class="s2">,</span>
    <span class="s3"># 'engine': 'c',</span>
    <span class="s4">&quot;parse_dates&quot;</span><span class="s1">: </span><span class="s2">False,</span>
    <span class="s4">&quot;keep_date_col&quot;</span><span class="s1">: </span><span class="s2">False,</span>
    <span class="s4">&quot;dayfirst&quot;</span><span class="s1">: </span><span class="s2">False,</span>
    <span class="s4">&quot;date_parser&quot;</span><span class="s1">: </span><span class="s2">None,</span>
    <span class="s4">&quot;usecols&quot;</span><span class="s1">: </span><span class="s2">None,</span>
    <span class="s3"># 'iterator': False,</span>
    <span class="s4">&quot;chunksize&quot;</span><span class="s1">: </span><span class="s2">None,</span>
    <span class="s4">&quot;verbose&quot;</span><span class="s1">: </span><span class="s2">False,</span>
    <span class="s4">&quot;encoding&quot;</span><span class="s1">: </span><span class="s2">None,</span>
    <span class="s4">&quot;squeeze&quot;</span><span class="s1">: </span><span class="s2">False,</span>
    <span class="s4">&quot;compression&quot;</span><span class="s1">: </span><span class="s2">None,</span>
    <span class="s4">&quot;mangle_dupe_cols&quot;</span><span class="s1">: </span><span class="s2">True,</span>
    <span class="s4">&quot;infer_datetime_format&quot;</span><span class="s1">: </span><span class="s2">False,</span>
    <span class="s4">&quot;skip_blank_lines&quot;</span><span class="s1">: </span><span class="s2">True,</span>
<span class="s1">}</span>


<span class="s1">_c_parser_defaults = {</span>
    <span class="s4">&quot;delim_whitespace&quot;</span><span class="s1">: </span><span class="s2">False,</span>
    <span class="s4">&quot;na_filter&quot;</span><span class="s1">: </span><span class="s2">True,</span>
    <span class="s4">&quot;low_memory&quot;</span><span class="s1">: </span><span class="s2">True,</span>
    <span class="s4">&quot;memory_map&quot;</span><span class="s1">: </span><span class="s2">False,</span>
    <span class="s4">&quot;error_bad_lines&quot;</span><span class="s1">: </span><span class="s2">True,</span>
    <span class="s4">&quot;warn_bad_lines&quot;</span><span class="s1">: </span><span class="s2">True,</span>
    <span class="s4">&quot;float_precision&quot;</span><span class="s1">: </span><span class="s2">None,</span>
<span class="s1">}</span>

<span class="s1">_fwf_defaults = {</span><span class="s4">&quot;colspecs&quot;</span><span class="s1">: </span><span class="s4">&quot;infer&quot;</span><span class="s2">, </span><span class="s4">&quot;infer_nrows&quot;</span><span class="s1">: </span><span class="s5">100</span><span class="s2">, </span><span class="s4">&quot;widths&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s1">}</span>

<span class="s1">_c_unsupported = {</span><span class="s4">&quot;skipfooter&quot;</span><span class="s1">}</span>
<span class="s1">_python_unsupported = {</span><span class="s4">&quot;low_memory&quot;</span><span class="s2">, </span><span class="s4">&quot;float_precision&quot;</span><span class="s1">}</span>

<span class="s1">_deprecated_defaults: Dict[str</span><span class="s2">, </span><span class="s1">Any] = {}</span>
<span class="s1">_deprecated_args: Set[str] = set()</span>


<span class="s1">@Appender(</span>
    <span class="s1">_doc_read_csv_and_table.format(</span>
        <span class="s1">func_name=</span><span class="s4">&quot;read_csv&quot;</span><span class="s2">,</span>
        <span class="s1">summary=</span><span class="s4">&quot;Read a comma-separated values (csv) file into DataFrame.&quot;</span><span class="s2">,</span>
        <span class="s1">_default_sep=</span><span class="s4">&quot;','&quot;</span><span class="s2">,</span>
        <span class="s1">storage_options=generic._shared_docs[</span><span class="s4">&quot;storage_options&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">read_csv(</span>
    <span class="s1">filepath_or_buffer: FilePathOrBuffer</span><span class="s2">,</span>
    <span class="s1">sep=lib.no_default</span><span class="s2">,</span>
    <span class="s1">delimiter=</span><span class="s2">None,</span>
    <span class="s3"># Column and Index Locations and Names</span>
    <span class="s1">header=</span><span class="s4">&quot;infer&quot;</span><span class="s2">,</span>
    <span class="s1">names=</span><span class="s2">None,</span>
    <span class="s1">index_col=</span><span class="s2">None,</span>
    <span class="s1">usecols=</span><span class="s2">None,</span>
    <span class="s1">squeeze=</span><span class="s2">False,</span>
    <span class="s1">prefix=</span><span class="s2">None,</span>
    <span class="s1">mangle_dupe_cols=</span><span class="s2">True,</span>
    <span class="s3"># General Parsing Configuration</span>
    <span class="s1">dtype=</span><span class="s2">None,</span>
    <span class="s1">engine=</span><span class="s2">None,</span>
    <span class="s1">converters=</span><span class="s2">None,</span>
    <span class="s1">true_values=</span><span class="s2">None,</span>
    <span class="s1">false_values=</span><span class="s2">None,</span>
    <span class="s1">skipinitialspace=</span><span class="s2">False,</span>
    <span class="s1">skiprows=</span><span class="s2">None,</span>
    <span class="s1">skipfooter=</span><span class="s5">0</span><span class="s2">,</span>
    <span class="s1">nrows=</span><span class="s2">None,</span>
    <span class="s3"># NA and Missing Data Handling</span>
    <span class="s1">na_values=</span><span class="s2">None,</span>
    <span class="s1">keep_default_na=</span><span class="s2">True,</span>
    <span class="s1">na_filter=</span><span class="s2">True,</span>
    <span class="s1">verbose=</span><span class="s2">False,</span>
    <span class="s1">skip_blank_lines=</span><span class="s2">True,</span>
    <span class="s3"># Datetime Handling</span>
    <span class="s1">parse_dates=</span><span class="s2">False,</span>
    <span class="s1">infer_datetime_format=</span><span class="s2">False,</span>
    <span class="s1">keep_date_col=</span><span class="s2">False,</span>
    <span class="s1">date_parser=</span><span class="s2">None,</span>
    <span class="s1">dayfirst=</span><span class="s2">False,</span>
    <span class="s1">cache_dates=</span><span class="s2">True,</span>
    <span class="s3"># Iteration</span>
    <span class="s1">iterator=</span><span class="s2">False,</span>
    <span class="s1">chunksize=</span><span class="s2">None,</span>
    <span class="s3"># Quoting, Compression, and File Format</span>
    <span class="s1">compression=</span><span class="s4">&quot;infer&quot;</span><span class="s2">,</span>
    <span class="s1">thousands=</span><span class="s2">None,</span>
    <span class="s1">decimal: str = </span><span class="s4">&quot;.&quot;</span><span class="s2">,</span>
    <span class="s1">lineterminator=</span><span class="s2">None,</span>
    <span class="s1">quotechar=</span><span class="s4">'&quot;'</span><span class="s2">,</span>
    <span class="s1">quoting=csv.QUOTE_MINIMAL</span><span class="s2">,</span>
    <span class="s1">doublequote=</span><span class="s2">True,</span>
    <span class="s1">escapechar=</span><span class="s2">None,</span>
    <span class="s1">comment=</span><span class="s2">None,</span>
    <span class="s1">encoding=</span><span class="s2">None,</span>
    <span class="s1">dialect=</span><span class="s2">None,</span>
    <span class="s3"># Error Handling</span>
    <span class="s1">error_bad_lines=</span><span class="s2">True,</span>
    <span class="s1">warn_bad_lines=</span><span class="s2">True,</span>
    <span class="s3"># Internal</span>
    <span class="s1">delim_whitespace=</span><span class="s2">False,</span>
    <span class="s1">low_memory=_c_parser_defaults[</span><span class="s4">&quot;low_memory&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">memory_map=</span><span class="s2">False,</span>
    <span class="s1">float_precision=</span><span class="s2">None,</span>
    <span class="s1">storage_options: StorageOptions = </span><span class="s2">None,</span>
<span class="s1">):</span>
    <span class="s1">kwds = locals()</span>
    <span class="s2">del </span><span class="s1">kwds[</span><span class="s4">&quot;filepath_or_buffer&quot;</span><span class="s1">]</span>
    <span class="s2">del </span><span class="s1">kwds[</span><span class="s4">&quot;sep&quot;</span><span class="s1">]</span>

    <span class="s1">kwds_defaults = _refine_defaults_read(</span>
        <span class="s1">dialect</span><span class="s2">, </span><span class="s1">delimiter</span><span class="s2">, </span><span class="s1">delim_whitespace</span><span class="s2">, </span><span class="s1">engine</span><span class="s2">, </span><span class="s1">sep</span><span class="s2">, </span><span class="s1">defaults={</span><span class="s4">&quot;delimiter&quot;</span><span class="s1">: </span><span class="s4">&quot;,&quot;</span><span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">kwds.update(kwds_defaults)</span>

    <span class="s2">return </span><span class="s1">_read(filepath_or_buffer</span><span class="s2">, </span><span class="s1">kwds)</span>


<span class="s1">@Appender(</span>
    <span class="s1">_doc_read_csv_and_table.format(</span>
        <span class="s1">func_name=</span><span class="s4">&quot;read_table&quot;</span><span class="s2">,</span>
        <span class="s1">summary=</span><span class="s4">&quot;Read general delimited file into DataFrame.&quot;</span><span class="s2">,</span>
        <span class="s1">_default_sep=</span><span class="s4">r&quot;'\\t' (tab-stop)&quot;</span><span class="s2">,</span>
        <span class="s1">storage_options=generic._shared_docs[</span><span class="s4">&quot;storage_options&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">read_table(</span>
    <span class="s1">filepath_or_buffer: FilePathOrBuffer</span><span class="s2">,</span>
    <span class="s1">sep=lib.no_default</span><span class="s2">,</span>
    <span class="s1">delimiter=</span><span class="s2">None,</span>
    <span class="s3"># Column and Index Locations and Names</span>
    <span class="s1">header=</span><span class="s4">&quot;infer&quot;</span><span class="s2">,</span>
    <span class="s1">names=</span><span class="s2">None,</span>
    <span class="s1">index_col=</span><span class="s2">None,</span>
    <span class="s1">usecols=</span><span class="s2">None,</span>
    <span class="s1">squeeze=</span><span class="s2">False,</span>
    <span class="s1">prefix=</span><span class="s2">None,</span>
    <span class="s1">mangle_dupe_cols=</span><span class="s2">True,</span>
    <span class="s3"># General Parsing Configuration</span>
    <span class="s1">dtype=</span><span class="s2">None,</span>
    <span class="s1">engine=</span><span class="s2">None,</span>
    <span class="s1">converters=</span><span class="s2">None,</span>
    <span class="s1">true_values=</span><span class="s2">None,</span>
    <span class="s1">false_values=</span><span class="s2">None,</span>
    <span class="s1">skipinitialspace=</span><span class="s2">False,</span>
    <span class="s1">skiprows=</span><span class="s2">None,</span>
    <span class="s1">skipfooter=</span><span class="s5">0</span><span class="s2">,</span>
    <span class="s1">nrows=</span><span class="s2">None,</span>
    <span class="s3"># NA and Missing Data Handling</span>
    <span class="s1">na_values=</span><span class="s2">None,</span>
    <span class="s1">keep_default_na=</span><span class="s2">True,</span>
    <span class="s1">na_filter=</span><span class="s2">True,</span>
    <span class="s1">verbose=</span><span class="s2">False,</span>
    <span class="s1">skip_blank_lines=</span><span class="s2">True,</span>
    <span class="s3"># Datetime Handling</span>
    <span class="s1">parse_dates=</span><span class="s2">False,</span>
    <span class="s1">infer_datetime_format=</span><span class="s2">False,</span>
    <span class="s1">keep_date_col=</span><span class="s2">False,</span>
    <span class="s1">date_parser=</span><span class="s2">None,</span>
    <span class="s1">dayfirst=</span><span class="s2">False,</span>
    <span class="s1">cache_dates=</span><span class="s2">True,</span>
    <span class="s3"># Iteration</span>
    <span class="s1">iterator=</span><span class="s2">False,</span>
    <span class="s1">chunksize=</span><span class="s2">None,</span>
    <span class="s3"># Quoting, Compression, and File Format</span>
    <span class="s1">compression=</span><span class="s4">&quot;infer&quot;</span><span class="s2">,</span>
    <span class="s1">thousands=</span><span class="s2">None,</span>
    <span class="s1">decimal: str = </span><span class="s4">&quot;.&quot;</span><span class="s2">,</span>
    <span class="s1">lineterminator=</span><span class="s2">None,</span>
    <span class="s1">quotechar=</span><span class="s4">'&quot;'</span><span class="s2">,</span>
    <span class="s1">quoting=csv.QUOTE_MINIMAL</span><span class="s2">,</span>
    <span class="s1">doublequote=</span><span class="s2">True,</span>
    <span class="s1">escapechar=</span><span class="s2">None,</span>
    <span class="s1">comment=</span><span class="s2">None,</span>
    <span class="s1">encoding=</span><span class="s2">None,</span>
    <span class="s1">dialect=</span><span class="s2">None,</span>
    <span class="s3"># Error Handling</span>
    <span class="s1">error_bad_lines=</span><span class="s2">True,</span>
    <span class="s1">warn_bad_lines=</span><span class="s2">True,</span>
    <span class="s3"># Internal</span>
    <span class="s1">delim_whitespace=</span><span class="s2">False,</span>
    <span class="s1">low_memory=_c_parser_defaults[</span><span class="s4">&quot;low_memory&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">memory_map=</span><span class="s2">False,</span>
    <span class="s1">float_precision=</span><span class="s2">None,</span>
<span class="s1">):</span>
    <span class="s1">kwds = locals()</span>
    <span class="s2">del </span><span class="s1">kwds[</span><span class="s4">&quot;filepath_or_buffer&quot;</span><span class="s1">]</span>
    <span class="s2">del </span><span class="s1">kwds[</span><span class="s4">&quot;sep&quot;</span><span class="s1">]</span>

    <span class="s1">kwds_defaults = _refine_defaults_read(</span>
        <span class="s1">dialect</span><span class="s2">, </span><span class="s1">delimiter</span><span class="s2">, </span><span class="s1">delim_whitespace</span><span class="s2">, </span><span class="s1">engine</span><span class="s2">, </span><span class="s1">sep</span><span class="s2">, </span><span class="s1">defaults={</span><span class="s4">&quot;delimiter&quot;</span><span class="s1">: </span><span class="s4">&quot;</span><span class="s2">\t</span><span class="s4">&quot;</span><span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">kwds.update(kwds_defaults)</span>

    <span class="s2">return </span><span class="s1">_read(filepath_or_buffer</span><span class="s2">, </span><span class="s1">kwds)</span>


<span class="s2">def </span><span class="s1">read_fwf(</span>
    <span class="s1">filepath_or_buffer: FilePathOrBuffer</span><span class="s2">,</span>
    <span class="s1">colspecs=</span><span class="s4">&quot;infer&quot;</span><span class="s2">,</span>
    <span class="s1">widths=</span><span class="s2">None,</span>
    <span class="s1">infer_nrows=</span><span class="s5">100</span><span class="s2">,</span>
    <span class="s1">**kwds</span><span class="s2">,</span>
<span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Read a table of fixed-width formatted lines into DataFrame. 
 
    Also supports optionally iterating or breaking of the file 
    into chunks. 
 
    Additional help can be found in the `online docs for IO Tools 
    &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html&gt;`_. 
 
    Parameters 
    ---------- 
    filepath_or_buffer : str, path object or file-like object 
        Any valid string path is acceptable. The string could be a URL. Valid 
        URL schemes include http, ftp, s3, and file. For file URLs, a host is 
        expected. A local file could be: 
        ``file://localhost/path/to/table.csv``. 
 
        If you want to pass in a path object, pandas accepts any 
        ``os.PathLike``. 
 
        By file-like object, we refer to objects with a ``read()`` method, 
        such as a file handle (e.g. via builtin ``open`` function) 
        or ``StringIO``. 
    colspecs : list of tuple (int, int) or 'infer'. optional 
        A list of tuples giving the extents of the fixed-width 
        fields of each line as half-open intervals (i.e.,  [from, to[ ). 
        String value 'infer' can be used to instruct the parser to try 
        detecting the column specifications from the first 100 rows of 
        the data which are not being skipped via skiprows (default='infer'). 
    widths : list of int, optional 
        A list of field widths which can be used instead of 'colspecs' if 
        the intervals are contiguous. 
    infer_nrows : int, default 100 
        The number of rows to consider when letting the parser determine the 
        `colspecs`. 
 
        .. versionadded:: 0.24.0 
    **kwds : optional 
        Optional keyword arguments can be passed to ``TextFileReader``. 
 
    Returns 
    ------- 
    DataFrame or TextParser 
        A comma-separated values (csv) file is returned as two-dimensional 
        data structure with labeled axes. 
 
    See Also 
    -------- 
    DataFrame.to_csv : Write DataFrame to a comma-separated values (csv) file. 
    read_csv : Read a comma-separated values (csv) file into DataFrame. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; pd.read_fwf('data.csv')  # doctest: +SKIP 
    &quot;&quot;&quot;</span>
    <span class="s3"># Check input arguments.</span>
    <span class="s2">if </span><span class="s1">colspecs </span><span class="s2">is None and </span><span class="s1">widths </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Must specify either colspecs or widths&quot;</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">colspecs </span><span class="s2">not in </span><span class="s1">(</span><span class="s2">None, </span><span class="s4">&quot;infer&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">widths </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;You must specify only one of 'widths' and 'colspecs'&quot;</span><span class="s1">)</span>

    <span class="s3"># Compute 'colspecs' from 'widths', if specified.</span>
    <span class="s2">if </span><span class="s1">widths </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">colspecs</span><span class="s2">, </span><span class="s1">col = []</span><span class="s2">, </span><span class="s5">0</span>
        <span class="s2">for </span><span class="s1">w </span><span class="s2">in </span><span class="s1">widths:</span>
            <span class="s1">colspecs.append((col</span><span class="s2">, </span><span class="s1">col + w))</span>
            <span class="s1">col += w</span>

    <span class="s1">kwds[</span><span class="s4">&quot;colspecs&quot;</span><span class="s1">] = colspecs</span>
    <span class="s1">kwds[</span><span class="s4">&quot;infer_nrows&quot;</span><span class="s1">] = infer_nrows</span>
    <span class="s1">kwds[</span><span class="s4">&quot;engine&quot;</span><span class="s1">] = </span><span class="s4">&quot;python-fwf&quot;</span>
    <span class="s2">return </span><span class="s1">_read(filepath_or_buffer</span><span class="s2">, </span><span class="s1">kwds)</span>


<span class="s2">class </span><span class="s1">TextFileReader(abc.Iterator):</span>
    <span class="s0">&quot;&quot;&quot; 
 
    Passed dialect overrides any of the related parser options 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">engine=</span><span class="s2">None, </span><span class="s1">**kwds):</span>

        <span class="s1">self.f = f</span>

        <span class="s2">if </span><span class="s1">engine </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">engine_specified = </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">engine = </span><span class="s4">&quot;python&quot;</span>
            <span class="s1">engine_specified = </span><span class="s2">False</span>
        <span class="s1">self.engine = engine</span>
        <span class="s1">self._engine_specified = kwds.get(</span><span class="s4">&quot;engine_specified&quot;</span><span class="s2">, </span><span class="s1">engine_specified)</span>

        <span class="s1">_validate_skipfooter(kwds)</span>

        <span class="s1">dialect = _extract_dialect(kwds)</span>
        <span class="s2">if </span><span class="s1">dialect </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">kwds = _merge_with_dialect_properties(dialect</span><span class="s2">, </span><span class="s1">kwds)</span>

        <span class="s2">if </span><span class="s1">kwds.get(</span><span class="s4">&quot;header&quot;</span><span class="s2">, </span><span class="s4">&quot;infer&quot;</span><span class="s1">) == </span><span class="s4">&quot;infer&quot;</span><span class="s1">:</span>
            <span class="s1">kwds[</span><span class="s4">&quot;header&quot;</span><span class="s1">] = </span><span class="s5">0 </span><span class="s2">if </span><span class="s1">kwds.get(</span><span class="s4">&quot;names&quot;</span><span class="s1">) </span><span class="s2">is None else None</span>

        <span class="s1">self.orig_options = kwds</span>

        <span class="s3"># miscellanea</span>
        <span class="s1">self._currow = </span><span class="s5">0</span>

        <span class="s1">options = self._get_options_with_defaults(engine)</span>
        <span class="s1">options[</span><span class="s4">&quot;storage_options&quot;</span><span class="s1">] = kwds.get(</span><span class="s4">&quot;storage_options&quot;</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s1">self.chunksize = options.pop(</span><span class="s4">&quot;chunksize&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">self.nrows = options.pop(</span><span class="s4">&quot;nrows&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">self.squeeze = options.pop(</span><span class="s4">&quot;squeeze&quot;</span><span class="s2">, False</span><span class="s1">)</span>

        <span class="s1">self._check_file_or_buffer(f</span><span class="s2">, </span><span class="s1">engine)</span>
        <span class="s1">self.options</span><span class="s2">, </span><span class="s1">self.engine = self._clean_options(options</span><span class="s2">, </span><span class="s1">engine)</span>

        <span class="s2">if </span><span class="s4">&quot;has_index_names&quot; </span><span class="s2">in </span><span class="s1">kwds:</span>
            <span class="s1">self.options[</span><span class="s4">&quot;has_index_names&quot;</span><span class="s1">] = kwds[</span><span class="s4">&quot;has_index_names&quot;</span><span class="s1">]</span>

        <span class="s1">self._engine = self._make_engine(self.engine)</span>

    <span class="s2">def </span><span class="s1">close(self):</span>
        <span class="s1">self._engine.close()</span>

    <span class="s2">def </span><span class="s1">_get_options_with_defaults(self</span><span class="s2">, </span><span class="s1">engine):</span>
        <span class="s1">kwds = self.orig_options</span>

        <span class="s1">options = {}</span>

        <span class="s2">for </span><span class="s1">argname</span><span class="s2">, </span><span class="s1">default </span><span class="s2">in </span><span class="s1">_parser_defaults.items():</span>
            <span class="s1">value = kwds.get(argname</span><span class="s2">, </span><span class="s1">default)</span>

            <span class="s3"># see gh-12935</span>
            <span class="s2">if </span><span class="s1">argname == </span><span class="s4">&quot;mangle_dupe_cols&quot; </span><span class="s2">and not </span><span class="s1">value:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Setting mangle_dupe_cols=False is not supported yet&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">options[argname] = value</span>

        <span class="s2">for </span><span class="s1">argname</span><span class="s2">, </span><span class="s1">default </span><span class="s2">in </span><span class="s1">_c_parser_defaults.items():</span>
            <span class="s2">if </span><span class="s1">argname </span><span class="s2">in </span><span class="s1">kwds:</span>
                <span class="s1">value = kwds[argname]</span>

                <span class="s2">if </span><span class="s1">engine != </span><span class="s4">&quot;c&quot; </span><span class="s2">and </span><span class="s1">value != default:</span>
                    <span class="s2">if </span><span class="s4">&quot;python&quot; </span><span class="s2">in </span><span class="s1">engine </span><span class="s2">and </span><span class="s1">argname </span><span class="s2">not in </span><span class="s1">_python_unsupported:</span>
                        <span class="s2">pass</span>
                    <span class="s2">elif </span><span class="s1">value == _deprecated_defaults.get(argname</span><span class="s2">, </span><span class="s1">default):</span>
                        <span class="s2">pass</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">raise </span><span class="s1">ValueError(</span>
                            <span class="s4">f&quot;The </span><span class="s2">{</span><span class="s1">repr(argname)</span><span class="s2">} </span><span class="s4">option is not supported with the &quot;</span>
                            <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">repr(engine)</span><span class="s2">} </span><span class="s4">engine&quot;</span>
                        <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">value = _deprecated_defaults.get(argname</span><span class="s2">, </span><span class="s1">default)</span>
            <span class="s1">options[argname] = value</span>

        <span class="s2">if </span><span class="s1">engine == </span><span class="s4">&quot;python-fwf&quot;</span><span class="s1">:</span>
            <span class="s3"># pandas\io\parsers.py:907: error: Incompatible types in assignment</span>
            <span class="s3"># (expression has type &quot;object&quot;, variable has type &quot;Union[int, str,</span>
            <span class="s3"># None]&quot;)  [assignment]</span>
            <span class="s2">for </span><span class="s1">argname</span><span class="s2">, </span><span class="s1">default </span><span class="s2">in </span><span class="s1">_fwf_defaults.items():  </span><span class="s3"># type: ignore[assignment]</span>
                <span class="s1">options[argname] = kwds.get(argname</span><span class="s2">, </span><span class="s1">default)</span>

        <span class="s2">return </span><span class="s1">options</span>

    <span class="s2">def </span><span class="s1">_check_file_or_buffer(self</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">engine):</span>
        <span class="s3"># see gh-16530</span>
        <span class="s2">if </span><span class="s1">is_file_like(f) </span><span class="s2">and </span><span class="s1">engine != </span><span class="s4">&quot;c&quot; </span><span class="s2">and not </span><span class="s1">hasattr(f</span><span class="s2">, </span><span class="s4">&quot;__next__&quot;</span><span class="s1">):</span>
            <span class="s3"># The C engine doesn't need the file-like to have the &quot;__next__&quot;</span>
            <span class="s3"># attribute. However, the Python engine explicitly calls</span>
            <span class="s3"># &quot;__next__(...)&quot; when iterating through such an object, meaning it</span>
            <span class="s3"># needs to have that attribute</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;The 'python' engine cannot iterate through this file buffer.&quot;</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_clean_options(self</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">engine):</span>
        <span class="s1">result = options.copy()</span>

        <span class="s1">fallback_reason = </span><span class="s2">None</span>

        <span class="s3"># C engine not supported yet</span>
        <span class="s2">if </span><span class="s1">engine == </span><span class="s4">&quot;c&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">options[</span><span class="s4">&quot;skipfooter&quot;</span><span class="s1">] &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">fallback_reason = </span><span class="s4">&quot;the 'c' engine does not support skipfooter&quot;</span>
                <span class="s1">engine = </span><span class="s4">&quot;python&quot;</span>

        <span class="s1">sep = options[</span><span class="s4">&quot;delimiter&quot;</span><span class="s1">]</span>
        <span class="s1">delim_whitespace = options[</span><span class="s4">&quot;delim_whitespace&quot;</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">sep </span><span class="s2">is None and not </span><span class="s1">delim_whitespace:</span>
            <span class="s2">if </span><span class="s1">engine == </span><span class="s4">&quot;c&quot;</span><span class="s1">:</span>
                <span class="s1">fallback_reason = (</span>
                    <span class="s4">&quot;the 'c' engine does not support &quot;</span>
                    <span class="s4">&quot;sep=None with delim_whitespace=False&quot;</span>
                <span class="s1">)</span>
                <span class="s1">engine = </span><span class="s4">&quot;python&quot;</span>
        <span class="s2">elif </span><span class="s1">sep </span><span class="s2">is not None and </span><span class="s1">len(sep) &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">engine == </span><span class="s4">&quot;c&quot; </span><span class="s2">and </span><span class="s1">sep == </span><span class="s4">r&quot;\s+&quot;</span><span class="s1">:</span>
                <span class="s1">result[</span><span class="s4">&quot;delim_whitespace&quot;</span><span class="s1">] = </span><span class="s2">True</span>
                <span class="s2">del </span><span class="s1">result[</span><span class="s4">&quot;delimiter&quot;</span><span class="s1">]</span>
            <span class="s2">elif </span><span class="s1">engine </span><span class="s2">not in </span><span class="s1">(</span><span class="s4">&quot;python&quot;</span><span class="s2">, </span><span class="s4">&quot;python-fwf&quot;</span><span class="s1">):</span>
                <span class="s3"># wait until regex engine integrated</span>
                <span class="s1">fallback_reason = (</span>
                    <span class="s4">&quot;the 'c' engine does not support &quot;</span>
                    <span class="s4">&quot;regex separators (separators &gt; 1 char and &quot;</span>
                    <span class="s4">r&quot;different from '\s+' are interpreted as regex)&quot;</span>
                <span class="s1">)</span>
                <span class="s1">engine = </span><span class="s4">&quot;python&quot;</span>
        <span class="s2">elif </span><span class="s1">delim_whitespace:</span>
            <span class="s2">if </span><span class="s4">&quot;python&quot; </span><span class="s2">in </span><span class="s1">engine:</span>
                <span class="s1">result[</span><span class="s4">&quot;delimiter&quot;</span><span class="s1">] = </span><span class="s4">r&quot;\s+&quot;</span>
        <span class="s2">elif </span><span class="s1">sep </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">encodeable = </span><span class="s2">True</span>
            <span class="s1">encoding = sys.getfilesystemencoding() </span><span class="s2">or </span><span class="s4">&quot;utf-8&quot;</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">len(sep.encode(encoding)) &gt; </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">encodeable = </span><span class="s2">False</span>
            <span class="s2">except </span><span class="s1">UnicodeDecodeError:</span>
                <span class="s1">encodeable = </span><span class="s2">False</span>
            <span class="s2">if not </span><span class="s1">encodeable </span><span class="s2">and </span><span class="s1">engine </span><span class="s2">not in </span><span class="s1">(</span><span class="s4">&quot;python&quot;</span><span class="s2">, </span><span class="s4">&quot;python-fwf&quot;</span><span class="s1">):</span>
                <span class="s1">fallback_reason = (</span>
                    <span class="s4">f&quot;the separator encoded in </span><span class="s2">{</span><span class="s1">encoding</span><span class="s2">} </span><span class="s4">&quot;</span>
                    <span class="s4">&quot;is &gt; 1 char long, and the 'c' engine &quot;</span>
                    <span class="s4">&quot;does not support such separators&quot;</span>
                <span class="s1">)</span>
                <span class="s1">engine = </span><span class="s4">&quot;python&quot;</span>

        <span class="s1">quotechar = options[</span><span class="s4">&quot;quotechar&quot;</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">quotechar </span><span class="s2">is not None and </span><span class="s1">isinstance(quotechar</span><span class="s2">, </span><span class="s1">(str</span><span class="s2">, </span><span class="s1">bytes)):</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">len(quotechar) == </span><span class="s5">1</span>
                <span class="s2">and </span><span class="s1">ord(quotechar) &gt; </span><span class="s5">127</span>
                <span class="s2">and </span><span class="s1">engine </span><span class="s2">not in </span><span class="s1">(</span><span class="s4">&quot;python&quot;</span><span class="s2">, </span><span class="s4">&quot;python-fwf&quot;</span><span class="s1">)</span>
            <span class="s1">):</span>
                <span class="s1">fallback_reason = (</span>
                    <span class="s4">&quot;ord(quotechar) &gt; 127, meaning the &quot;</span>
                    <span class="s4">&quot;quotechar is larger than one byte, &quot;</span>
                    <span class="s4">&quot;and the 'c' engine does not support such quotechars&quot;</span>
                <span class="s1">)</span>
                <span class="s1">engine = </span><span class="s4">&quot;python&quot;</span>

        <span class="s2">if </span><span class="s1">fallback_reason </span><span class="s2">and </span><span class="s1">self._engine_specified:</span>
            <span class="s2">raise </span><span class="s1">ValueError(fallback_reason)</span>

        <span class="s2">if </span><span class="s1">engine == </span><span class="s4">&quot;c&quot;</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">_c_unsupported:</span>
                <span class="s2">del </span><span class="s1">result[arg]</span>

        <span class="s2">if </span><span class="s4">&quot;python&quot; </span><span class="s2">in </span><span class="s1">engine:</span>
            <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">_python_unsupported:</span>
                <span class="s2">if </span><span class="s1">fallback_reason </span><span class="s2">and </span><span class="s1">result[arg] != _c_parser_defaults[arg]:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s4">&quot;Falling back to the 'python' engine because &quot;</span>
                        <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">fallback_reason</span><span class="s2">}</span><span class="s4">, but this causes </span><span class="s2">{</span><span class="s1">repr(arg)</span><span class="s2">} </span><span class="s4">to be &quot;</span>
                        <span class="s4">&quot;ignored as it is not supported by the 'python' engine.&quot;</span>
                    <span class="s1">)</span>
                <span class="s2">del </span><span class="s1">result[arg]</span>

        <span class="s2">if </span><span class="s1">fallback_reason:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s1">(</span>
                    <span class="s4">&quot;Falling back to the 'python' engine because &quot;</span>
                    <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">fallback_reason</span><span class="s2">}</span><span class="s4">; you can avoid this warning by specifying &quot;</span>
                    <span class="s4">&quot;engine='python'.&quot;</span>
                <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">ParserWarning</span><span class="s2">,</span>
                <span class="s1">stacklevel=</span><span class="s5">5</span><span class="s2">,</span>
            <span class="s1">)</span>

        <span class="s1">index_col = options[</span><span class="s4">&quot;index_col&quot;</span><span class="s1">]</span>
        <span class="s1">names = options[</span><span class="s4">&quot;names&quot;</span><span class="s1">]</span>
        <span class="s1">converters = options[</span><span class="s4">&quot;converters&quot;</span><span class="s1">]</span>
        <span class="s1">na_values = options[</span><span class="s4">&quot;na_values&quot;</span><span class="s1">]</span>
        <span class="s1">skiprows = options[</span><span class="s4">&quot;skiprows&quot;</span><span class="s1">]</span>

        <span class="s1">validate_header_arg(options[</span><span class="s4">&quot;header&quot;</span><span class="s1">])</span>

        <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">_deprecated_args:</span>
            <span class="s1">parser_default = _c_parser_defaults[arg]</span>
            <span class="s1">depr_default = _deprecated_defaults[arg]</span>
            <span class="s2">if </span><span class="s1">result.get(arg</span><span class="s2">, </span><span class="s1">depr_default) != depr_default:</span>
                <span class="s1">msg = (</span>
                    <span class="s4">f&quot;The </span><span class="s2">{</span><span class="s1">arg</span><span class="s2">} </span><span class="s4">argument has been deprecated and will be &quot;</span>
                    <span class="s4">&quot;removed in a future version.</span><span class="s2">\n\n</span><span class="s4">&quot;</span>
                <span class="s1">)</span>
                <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">FutureWarning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">result[arg] = parser_default</span>

        <span class="s2">if </span><span class="s1">index_col </span><span class="s2">is True</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;The value of index_col couldn't be 'True'&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">_is_index_col(index_col):</span>
            <span class="s2">if not </span><span class="s1">isinstance(index_col</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">np.ndarray)):</span>
                <span class="s1">index_col = [index_col]</span>
        <span class="s1">result[</span><span class="s4">&quot;index_col&quot;</span><span class="s1">] = index_col</span>

        <span class="s1">names = list(names) </span><span class="s2">if </span><span class="s1">names </span><span class="s2">is not None else </span><span class="s1">names</span>

        <span class="s3"># type conversion-related</span>
        <span class="s2">if </span><span class="s1">converters </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">isinstance(converters</span><span class="s2">, </span><span class="s1">dict):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s4">&quot;Type converters must be a dict or subclass, &quot;</span>
                    <span class="s4">f&quot;input was a </span><span class="s2">{</span><span class="s1">type(converters).__name__</span><span class="s2">}</span><span class="s4">&quot;</span>
                <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">converters = {}</span>

        <span class="s3"># Converting values to NA</span>
        <span class="s1">keep_default_na = options[</span><span class="s4">&quot;keep_default_na&quot;</span><span class="s1">]</span>
        <span class="s1">na_values</span><span class="s2">, </span><span class="s1">na_fvalues = _clean_na_values(na_values</span><span class="s2">, </span><span class="s1">keep_default_na)</span>

        <span class="s3"># handle skiprows; this is internally handled by the</span>
        <span class="s3"># c-engine, so only need for python parsers</span>
        <span class="s2">if </span><span class="s1">engine != </span><span class="s4">&quot;c&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">is_integer(skiprows):</span>
                <span class="s1">skiprows = list(range(skiprows))</span>
            <span class="s2">if </span><span class="s1">skiprows </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">skiprows = set()</span>
            <span class="s2">elif not </span><span class="s1">callable(skiprows):</span>
                <span class="s1">skiprows = set(skiprows)</span>

        <span class="s3"># put stuff back</span>
        <span class="s1">result[</span><span class="s4">&quot;names&quot;</span><span class="s1">] = names</span>
        <span class="s1">result[</span><span class="s4">&quot;converters&quot;</span><span class="s1">] = converters</span>
        <span class="s1">result[</span><span class="s4">&quot;na_values&quot;</span><span class="s1">] = na_values</span>
        <span class="s1">result[</span><span class="s4">&quot;na_fvalues&quot;</span><span class="s1">] = na_fvalues</span>
        <span class="s1">result[</span><span class="s4">&quot;skiprows&quot;</span><span class="s1">] = skiprows</span>

        <span class="s2">return </span><span class="s1">result</span><span class="s2">, </span><span class="s1">engine</span>

    <span class="s2">def </span><span class="s1">__next__(self):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.get_chunk()</span>
        <span class="s2">except </span><span class="s1">StopIteration:</span>
            <span class="s1">self.close()</span>
            <span class="s2">raise</span>

    <span class="s2">def </span><span class="s1">_make_engine(self</span><span class="s2">, </span><span class="s1">engine=</span><span class="s4">&quot;c&quot;</span><span class="s1">):</span>
        <span class="s1">mapping: Dict[str</span><span class="s2">, </span><span class="s1">Type[ParserBase]] = {</span>
            <span class="s4">&quot;c&quot;</span><span class="s1">: CParserWrapper</span><span class="s2">,</span>
            <span class="s4">&quot;python&quot;</span><span class="s1">: PythonParser</span><span class="s2">,</span>
            <span class="s4">&quot;python-fwf&quot;</span><span class="s1">: FixedWidthFieldParser</span><span class="s2">,</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">engine </span><span class="s2">not in </span><span class="s1">mapping:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">f&quot;Unknown engine: </span><span class="s2">{</span><span class="s1">engine</span><span class="s2">} </span><span class="s4">(valid options are </span><span class="s2">{</span><span class="s1">mapping.keys()</span><span class="s2">}</span><span class="s4">)&quot;</span>
            <span class="s1">)</span>
        <span class="s3"># error: Too many arguments for &quot;ParserBase&quot;</span>
        <span class="s2">return </span><span class="s1">mapping[engine](self.f</span><span class="s2">, </span><span class="s1">**self.options)  </span><span class="s3"># type: ignore[call-arg]</span>

    <span class="s2">def </span><span class="s1">_failover_to_python(self):</span>
        <span class="s2">raise </span><span class="s1">AbstractMethodError(self)</span>

    <span class="s2">def </span><span class="s1">read(self</span><span class="s2">, </span><span class="s1">nrows=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">nrows = validate_integer(</span><span class="s4">&quot;nrows&quot;</span><span class="s2">, </span><span class="s1">nrows)</span>
        <span class="s1">index</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">col_dict = self._engine.read(nrows)</span>

        <span class="s2">if </span><span class="s1">index </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">col_dict:</span>
                <span class="s3"># Any column is actually fine:</span>
                <span class="s1">new_rows = len(next(iter(col_dict.values())))</span>
                <span class="s1">index = RangeIndex(self._currow</span><span class="s2">, </span><span class="s1">self._currow + new_rows)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">new_rows = </span><span class="s5">0</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">new_rows = len(index)</span>

        <span class="s1">df = DataFrame(col_dict</span><span class="s2">, </span><span class="s1">columns=columns</span><span class="s2">, </span><span class="s1">index=index)</span>

        <span class="s1">self._currow += new_rows</span>

        <span class="s2">if </span><span class="s1">self.squeeze </span><span class="s2">and </span><span class="s1">len(df.columns) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">df[df.columns[</span><span class="s5">0</span><span class="s1">]].copy()</span>
        <span class="s2">return </span><span class="s1">df</span>

    <span class="s2">def </span><span class="s1">get_chunk(self</span><span class="s2">, </span><span class="s1">size=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">size </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">size = self.chunksize</span>
        <span class="s2">if </span><span class="s1">self.nrows </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self._currow &gt;= self.nrows:</span>
                <span class="s2">raise </span><span class="s1">StopIteration</span>
            <span class="s1">size = min(size</span><span class="s2">, </span><span class="s1">self.nrows - self._currow)</span>
        <span class="s2">return </span><span class="s1">self.read(nrows=size)</span>

    <span class="s2">def </span><span class="s1">__enter__(self):</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__exit__(self</span><span class="s2">, </span><span class="s1">exc_type</span><span class="s2">, </span><span class="s1">exc_value</span><span class="s2">, </span><span class="s1">traceback):</span>
        <span class="s1">self.close()</span>


<span class="s2">def </span><span class="s1">_is_index_col(col):</span>
    <span class="s2">return </span><span class="s1">col </span><span class="s2">is not None and </span><span class="s1">col </span><span class="s2">is not False</span>


<span class="s2">def </span><span class="s1">_is_potential_multi_index(</span>
    <span class="s1">columns</span><span class="s2">, </span><span class="s1">index_col: Optional[Union[bool</span><span class="s2">, </span><span class="s1">Sequence[int]]] = </span><span class="s2">None</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Check whether or not the `columns` parameter 
    could be converted into a MultiIndex. 
 
    Parameters 
    ---------- 
    columns : array-like 
        Object which may or may not be convertible into a MultiIndex 
    index_col : None, bool or list, optional 
        Column or columns to use as the (possibly hierarchical) index 
 
    Returns 
    ------- 
    boolean : Whether or not columns could become a MultiIndex 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">index_col </span><span class="s2">is None or </span><span class="s1">isinstance(index_col</span><span class="s2">, </span><span class="s1">bool):</span>
        <span class="s1">index_col = []</span>

    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">len(columns)</span>
        <span class="s2">and not </span><span class="s1">isinstance(columns</span><span class="s2">, </span><span class="s1">MultiIndex)</span>
        <span class="s2">and </span><span class="s1">all(isinstance(c</span><span class="s2">, </span><span class="s1">tuple) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">columns </span><span class="s2">if </span><span class="s1">c </span><span class="s2">not in </span><span class="s1">list(index_col))</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">_evaluate_usecols(usecols</span><span class="s2">, </span><span class="s1">names):</span>
    <span class="s0">&quot;&quot;&quot; 
    Check whether or not the 'usecols' parameter 
    is a callable.  If so, enumerates the 'names' 
    parameter and returns a set of indices for 
    each entry in 'names' that evaluates to True. 
    If not a callable, returns 'usecols'. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">callable(usecols):</span>
        <span class="s2">return </span><span class="s1">{i </span><span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">enumerate(names) </span><span class="s2">if </span><span class="s1">usecols(name)}</span>
    <span class="s2">return </span><span class="s1">usecols</span>


<span class="s2">def </span><span class="s1">_validate_usecols_names(usecols</span><span class="s2">, </span><span class="s1">names):</span>
    <span class="s0">&quot;&quot;&quot; 
    Validates that all usecols are present in a given 
    list of names. If not, raise a ValueError that 
    shows what usecols are missing. 
 
    Parameters 
    ---------- 
    usecols : iterable of usecols 
        The columns to validate are present in names. 
    names : iterable of names 
        The column names to check against. 
 
    Returns 
    ------- 
    usecols : iterable of usecols 
        The `usecols` parameter if the validation succeeds. 
 
    Raises 
    ------ 
    ValueError : Columns were missing. Error message will list them. 
    &quot;&quot;&quot;</span>
    <span class="s1">missing = [c </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">usecols </span><span class="s2">if </span><span class="s1">c </span><span class="s2">not in </span><span class="s1">names]</span>
    <span class="s2">if </span><span class="s1">len(missing) &gt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s4">f&quot;Usecols do not match columns, columns expected but not found: </span><span class="s2">{</span><span class="s1">missing</span><span class="s2">}</span><span class="s4">&quot;</span>
        <span class="s1">)</span>

    <span class="s2">return </span><span class="s1">usecols</span>


<span class="s2">def </span><span class="s1">_validate_skipfooter_arg(skipfooter):</span>
    <span class="s0">&quot;&quot;&quot; 
    Validate the 'skipfooter' parameter. 
 
    Checks whether 'skipfooter' is a non-negative integer. 
    Raises a ValueError if that is not the case. 
 
    Parameters 
    ---------- 
    skipfooter : non-negative integer 
        The number of rows to skip at the end of the file. 
 
    Returns 
    ------- 
    validated_skipfooter : non-negative integer 
        The original input if the validation succeeds. 
 
    Raises 
    ------ 
    ValueError : 'skipfooter' was not a non-negative integer. 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">is_integer(skipfooter):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;skipfooter must be an integer&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">skipfooter &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;skipfooter cannot be negative&quot;</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">skipfooter</span>


<span class="s2">def </span><span class="s1">_validate_usecols_arg(usecols):</span>
    <span class="s0">&quot;&quot;&quot; 
    Validate the 'usecols' parameter. 
 
    Checks whether or not the 'usecols' parameter contains all integers 
    (column selection by index), strings (column by name) or is a callable. 
    Raises a ValueError if that is not the case. 
 
    Parameters 
    ---------- 
    usecols : list-like, callable, or None 
        List of columns to use when parsing or a callable that can be used 
        to filter a list of table columns. 
 
    Returns 
    ------- 
    usecols_tuple : tuple 
        A tuple of (verified_usecols, usecols_dtype). 
 
        'verified_usecols' is either a set if an array-like is passed in or 
        'usecols' if a callable or None is passed in. 
 
        'usecols_dtype` is the inferred dtype of 'usecols' if an array-like 
        is passed in or None if a callable or None is passed in. 
    &quot;&quot;&quot;</span>
    <span class="s1">msg = (</span>
        <span class="s4">&quot;'usecols' must either be list-like of all strings, all unicode, &quot;</span>
        <span class="s4">&quot;all integers or a callable.&quot;</span>
    <span class="s1">)</span>
    <span class="s2">if </span><span class="s1">usecols </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">callable(usecols):</span>
            <span class="s2">return </span><span class="s1">usecols</span><span class="s2">, None</span>

        <span class="s2">if not </span><span class="s1">is_list_like(usecols):</span>
            <span class="s3"># see gh-20529</span>
            <span class="s3">#</span>
            <span class="s3"># Ensure it is iterable container but not string.</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

        <span class="s1">usecols_dtype = lib.infer_dtype(usecols</span><span class="s2">, </span><span class="s1">skipna=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">usecols_dtype </span><span class="s2">not in </span><span class="s1">(</span><span class="s4">&quot;empty&quot;</span><span class="s2">, </span><span class="s4">&quot;integer&quot;</span><span class="s2">, </span><span class="s4">&quot;string&quot;</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

        <span class="s1">usecols = set(usecols)</span>

        <span class="s2">return </span><span class="s1">usecols</span><span class="s2">, </span><span class="s1">usecols_dtype</span>
    <span class="s2">return </span><span class="s1">usecols</span><span class="s2">, None</span>


<span class="s2">def </span><span class="s1">_validate_parse_dates_arg(parse_dates):</span>
    <span class="s0">&quot;&quot;&quot; 
    Check whether or not the 'parse_dates' parameter 
    is a non-boolean scalar. Raises a ValueError if 
    that is the case. 
    &quot;&quot;&quot;</span>
    <span class="s1">msg = (</span>
        <span class="s4">&quot;Only booleans, lists, and dictionaries are accepted &quot;</span>
        <span class="s4">&quot;for the 'parse_dates' parameter&quot;</span>
    <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">parse_dates </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">is_scalar(parse_dates):</span>
            <span class="s2">if not </span><span class="s1">lib.is_bool(parse_dates):</span>
                <span class="s2">raise </span><span class="s1">TypeError(msg)</span>

        <span class="s2">elif not </span><span class="s1">isinstance(parse_dates</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">dict)):</span>
            <span class="s2">raise </span><span class="s1">TypeError(msg)</span>

    <span class="s2">return </span><span class="s1">parse_dates</span>


<span class="s2">class </span><span class="s1">ParserBase:</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">kwds):</span>

        <span class="s1">self.names = kwds.get(</span><span class="s4">&quot;names&quot;</span><span class="s1">)</span>
        <span class="s1">self.orig_names: Optional[List] = </span><span class="s2">None</span>
        <span class="s1">self.prefix = kwds.pop(</span><span class="s4">&quot;prefix&quot;</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s1">self.index_col = kwds.get(</span><span class="s4">&quot;index_col&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">self.unnamed_cols: Set = set()</span>
        <span class="s1">self.index_names: Optional[List] = </span><span class="s2">None</span>
        <span class="s1">self.col_names = </span><span class="s2">None</span>

        <span class="s1">self.parse_dates = _validate_parse_dates_arg(kwds.pop(</span><span class="s4">&quot;parse_dates&quot;</span><span class="s2">, False</span><span class="s1">))</span>
        <span class="s1">self.date_parser = kwds.pop(</span><span class="s4">&quot;date_parser&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">self.dayfirst = kwds.pop(</span><span class="s4">&quot;dayfirst&quot;</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">self.keep_date_col = kwds.pop(</span><span class="s4">&quot;keep_date_col&quot;</span><span class="s2">, False</span><span class="s1">)</span>

        <span class="s1">self.na_values = kwds.get(</span><span class="s4">&quot;na_values&quot;</span><span class="s1">)</span>
        <span class="s1">self.na_fvalues = kwds.get(</span><span class="s4">&quot;na_fvalues&quot;</span><span class="s1">)</span>
        <span class="s1">self.na_filter = kwds.get(</span><span class="s4">&quot;na_filter&quot;</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">self.keep_default_na = kwds.get(</span><span class="s4">&quot;keep_default_na&quot;</span><span class="s2">, True</span><span class="s1">)</span>

        <span class="s1">self.true_values = kwds.get(</span><span class="s4">&quot;true_values&quot;</span><span class="s1">)</span>
        <span class="s1">self.false_values = kwds.get(</span><span class="s4">&quot;false_values&quot;</span><span class="s1">)</span>
        <span class="s1">self.mangle_dupe_cols = kwds.get(</span><span class="s4">&quot;mangle_dupe_cols&quot;</span><span class="s2">, True</span><span class="s1">)</span>
        <span class="s1">self.infer_datetime_format = kwds.pop(</span><span class="s4">&quot;infer_datetime_format&quot;</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">self.cache_dates = kwds.pop(</span><span class="s4">&quot;cache_dates&quot;</span><span class="s2">, True</span><span class="s1">)</span>

        <span class="s1">self._date_conv = _make_date_converter(</span>
            <span class="s1">date_parser=self.date_parser</span><span class="s2">,</span>
            <span class="s1">dayfirst=self.dayfirst</span><span class="s2">,</span>
            <span class="s1">infer_datetime_format=self.infer_datetime_format</span><span class="s2">,</span>
            <span class="s1">cache_dates=self.cache_dates</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s3"># validate header options for mi</span>
        <span class="s1">self.header = kwds.get(</span><span class="s4">&quot;header&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">isinstance(self.header</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">np.ndarray)):</span>
            <span class="s2">if not </span><span class="s1">all(map(is_integer</span><span class="s2">, </span><span class="s1">self.header)):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;header must be integer or list of integers&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">any(i &lt; </span><span class="s5">0 </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.header):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;cannot specify multi-index header with negative integers&quot;</span>
                <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">kwds.get(</span><span class="s4">&quot;usecols&quot;</span><span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;cannot specify usecols when specifying a multi-index header&quot;</span>
                <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">kwds.get(</span><span class="s4">&quot;names&quot;</span><span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;cannot specify names when specifying a multi-index header&quot;</span>
                <span class="s1">)</span>

            <span class="s3"># validate index_col that only contains integers</span>
            <span class="s2">if </span><span class="s1">self.index_col </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">is_sequence = isinstance(self.index_col</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">np.ndarray))</span>
                <span class="s2">if not </span><span class="s1">(</span>
                    <span class="s1">is_sequence</span>
                    <span class="s2">and </span><span class="s1">all(map(is_integer</span><span class="s2">, </span><span class="s1">self.index_col))</span>
                    <span class="s2">or </span><span class="s1">is_integer(self.index_col)</span>
                <span class="s1">):</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s4">&quot;index_col must only contain row numbers &quot;</span>
                        <span class="s4">&quot;when specifying a multi-index header&quot;</span>
                    <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">self.header </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s3"># GH 27394</span>
            <span class="s2">if </span><span class="s1">self.prefix </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;Argument prefix must be None if argument header is not None&quot;</span>
                <span class="s1">)</span>
            <span class="s3"># GH 16338</span>
            <span class="s2">elif not </span><span class="s1">is_integer(self.header):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;header must be integer or list of integers&quot;</span><span class="s1">)</span>
            <span class="s3"># GH 27779</span>
            <span class="s2">elif </span><span class="s1">self.header &lt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;Passing negative integer to header is invalid. &quot;</span>
                    <span class="s4">&quot;For no header, use header=None instead&quot;</span>
                <span class="s1">)</span>

        <span class="s1">self._name_processed = </span><span class="s2">False</span>

        <span class="s1">self._first_chunk = </span><span class="s2">True</span>

        <span class="s1">self.handles: Optional[IOHandles] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">_open_handles(self</span><span class="s2">, </span><span class="s1">src: FilePathOrBuffer</span><span class="s2">, </span><span class="s1">kwds: Dict[str</span><span class="s2">, </span><span class="s1">Any]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Let the readers open IOHanldes after they are done with their potential raises. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.handles = get_handle(</span>
            <span class="s1">src</span><span class="s2">,</span>
            <span class="s4">&quot;r&quot;</span><span class="s2">,</span>
            <span class="s1">encoding=kwds.get(</span><span class="s4">&quot;encoding&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">compression=kwds.get(</span><span class="s4">&quot;compression&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">memory_map=kwds.get(</span><span class="s4">&quot;memory_map&quot;</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">storage_options=kwds.get(</span><span class="s4">&quot;storage_options&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_validate_parse_dates_presence(self</span><span class="s2">, </span><span class="s1">columns: List[str]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Check if parse_dates are in columns. 
 
        If user has provided names for parse_dates, check if those columns 
        are available. 
 
        Parameters 
        ---------- 
        columns : list 
            List of names of the dataframe. 
 
        Raises 
        ------ 
        ValueError 
            If column to parse_date is not in dataframe. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">cols_needed: Iterable</span>
        <span class="s2">if </span><span class="s1">is_dict_like(self.parse_dates):</span>
            <span class="s1">cols_needed = itertools.chain(*self.parse_dates.values())</span>
        <span class="s2">elif </span><span class="s1">is_list_like(self.parse_dates):</span>
            <span class="s3"># a column in parse_dates could be represented</span>
            <span class="s3"># ColReference = Union[int, str]</span>
            <span class="s3"># DateGroups = List[ColReference]</span>
            <span class="s3"># ParseDates = Union[DateGroups, List[DateGroups],</span>
            <span class="s3">#     Dict[ColReference, DateGroups]]</span>
            <span class="s1">cols_needed = itertools.chain.from_iterable(</span>
                <span class="s1">col </span><span class="s2">if </span><span class="s1">is_list_like(col) </span><span class="s2">else </span><span class="s1">[col] </span><span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">self.parse_dates</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">cols_needed = []</span>

        <span class="s3"># get only columns that are references using names (str), not by index</span>
        <span class="s1">missing_cols = </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
            <span class="s1">sorted(</span>
                <span class="s1">{</span>
                    <span class="s1">col</span>
                    <span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">cols_needed</span>
                    <span class="s2">if </span><span class="s1">isinstance(col</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">col </span><span class="s2">not in </span><span class="s1">columns</span>
                <span class="s1">}</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">missing_cols:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">f&quot;Missing column provided to 'parse_dates': '</span><span class="s2">{</span><span class="s1">missing_cols</span><span class="s2">}</span><span class="s4">'&quot;</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">close(self):</span>
        <span class="s2">if </span><span class="s1">self.handles </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.handles.close()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_has_complex_date_col(self):</span>
        <span class="s2">return </span><span class="s1">isinstance(self.parse_dates</span><span class="s2">, </span><span class="s1">dict) </span><span class="s2">or </span><span class="s1">(</span>
            <span class="s1">isinstance(self.parse_dates</span><span class="s2">, </span><span class="s1">list)</span>
            <span class="s2">and </span><span class="s1">len(self.parse_dates) &gt; </span><span class="s5">0</span>
            <span class="s2">and </span><span class="s1">isinstance(self.parse_dates[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">list)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_should_parse_dates(self</span><span class="s2">, </span><span class="s1">i):</span>
        <span class="s2">if </span><span class="s1">isinstance(self.parse_dates</span><span class="s2">, </span><span class="s1">bool):</span>
            <span class="s2">return </span><span class="s1">self.parse_dates</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.index_names </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">name = self.index_names[i]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">name = </span><span class="s2">None</span>
            <span class="s1">j = self.index_col[i]</span>

            <span class="s2">if </span><span class="s1">is_scalar(self.parse_dates):</span>
                <span class="s2">return </span><span class="s1">(j == self.parse_dates) </span><span class="s2">or </span><span class="s1">(</span>
                    <span class="s1">name </span><span class="s2">is not None and </span><span class="s1">name == self.parse_dates</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">(j </span><span class="s2">in </span><span class="s1">self.parse_dates) </span><span class="s2">or </span><span class="s1">(</span>
                    <span class="s1">name </span><span class="s2">is not None and </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.parse_dates</span>
                <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_extract_multi_indexer_columns(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">header</span><span class="s2">, </span><span class="s1">index_names</span><span class="s2">, </span><span class="s1">col_names</span><span class="s2">, </span><span class="s1">passed_names=</span><span class="s2">False</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        extract and return the names, index_names, col_names 
        header is a list-of-lists returned from the parsers 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len(header) &lt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">header[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index_names</span><span class="s2">, </span><span class="s1">col_names</span><span class="s2">, </span><span class="s1">passed_names</span>

        <span class="s3"># the names are the tuples of the header that are not the index cols</span>
        <span class="s3"># 0 is the name of the index, assuming index_col is a list of column</span>
        <span class="s3"># numbers</span>
        <span class="s1">ic = self.index_col</span>
        <span class="s2">if </span><span class="s1">ic </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">ic = []</span>

        <span class="s2">if not </span><span class="s1">isinstance(ic</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">np.ndarray)):</span>
            <span class="s1">ic = [ic]</span>
        <span class="s1">sic = set(ic)</span>

        <span class="s3"># clean the index_names</span>
        <span class="s1">index_names = header.pop(-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">index_names</span><span class="s2">, </span><span class="s1">names</span><span class="s2">, </span><span class="s1">index_col = _clean_index_names(</span>
            <span class="s1">index_names</span><span class="s2">, </span><span class="s1">self.index_col</span><span class="s2">, </span><span class="s1">self.unnamed_cols</span>
        <span class="s1">)</span>

        <span class="s3"># extract the columns</span>
        <span class="s1">field_count = len(header[</span><span class="s5">0</span><span class="s1">])</span>

        <span class="s2">def </span><span class="s1">extract(r):</span>
            <span class="s2">return </span><span class="s1">tuple(r[i] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(field_count) </span><span class="s2">if </span><span class="s1">i </span><span class="s2">not in </span><span class="s1">sic)</span>

        <span class="s1">columns = list(zip(*(extract(r) </span><span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">header)))</span>
        <span class="s1">names = ic + columns</span>

        <span class="s3"># If we find unnamed columns all in a single</span>
        <span class="s3"># level, then our header was too long.</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(len(columns[</span><span class="s5">0</span><span class="s1">])):</span>
            <span class="s2">if </span><span class="s1">all(ensure_str(col[n]) </span><span class="s2">in </span><span class="s1">self.unnamed_cols </span><span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">columns):</span>
                <span class="s1">header = </span><span class="s4">&quot;,&quot;</span><span class="s1">.join(str(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self.header)</span>
                <span class="s2">raise </span><span class="s1">ParserError(</span>
                    <span class="s4">f&quot;Passed header=[</span><span class="s2">{</span><span class="s1">header</span><span class="s2">}</span><span class="s4">] are too many rows &quot;</span>
                    <span class="s4">&quot;for this multi_index of columns&quot;</span>
                <span class="s1">)</span>

        <span class="s3"># Clean the column names (if we have an index_col).</span>
        <span class="s2">if </span><span class="s1">len(ic):</span>
            <span class="s1">col_names = [</span>
                <span class="s1">r[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">if </span><span class="s1">((r[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">is not None</span><span class="s1">) </span><span class="s2">and </span><span class="s1">r[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">not in </span><span class="s1">self.unnamed_cols) </span><span class="s2">else None</span>
                <span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">header</span>
            <span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">col_names = [</span><span class="s2">None</span><span class="s1">] * len(header)</span>

        <span class="s1">passed_names = </span><span class="s2">True</span>

        <span class="s2">return </span><span class="s1">names</span><span class="s2">, </span><span class="s1">index_names</span><span class="s2">, </span><span class="s1">col_names</span><span class="s2">, </span><span class="s1">passed_names</span>

    <span class="s2">def </span><span class="s1">_maybe_dedup_names(self</span><span class="s2">, </span><span class="s1">names):</span>
        <span class="s3"># see gh-7160 and gh-9424: this helps to provide</span>
        <span class="s3"># immediate alleviation of the duplicate names</span>
        <span class="s3"># issue and appears to be satisfactory to users,</span>
        <span class="s3"># but ultimately, not needing to butcher the names</span>
        <span class="s3"># would be nice!</span>
        <span class="s2">if </span><span class="s1">self.mangle_dupe_cols:</span>
            <span class="s1">names = list(names)  </span><span class="s3"># so we can index</span>
            <span class="s3"># pandas\io\parsers.py:1559: error: Need type annotation for</span>
            <span class="s3"># 'counts'  [var-annotated]</span>
            <span class="s1">counts = defaultdict(int)  </span><span class="s3"># type: ignore[var-annotated]</span>
            <span class="s1">is_potential_mi = _is_potential_multi_index(names</span><span class="s2">, </span><span class="s1">self.index_col)</span>

            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">col </span><span class="s2">in </span><span class="s1">enumerate(names):</span>
                <span class="s1">cur_count = counts[col]</span>

                <span class="s2">while </span><span class="s1">cur_count &gt; </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">counts[col] = cur_count + </span><span class="s5">1</span>

                    <span class="s2">if </span><span class="s1">is_potential_mi:</span>
                        <span class="s1">col = col[:-</span><span class="s5">1</span><span class="s1">] + (</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">col[-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">}</span><span class="s4">.</span><span class="s2">{</span><span class="s1">cur_count</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s2">,</span><span class="s1">)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">col = </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">col</span><span class="s2">}</span><span class="s4">.</span><span class="s2">{</span><span class="s1">cur_count</span><span class="s2">}</span><span class="s4">&quot;</span>
                    <span class="s1">cur_count = counts[col]</span>

                <span class="s1">names[i] = col</span>
                <span class="s1">counts[col] = cur_count + </span><span class="s5">1</span>

        <span class="s2">return </span><span class="s1">names</span>

    <span class="s2">def </span><span class="s1">_maybe_make_multi_index_columns(self</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">col_names=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s3"># possibly create a column mi here</span>
        <span class="s2">if </span><span class="s1">_is_potential_multi_index(columns):</span>
            <span class="s1">columns = MultiIndex.from_tuples(columns</span><span class="s2">, </span><span class="s1">names=col_names)</span>
        <span class="s2">return </span><span class="s1">columns</span>

    <span class="s2">def </span><span class="s1">_make_index(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">alldata</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">indexnamerow=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s2">if not </span><span class="s1">_is_index_col(self.index_col) </span><span class="s2">or not </span><span class="s1">self.index_col:</span>
            <span class="s1">index = </span><span class="s2">None</span>

        <span class="s2">elif not </span><span class="s1">self._has_complex_date_col:</span>
            <span class="s1">index = self._get_simple_index(alldata</span><span class="s2">, </span><span class="s1">columns)</span>
            <span class="s1">index = self._agg_index(index)</span>
        <span class="s2">elif </span><span class="s1">self._has_complex_date_col:</span>
            <span class="s2">if not </span><span class="s1">self._name_processed:</span>
                <span class="s1">(self.index_names</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">self.index_col) = _clean_index_names(</span>
                    <span class="s1">list(columns)</span><span class="s2">, </span><span class="s1">self.index_col</span><span class="s2">, </span><span class="s1">self.unnamed_cols</span>
                <span class="s1">)</span>
                <span class="s1">self._name_processed = </span><span class="s2">True</span>
            <span class="s1">index = self._get_complex_date_index(data</span><span class="s2">, </span><span class="s1">columns)</span>
            <span class="s1">index = self._agg_index(index</span><span class="s2">, </span><span class="s1">try_parse_dates=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s3"># add names for the index</span>
        <span class="s2">if </span><span class="s1">indexnamerow:</span>
            <span class="s1">coffset = len(indexnamerow) - len(columns)</span>
            <span class="s3"># pandas\io\parsers.py:1604: error: Item &quot;None&quot; of &quot;Optional[Any]&quot;</span>
            <span class="s3"># has no attribute &quot;set_names&quot;  [union-attr]</span>
            <span class="s1">index = index.set_names(indexnamerow[:coffset])  </span><span class="s3"># type: ignore[union-attr]</span>

        <span class="s3"># maybe create a mi on the columns</span>
        <span class="s1">columns = self._maybe_make_multi_index_columns(columns</span><span class="s2">, </span><span class="s1">self.col_names)</span>

        <span class="s2">return </span><span class="s1">index</span><span class="s2">, </span><span class="s1">columns</span>

    <span class="s1">_implicit_index = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">_get_simple_index(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">columns):</span>
        <span class="s2">def </span><span class="s1">ix(col):</span>
            <span class="s2">if not </span><span class="s1">isinstance(col</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s2">return </span><span class="s1">col</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Index </span><span class="s2">{</span><span class="s1">col</span><span class="s2">} </span><span class="s4">invalid&quot;</span><span class="s1">)</span>

        <span class="s1">to_remove = []</span>
        <span class="s1">index = []</span>
        <span class="s2">for </span><span class="s1">idx </span><span class="s2">in </span><span class="s1">self.index_col:</span>
            <span class="s1">i = ix(idx)</span>
            <span class="s1">to_remove.append(i)</span>
            <span class="s1">index.append(data[i])</span>

        <span class="s3"># remove index items from content and columns, don't pop in</span>
        <span class="s3"># loop</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">sorted(to_remove</span><span class="s2">, </span><span class="s1">reverse=</span><span class="s2">True</span><span class="s1">):</span>
            <span class="s1">data.pop(i)</span>
            <span class="s2">if not </span><span class="s1">self._implicit_index:</span>
                <span class="s1">columns.pop(i)</span>

        <span class="s2">return </span><span class="s1">index</span>

    <span class="s2">def </span><span class="s1">_get_complex_date_index(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">col_names):</span>
        <span class="s2">def </span><span class="s1">_get_name(icol):</span>
            <span class="s2">if </span><span class="s1">isinstance(icol</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s2">return </span><span class="s1">icol</span>

            <span class="s2">if </span><span class="s1">col_names </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Must supply column order to use </span><span class="s2">{</span><span class="s1">icol</span><span class="s2">!s} </span><span class="s4">as index&quot;</span><span class="s1">)</span>

            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">c </span><span class="s2">in </span><span class="s1">enumerate(col_names):</span>
                <span class="s2">if </span><span class="s1">i == icol:</span>
                    <span class="s2">return </span><span class="s1">c</span>

        <span class="s1">to_remove = []</span>
        <span class="s1">index = []</span>
        <span class="s2">for </span><span class="s1">idx </span><span class="s2">in </span><span class="s1">self.index_col:</span>
            <span class="s1">name = _get_name(idx)</span>
            <span class="s1">to_remove.append(name)</span>
            <span class="s1">index.append(data[name])</span>

        <span class="s3"># remove index items from content and columns, don't pop in</span>
        <span class="s3"># loop</span>
        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">sorted(to_remove</span><span class="s2">, </span><span class="s1">reverse=</span><span class="s2">True</span><span class="s1">):</span>
            <span class="s1">data.pop(c)</span>
            <span class="s1">col_names.remove(c)</span>

        <span class="s2">return </span><span class="s1">index</span>

    <span class="s2">def </span><span class="s1">_agg_index(self</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">try_parse_dates=</span><span class="s2">True</span><span class="s1">) -&gt; Index:</span>
        <span class="s1">arrays = []</span>

        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">enumerate(index):</span>

            <span class="s2">if </span><span class="s1">try_parse_dates </span><span class="s2">and </span><span class="s1">self._should_parse_dates(i):</span>
                <span class="s1">arr = self._date_conv(arr)</span>

            <span class="s2">if </span><span class="s1">self.na_filter:</span>
                <span class="s1">col_na_values = self.na_values</span>
                <span class="s1">col_na_fvalues = self.na_fvalues</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">col_na_values = set()</span>
                <span class="s1">col_na_fvalues = set()</span>

            <span class="s2">if </span><span class="s1">isinstance(self.na_values</span><span class="s2">, </span><span class="s1">dict):</span>
                <span class="s3"># pandas\io\parsers.py:1678: error: Value of type</span>
                <span class="s3"># &quot;Optional[Any]&quot; is not indexable  [index]</span>
                <span class="s1">col_name = self.index_names[i]  </span><span class="s3"># type: ignore[index]</span>
                <span class="s2">if </span><span class="s1">col_name </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">col_na_values</span><span class="s2">, </span><span class="s1">col_na_fvalues = _get_na_values(</span>
                        <span class="s1">col_name</span><span class="s2">, </span><span class="s1">self.na_values</span><span class="s2">, </span><span class="s1">self.na_fvalues</span><span class="s2">, </span><span class="s1">self.keep_default_na</span>
                    <span class="s1">)</span>

            <span class="s1">arr</span><span class="s2">, </span><span class="s1">_ = self._infer_types(arr</span><span class="s2">, </span><span class="s1">col_na_values | col_na_fvalues)</span>
            <span class="s1">arrays.append(arr)</span>

        <span class="s1">names = self.index_names</span>
        <span class="s1">index = ensure_index_from_sequences(arrays</span><span class="s2">, </span><span class="s1">names)</span>

        <span class="s2">return </span><span class="s1">index</span>

    <span class="s2">def </span><span class="s1">_convert_to_ndarrays(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">dct</span><span class="s2">, </span><span class="s1">na_values</span><span class="s2">, </span><span class="s1">na_fvalues</span><span class="s2">, </span><span class="s1">verbose=</span><span class="s2">False, </span><span class="s1">converters=</span><span class="s2">None, </span><span class="s1">dtypes=</span><span class="s2">None</span>
    <span class="s1">):</span>
        <span class="s1">result = {}</span>
        <span class="s2">for </span><span class="s1">c</span><span class="s2">, </span><span class="s1">values </span><span class="s2">in </span><span class="s1">dct.items():</span>
            <span class="s1">conv_f = </span><span class="s2">None if </span><span class="s1">converters </span><span class="s2">is None else </span><span class="s1">converters.get(c</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">isinstance(dtypes</span><span class="s2">, </span><span class="s1">dict):</span>
                <span class="s1">cast_type = dtypes.get(c</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s3"># single dtype or None</span>
                <span class="s1">cast_type = dtypes</span>

            <span class="s2">if </span><span class="s1">self.na_filter:</span>
                <span class="s1">col_na_values</span><span class="s2">, </span><span class="s1">col_na_fvalues = _get_na_values(</span>
                    <span class="s1">c</span><span class="s2">, </span><span class="s1">na_values</span><span class="s2">, </span><span class="s1">na_fvalues</span><span class="s2">, </span><span class="s1">self.keep_default_na</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">col_na_values</span><span class="s2">, </span><span class="s1">col_na_fvalues = set()</span><span class="s2">, </span><span class="s1">set()</span>

            <span class="s2">if </span><span class="s1">conv_f </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s3"># conv_f applied to data before inference</span>
                <span class="s2">if </span><span class="s1">cast_type </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">warnings.warn(</span>
                        <span class="s1">(</span>
                            <span class="s4">&quot;Both a converter and dtype were specified &quot;</span>
                            <span class="s4">f&quot;for column </span><span class="s2">{</span><span class="s1">c</span><span class="s2">} </span><span class="s4">- only the converter will be used&quot;</span>
                        <span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">ParserWarning</span><span class="s2">,</span>
                        <span class="s1">stacklevel=</span><span class="s5">7</span><span class="s2">,</span>
                    <span class="s1">)</span>

                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">values = lib.map_infer(values</span><span class="s2">, </span><span class="s1">conv_f)</span>
                <span class="s2">except </span><span class="s1">ValueError:</span>
                    <span class="s1">mask = algorithms.isin(values</span><span class="s2">, </span><span class="s1">list(na_values)).view(np.uint8)</span>
                    <span class="s1">values = lib.map_infer_mask(values</span><span class="s2">, </span><span class="s1">conv_f</span><span class="s2">, </span><span class="s1">mask)</span>

                <span class="s1">cvals</span><span class="s2">, </span><span class="s1">na_count = self._infer_types(</span>
                    <span class="s1">values</span><span class="s2">, </span><span class="s1">set(col_na_values) | col_na_fvalues</span><span class="s2">, </span><span class="s1">try_num_bool=</span><span class="s2">False</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">is_ea = is_extension_array_dtype(cast_type)</span>
                <span class="s1">is_str_or_ea_dtype = is_ea </span><span class="s2">or </span><span class="s1">is_string_dtype(cast_type)</span>
                <span class="s3"># skip inference if specified dtype is object</span>
                <span class="s3"># or casting to an EA</span>
                <span class="s1">try_num_bool = </span><span class="s2">not </span><span class="s1">(cast_type </span><span class="s2">and </span><span class="s1">is_str_or_ea_dtype)</span>

                <span class="s3"># general type inference and conversion</span>
                <span class="s1">cvals</span><span class="s2">, </span><span class="s1">na_count = self._infer_types(</span>
                    <span class="s1">values</span><span class="s2">, </span><span class="s1">set(col_na_values) | col_na_fvalues</span><span class="s2">, </span><span class="s1">try_num_bool</span>
                <span class="s1">)</span>

                <span class="s3"># type specified in dtype param or cast_type is an EA</span>
                <span class="s2">if </span><span class="s1">cast_type </span><span class="s2">and </span><span class="s1">(</span>
                    <span class="s2">not </span><span class="s1">is_dtype_equal(cvals</span><span class="s2">, </span><span class="s1">cast_type)</span>
                    <span class="s2">or </span><span class="s1">is_extension_array_dtype(cast_type)</span>
                <span class="s1">):</span>
                    <span class="s2">if not </span><span class="s1">is_ea </span><span class="s2">and </span><span class="s1">na_count &gt; </span><span class="s5">0</span><span class="s1">:</span>
                        <span class="s2">try</span><span class="s1">:</span>
                            <span class="s2">if </span><span class="s1">is_bool_dtype(cast_type):</span>
                                <span class="s2">raise </span><span class="s1">ValueError(</span>
                                    <span class="s4">f&quot;Bool column has NA values in column </span><span class="s2">{</span><span class="s1">c</span><span class="s2">}</span><span class="s4">&quot;</span>
                                <span class="s1">)</span>
                        <span class="s2">except </span><span class="s1">(AttributeError</span><span class="s2">, </span><span class="s1">TypeError):</span>
                            <span class="s3"># invalid input to is_bool_dtype</span>
                            <span class="s2">pass</span>
                    <span class="s1">cvals = self._cast_types(cvals</span><span class="s2">, </span><span class="s1">cast_type</span><span class="s2">, </span><span class="s1">c)</span>

            <span class="s1">result[c] = cvals</span>
            <span class="s2">if </span><span class="s1">verbose </span><span class="s2">and </span><span class="s1">na_count:</span>
                <span class="s1">print(</span><span class="s4">f&quot;Filled </span><span class="s2">{</span><span class="s1">na_count</span><span class="s2">} </span><span class="s4">NA values in column </span><span class="s2">{</span><span class="s1">c</span><span class="s2">!s}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">_infer_types(self</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">na_values</span><span class="s2">, </span><span class="s1">try_num_bool=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Infer types of values, possibly casting 
 
        Parameters 
        ---------- 
        values : ndarray 
        na_values : set 
        try_num_bool : bool, default try 
           try to cast values to numeric (first preference) or boolean 
 
        Returns 
        ------- 
        converted : ndarray 
        na_count : int 
        &quot;&quot;&quot;</span>
        <span class="s1">na_count = </span><span class="s5">0</span>
        <span class="s2">if </span><span class="s1">issubclass(values.dtype.type</span><span class="s2">, </span><span class="s1">(np.number</span><span class="s2">, </span><span class="s1">np.bool_)):</span>
            <span class="s1">mask = algorithms.isin(values</span><span class="s2">, </span><span class="s1">list(na_values))</span>
            <span class="s1">na_count = mask.sum()</span>
            <span class="s2">if </span><span class="s1">na_count &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">is_integer_dtype(values):</span>
                    <span class="s1">values = values.astype(np.float64)</span>
                <span class="s1">np.putmask(values</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">np.nan)</span>
            <span class="s2">return </span><span class="s1">values</span><span class="s2">, </span><span class="s1">na_count</span>

        <span class="s2">if </span><span class="s1">try_num_bool </span><span class="s2">and </span><span class="s1">is_object_dtype(values.dtype):</span>
            <span class="s3"># exclude e.g DatetimeIndex here</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">result = lib.maybe_convert_numeric(values</span><span class="s2">, </span><span class="s1">na_values</span><span class="s2">, False</span><span class="s1">)</span>
            <span class="s2">except </span><span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">TypeError):</span>
                <span class="s3"># e.g. encountering datetime string gets ValueError</span>
                <span class="s3">#  TypeError can be raised in floatify</span>
                <span class="s1">result = values</span>
                <span class="s1">na_count = parsers.sanitize_objects(result</span><span class="s2">, </span><span class="s1">na_values</span><span class="s2">, False</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">na_count = isna(result).sum()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">result = values</span>
            <span class="s2">if </span><span class="s1">values.dtype == np.object_:</span>
                <span class="s1">na_count = parsers.sanitize_objects(values</span><span class="s2">, </span><span class="s1">na_values</span><span class="s2">, False</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">result.dtype == np.object_ </span><span class="s2">and </span><span class="s1">try_num_bool:</span>
            <span class="s1">result = libops.maybe_convert_bool(</span>
                <span class="s1">np.asarray(values)</span><span class="s2">,</span>
                <span class="s1">true_values=self.true_values</span><span class="s2">,</span>
                <span class="s1">false_values=self.false_values</span><span class="s2">,</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">result</span><span class="s2">, </span><span class="s1">na_count</span>

    <span class="s2">def </span><span class="s1">_cast_types(self</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">cast_type</span><span class="s2">, </span><span class="s1">column):</span>
        <span class="s0">&quot;&quot;&quot; 
        Cast values to specified type 
 
        Parameters 
        ---------- 
        values : ndarray 
        cast_type : string or np.dtype 
           dtype to cast values to 
        column : string 
            column name - used only for error reporting 
 
        Returns 
        ------- 
        converted : ndarray 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">is_categorical_dtype(cast_type):</span>
            <span class="s1">known_cats = (</span>
                <span class="s1">isinstance(cast_type</span><span class="s2">, </span><span class="s1">CategoricalDtype)</span>
                <span class="s2">and </span><span class="s1">cast_type.categories </span><span class="s2">is not None</span>
            <span class="s1">)</span>

            <span class="s2">if not </span><span class="s1">is_object_dtype(values) </span><span class="s2">and not </span><span class="s1">known_cats:</span>
                <span class="s3"># TODO: this is for consistency with</span>
                <span class="s3"># c-parser which parses all categories</span>
                <span class="s3"># as strings</span>
                <span class="s1">values = astype_nansafe(values</span><span class="s2">, </span><span class="s1">str)</span>

            <span class="s1">cats = Index(values).unique().dropna()</span>
            <span class="s1">values = Categorical._from_inferred_categories(</span>
                <span class="s1">cats</span><span class="s2">, </span><span class="s1">cats.get_indexer(values)</span><span class="s2">, </span><span class="s1">cast_type</span><span class="s2">, </span><span class="s1">true_values=self.true_values</span>
            <span class="s1">)</span>

        <span class="s3"># use the EA's implementation of casting</span>
        <span class="s2">elif </span><span class="s1">is_extension_array_dtype(cast_type):</span>
            <span class="s3"># ensure cast_type is an actual dtype and not a string</span>
            <span class="s1">cast_type = pandas_dtype(cast_type)</span>
            <span class="s1">array_type = cast_type.construct_array_type()</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">array_type._from_sequence_of_strings(values</span><span class="s2">, </span><span class="s1">dtype=cast_type)</span>
            <span class="s2">except </span><span class="s1">NotImplementedError </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s2">raise </span><span class="s1">NotImplementedError(</span>
                    <span class="s4">f&quot;Extension Array: </span><span class="s2">{</span><span class="s1">array_type</span><span class="s2">} </span><span class="s4">must implement &quot;</span>
                    <span class="s4">&quot;_from_sequence_of_strings in order to be used in parser methods&quot;</span>
                <span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">values = astype_nansafe(values</span><span class="s2">, </span><span class="s1">cast_type</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True, </span><span class="s1">skipna=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">f&quot;Unable to convert column </span><span class="s2">{</span><span class="s1">column</span><span class="s2">} </span><span class="s4">to type </span><span class="s2">{</span><span class="s1">cast_type</span><span class="s2">}</span><span class="s4">&quot;</span>
                <span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>
        <span class="s2">return </span><span class="s1">values</span>

    <span class="s2">def </span><span class="s1">_do_date_conversions(self</span><span class="s2">, </span><span class="s1">names</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s3"># returns data, columns</span>

        <span class="s2">if </span><span class="s1">self.parse_dates </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">data</span><span class="s2">, </span><span class="s1">names = _process_date_conversion(</span>
                <span class="s1">data</span><span class="s2">,</span>
                <span class="s1">self._date_conv</span><span class="s2">,</span>
                <span class="s1">self.parse_dates</span><span class="s2">,</span>
                <span class="s1">self.index_col</span><span class="s2">,</span>
                <span class="s1">self.index_names</span><span class="s2">,</span>
                <span class="s1">names</span><span class="s2">,</span>
                <span class="s1">keep_date_col=self.keep_date_col</span><span class="s2">,</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">names</span><span class="s2">, </span><span class="s1">data</span>


<span class="s2">class </span><span class="s1">CParserWrapper(ParserBase):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">src: FilePathOrBuffer</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s1">self.kwds = kwds</span>
        <span class="s1">kwds = kwds.copy()</span>

        <span class="s1">ParserBase.__init__(self</span><span class="s2">, </span><span class="s1">kwds)</span>

        <span class="s3"># #2442</span>
        <span class="s1">kwds[</span><span class="s4">&quot;allow_leading_cols&quot;</span><span class="s1">] = self.index_col </span><span class="s2">is not False</span>

        <span class="s3"># GH20529, validate usecol arg before TextReader</span>
        <span class="s1">self.usecols</span><span class="s2">, </span><span class="s1">self.usecols_dtype = _validate_usecols_arg(kwds[</span><span class="s4">&quot;usecols&quot;</span><span class="s1">])</span>
        <span class="s1">kwds[</span><span class="s4">&quot;usecols&quot;</span><span class="s1">] = self.usecols</span>

        <span class="s3"># open handles</span>
        <span class="s1">self._open_handles(src</span><span class="s2">, </span><span class="s1">kwds)</span>
        <span class="s2">assert </span><span class="s1">self.handles </span><span class="s2">is not None</span>
        <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">(</span><span class="s4">&quot;storage_options&quot;</span><span class="s2">, </span><span class="s4">&quot;encoding&quot;</span><span class="s2">, </span><span class="s4">&quot;memory_map&quot;</span><span class="s2">, </span><span class="s4">&quot;compression&quot;</span><span class="s1">):</span>
            <span class="s1">kwds.pop(key</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.handles.is_mmap </span><span class="s2">and </span><span class="s1">hasattr(self.handles.handle</span><span class="s2">, </span><span class="s4">&quot;mmap&quot;</span><span class="s1">):</span>
            <span class="s3"># pandas\io\parsers.py:1861: error: Item &quot;IO[Any]&quot; of</span>
            <span class="s3"># &quot;Union[IO[Any], RawIOBase, BufferedIOBase, TextIOBase,</span>
            <span class="s3"># TextIOWrapper, mmap]&quot; has no attribute &quot;mmap&quot;  [union-attr]</span>

            <span class="s3"># pandas\io\parsers.py:1861: error: Item &quot;RawIOBase&quot; of</span>
            <span class="s3"># &quot;Union[IO[Any], RawIOBase, BufferedIOBase, TextIOBase,</span>
            <span class="s3"># TextIOWrapper, mmap]&quot; has no attribute &quot;mmap&quot;  [union-attr]</span>

            <span class="s3"># pandas\io\parsers.py:1861: error: Item &quot;BufferedIOBase&quot; of</span>
            <span class="s3"># &quot;Union[IO[Any], RawIOBase, BufferedIOBase, TextIOBase,</span>
            <span class="s3"># TextIOWrapper, mmap]&quot; has no attribute &quot;mmap&quot;  [union-attr]</span>

            <span class="s3"># pandas\io\parsers.py:1861: error: Item &quot;TextIOBase&quot; of</span>
            <span class="s3"># &quot;Union[IO[Any], RawIOBase, BufferedIOBase, TextIOBase,</span>
            <span class="s3"># TextIOWrapper, mmap]&quot; has no attribute &quot;mmap&quot;  [union-attr]</span>

            <span class="s3"># pandas\io\parsers.py:1861: error: Item &quot;TextIOWrapper&quot; of</span>
            <span class="s3"># &quot;Union[IO[Any], RawIOBase, BufferedIOBase, TextIOBase,</span>
            <span class="s3"># TextIOWrapper, mmap]&quot; has no attribute &quot;mmap&quot;  [union-attr]</span>

            <span class="s3"># pandas\io\parsers.py:1861: error: Item &quot;mmap&quot; of &quot;Union[IO[Any],</span>
            <span class="s3"># RawIOBase, BufferedIOBase, TextIOBase, TextIOWrapper, mmap]&quot; has</span>
            <span class="s3"># no attribute &quot;mmap&quot;  [union-attr]</span>
            <span class="s1">self.handles.handle = self.handles.handle.mmap  </span><span class="s3"># type: ignore[union-attr]</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self._reader = parsers.TextReader(self.handles.handle</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s1">self.handles.close()</span>
            <span class="s2">raise</span>
        <span class="s1">self.unnamed_cols = self._reader.unnamed_cols</span>

        <span class="s1">passed_names = self.names </span><span class="s2">is None</span>

        <span class="s2">if </span><span class="s1">self._reader.header </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.names = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">len(self._reader.header) &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s3"># we have a multi index in the columns</span>
                <span class="s1">(</span>
                    <span class="s1">self.names</span><span class="s2">,</span>
                    <span class="s1">self.index_names</span><span class="s2">,</span>
                    <span class="s1">self.col_names</span><span class="s2">,</span>
                    <span class="s1">passed_names</span><span class="s2">,</span>
                <span class="s1">) = self._extract_multi_indexer_columns(</span>
                    <span class="s1">self._reader.header</span><span class="s2">, </span><span class="s1">self.index_names</span><span class="s2">, </span><span class="s1">self.col_names</span><span class="s2">, </span><span class="s1">passed_names</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.names = list(self._reader.header[</span><span class="s5">0</span><span class="s1">])</span>

        <span class="s2">if </span><span class="s1">self.names </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.prefix:</span>
                <span class="s1">self.names = [</span>
                    <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">self.prefix</span><span class="s2">}{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">&quot; </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self._reader.table_width)</span>
                <span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.names = list(range(self._reader.table_width))</span>

        <span class="s3"># gh-9755</span>
        <span class="s3">#</span>
        <span class="s3"># need to set orig_names here first</span>
        <span class="s3"># so that proper indexing can be done</span>
        <span class="s3"># with _set_noconvert_columns</span>
        <span class="s3">#</span>
        <span class="s3"># once names has been filtered, we will</span>
        <span class="s3"># then set orig_names again to names</span>
        <span class="s1">self.orig_names = self.names[:]</span>

        <span class="s2">if </span><span class="s1">self.usecols:</span>
            <span class="s1">usecols = _evaluate_usecols(self.usecols</span><span class="s2">, </span><span class="s1">self.orig_names)</span>

            <span class="s3"># GH 14671</span>
            <span class="s3"># assert for mypy, orig_names is List or None, None would error in issubset</span>
            <span class="s2">assert </span><span class="s1">self.orig_names </span><span class="s2">is not None</span>
            <span class="s2">if </span><span class="s1">self.usecols_dtype == </span><span class="s4">&quot;string&quot; </span><span class="s2">and not </span><span class="s1">set(usecols).issubset(</span>
                <span class="s1">self.orig_names</span>
            <span class="s1">):</span>
                <span class="s1">_validate_usecols_names(usecols</span><span class="s2">, </span><span class="s1">self.orig_names)</span>

            <span class="s2">if </span><span class="s1">len(self.names) &gt; len(usecols):</span>
                <span class="s1">self.names = [</span>
                    <span class="s1">n</span>
                    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">n </span><span class="s2">in </span><span class="s1">enumerate(self.names)</span>
                    <span class="s2">if </span><span class="s1">(i </span><span class="s2">in </span><span class="s1">usecols </span><span class="s2">or </span><span class="s1">n </span><span class="s2">in </span><span class="s1">usecols)</span>
                <span class="s1">]</span>

            <span class="s2">if </span><span class="s1">len(self.names) &lt; len(usecols):</span>
                <span class="s1">_validate_usecols_names(usecols</span><span class="s2">, </span><span class="s1">self.names)</span>

        <span class="s1">self._validate_parse_dates_presence(self.names)</span>
        <span class="s1">self._set_noconvert_columns()</span>

        <span class="s1">self.orig_names = self.names</span>

        <span class="s2">if not </span><span class="s1">self._has_complex_date_col:</span>
            <span class="s2">if </span><span class="s1">self._reader.leading_cols == </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">_is_index_col(self.index_col):</span>

                <span class="s1">self._name_processed = </span><span class="s2">True</span>
                <span class="s1">(index_names</span><span class="s2">, </span><span class="s1">self.names</span><span class="s2">, </span><span class="s1">self.index_col) = _clean_index_names(</span>
                    <span class="s1">self.names</span><span class="s2">, </span><span class="s1">self.index_col</span><span class="s2">, </span><span class="s1">self.unnamed_cols</span>
                <span class="s1">)</span>

                <span class="s2">if </span><span class="s1">self.index_names </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">self.index_names = index_names</span>

            <span class="s2">if </span><span class="s1">self._reader.header </span><span class="s2">is None and not </span><span class="s1">passed_names:</span>
                <span class="s3"># pandas\io\parsers.py:1997: error: Argument 1 to &quot;len&quot; has</span>
                <span class="s3"># incompatible type &quot;Optional[Any]&quot;; expected &quot;Sized&quot;</span>
                <span class="s3"># [arg-type]</span>
                <span class="s1">self.index_names = [</span><span class="s2">None</span><span class="s1">] * len(</span>
                    <span class="s1">self.index_names  </span><span class="s3"># type: ignore[arg-type]</span>
                <span class="s1">)</span>

        <span class="s1">self._implicit_index = self._reader.leading_cols &gt; </span><span class="s5">0</span>

    <span class="s2">def </span><span class="s1">close(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">super().close()</span>

        <span class="s3"># close additional handles opened by C parser</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self._reader.close()</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">_set_noconvert_columns(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the columns that should not undergo dtype conversions. 
 
        Currently, any column that is involved with date parsing will not 
        undergo such conversions. 
        &quot;&quot;&quot;</span>
        <span class="s1">names = self.orig_names</span>
        <span class="s2">if </span><span class="s1">self.usecols_dtype == </span><span class="s4">&quot;integer&quot;</span><span class="s1">:</span>
            <span class="s3"># A set of integers will be converted to a list in</span>
            <span class="s3"># the correct order every single time.</span>
            <span class="s1">usecols = list(self.usecols)</span>
            <span class="s1">usecols.sort()</span>
        <span class="s2">elif </span><span class="s1">callable(self.usecols) </span><span class="s2">or </span><span class="s1">self.usecols_dtype </span><span class="s2">not in </span><span class="s1">(</span><span class="s4">&quot;empty&quot;</span><span class="s2">, None</span><span class="s1">):</span>
            <span class="s3"># The names attribute should have the correct columns</span>
            <span class="s3"># in the proper order for indexing with parse_dates.</span>
            <span class="s1">usecols = self.names[:]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># Usecols is empty.</span>

            <span class="s3"># pandas\io\parsers.py:2030: error: Incompatible types in</span>
            <span class="s3"># assignment (expression has type &quot;None&quot;, variable has type</span>
            <span class="s3"># &quot;List[Any]&quot;)  [assignment]</span>
            <span class="s1">usecols = </span><span class="s2">None  </span><span class="s3"># type: ignore[assignment]</span>

        <span class="s2">def </span><span class="s1">_set(x):</span>
            <span class="s2">if </span><span class="s1">usecols </span><span class="s2">is not None and </span><span class="s1">is_integer(x):</span>
                <span class="s1">x = usecols[x]</span>

            <span class="s2">if not </span><span class="s1">is_integer(x):</span>
                <span class="s3"># assert for mypy, names is List or None, None would error when calling</span>
                <span class="s3"># .index()</span>
                <span class="s2">assert </span><span class="s1">names </span><span class="s2">is not None</span>
                <span class="s1">x = names.index(x)</span>

            <span class="s1">self._reader.set_noconvert(x)</span>

        <span class="s2">if </span><span class="s1">isinstance(self.parse_dates</span><span class="s2">, </span><span class="s1">list):</span>
            <span class="s2">for </span><span class="s1">val </span><span class="s2">in </span><span class="s1">self.parse_dates:</span>
                <span class="s2">if </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">list):</span>
                    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">val:</span>
                        <span class="s1">_set(k)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">_set(val)</span>

        <span class="s2">elif </span><span class="s1">isinstance(self.parse_dates</span><span class="s2">, </span><span class="s1">dict):</span>
            <span class="s2">for </span><span class="s1">val </span><span class="s2">in </span><span class="s1">self.parse_dates.values():</span>
                <span class="s2">if </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">list):</span>
                    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">val:</span>
                        <span class="s1">_set(k)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">_set(val)</span>

        <span class="s2">elif </span><span class="s1">self.parse_dates:</span>
            <span class="s2">if </span><span class="s1">isinstance(self.index_col</span><span class="s2">, </span><span class="s1">list):</span>
                <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">self.index_col:</span>
                    <span class="s1">_set(k)</span>
            <span class="s2">elif </span><span class="s1">self.index_col </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">_set(self.index_col)</span>

    <span class="s2">def </span><span class="s1">set_error_bad_lines(self</span><span class="s2">, </span><span class="s1">status):</span>
        <span class="s1">self._reader.set_error_bad_lines(int(status))</span>

    <span class="s2">def </span><span class="s1">read(self</span><span class="s2">, </span><span class="s1">nrows=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">data = self._reader.read(nrows)</span>
        <span class="s2">except </span><span class="s1">StopIteration:</span>
            <span class="s2">if </span><span class="s1">self._first_chunk:</span>
                <span class="s1">self._first_chunk = </span><span class="s2">False</span>
                <span class="s1">names = self._maybe_dedup_names(self.orig_names)</span>
                <span class="s1">index</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">col_dict = _get_empty_meta(</span>
                    <span class="s1">names</span><span class="s2">,</span>
                    <span class="s1">self.index_col</span><span class="s2">,</span>
                    <span class="s1">self.index_names</span><span class="s2">,</span>
                    <span class="s1">dtype=self.kwds.get(</span><span class="s4">&quot;dtype&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">)</span>
                <span class="s1">columns = self._maybe_make_multi_index_columns(columns</span><span class="s2">, </span><span class="s1">self.col_names)</span>

                <span class="s2">if </span><span class="s1">self.usecols </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">columns = self._filter_usecols(columns)</span>

                <span class="s1">col_dict = {k: v </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">col_dict.items() </span><span class="s2">if </span><span class="s1">k </span><span class="s2">in </span><span class="s1">columns}</span>

                <span class="s2">return </span><span class="s1">index</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">col_dict</span>

            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.close()</span>
                <span class="s2">raise</span>

        <span class="s3"># Done with first read, next time raise StopIteration</span>
        <span class="s1">self._first_chunk = </span><span class="s2">False</span>

        <span class="s1">names = self.names</span>

        <span class="s2">if </span><span class="s1">self._reader.leading_cols:</span>
            <span class="s2">if </span><span class="s1">self._has_complex_date_col:</span>
                <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;file structure not yet supported&quot;</span><span class="s1">)</span>

            <span class="s3"># implicit index, no index names</span>
            <span class="s1">arrays = []</span>

            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self._reader.leading_cols):</span>
                <span class="s2">if </span><span class="s1">self.index_col </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">values = data.pop(i)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">values = data.pop(self.index_col[i])</span>

                <span class="s1">values = self._maybe_parse_dates(values</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">try_parse_dates=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s1">arrays.append(values)</span>

            <span class="s1">index = ensure_index_from_sequences(arrays)</span>

            <span class="s2">if </span><span class="s1">self.usecols </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">names = self._filter_usecols(names)</span>

            <span class="s1">names = self._maybe_dedup_names(names)</span>

            <span class="s3"># rename dict keys</span>
            <span class="s1">data = sorted(data.items())</span>
            <span class="s1">data = {k: v </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">(i</span><span class="s2">, </span><span class="s1">v) </span><span class="s2">in </span><span class="s1">zip(names</span><span class="s2">, </span><span class="s1">data)}</span>

            <span class="s1">names</span><span class="s2">, </span><span class="s1">data = self._do_date_conversions(names</span><span class="s2">, </span><span class="s1">data)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># rename dict keys</span>
            <span class="s1">data = sorted(data.items())</span>

            <span class="s3"># ugh, mutation</span>

            <span class="s3"># assert for mypy, orig_names is List or None, None would error in list(...)</span>
            <span class="s2">assert </span><span class="s1">self.orig_names </span><span class="s2">is not None</span>
            <span class="s1">names = list(self.orig_names)</span>
            <span class="s1">names = self._maybe_dedup_names(names)</span>

            <span class="s2">if </span><span class="s1">self.usecols </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">names = self._filter_usecols(names)</span>

            <span class="s3"># columns as list</span>
            <span class="s1">alldata = [x[</span><span class="s5">1</span><span class="s1">] </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">data]</span>

            <span class="s1">data = {k: v </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">(i</span><span class="s2">, </span><span class="s1">v) </span><span class="s2">in </span><span class="s1">zip(names</span><span class="s2">, </span><span class="s1">data)}</span>

            <span class="s1">names</span><span class="s2">, </span><span class="s1">data = self._do_date_conversions(names</span><span class="s2">, </span><span class="s1">data)</span>
            <span class="s1">index</span><span class="s2">, </span><span class="s1">names = self._make_index(data</span><span class="s2">, </span><span class="s1">alldata</span><span class="s2">, </span><span class="s1">names)</span>

        <span class="s3"># maybe create a mi on the columns</span>
        <span class="s1">names = self._maybe_make_multi_index_columns(names</span><span class="s2">, </span><span class="s1">self.col_names)</span>

        <span class="s2">return </span><span class="s1">index</span><span class="s2">, </span><span class="s1">names</span><span class="s2">, </span><span class="s1">data</span>

    <span class="s2">def </span><span class="s1">_filter_usecols(self</span><span class="s2">, </span><span class="s1">names):</span>
        <span class="s3"># hackish</span>
        <span class="s1">usecols = _evaluate_usecols(self.usecols</span><span class="s2">, </span><span class="s1">names)</span>
        <span class="s2">if </span><span class="s1">usecols </span><span class="s2">is not None and </span><span class="s1">len(names) != len(usecols):</span>
            <span class="s1">names = [</span>
                <span class="s1">name </span><span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">enumerate(names) </span><span class="s2">if </span><span class="s1">i </span><span class="s2">in </span><span class="s1">usecols </span><span class="s2">or </span><span class="s1">name </span><span class="s2">in </span><span class="s1">usecols</span>
            <span class="s1">]</span>
        <span class="s2">return </span><span class="s1">names</span>

    <span class="s2">def </span><span class="s1">_get_index_names(self):</span>
        <span class="s1">names = list(self._reader.header[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s1">idx_names = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">self._reader.leading_cols == </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">self.index_col </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">(idx_names</span><span class="s2">, </span><span class="s1">names</span><span class="s2">, </span><span class="s1">self.index_col) = _clean_index_names(</span>
                <span class="s1">names</span><span class="s2">, </span><span class="s1">self.index_col</span><span class="s2">, </span><span class="s1">self.unnamed_cols</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">names</span><span class="s2">, </span><span class="s1">idx_names</span>

    <span class="s2">def </span><span class="s1">_maybe_parse_dates(self</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">try_parse_dates=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">try_parse_dates </span><span class="s2">and </span><span class="s1">self._should_parse_dates(index):</span>
            <span class="s1">values = self._date_conv(values)</span>
        <span class="s2">return </span><span class="s1">values</span>


<span class="s2">def </span><span class="s1">TextParser(*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
    <span class="s0">&quot;&quot;&quot; 
    Converts lists of lists/tuples into DataFrames with proper type inference 
    and optional (e.g. string to datetime) conversion. Also enables iterating 
    lazily over chunks of large files 
 
    Parameters 
    ---------- 
    data : file-like object or list 
    delimiter : separator character to use 
    dialect : str or csv.Dialect instance, optional 
        Ignored if delimiter is longer than 1 character 
    names : sequence, default 
    header : int, default 0 
        Row to use to parse column labels. Defaults to the first row. Prior 
        rows will be discarded 
    index_col : int or list, optional 
        Column or columns to use as the (possibly hierarchical) index 
    has_index_names: bool, default False 
        True if the cols defined in index_col have an index name and are 
        not in the header. 
    na_values : scalar, str, list-like, or dict, optional 
        Additional strings to recognize as NA/NaN. 
    keep_default_na : bool, default True 
    thousands : str, optional 
        Thousands separator 
    comment : str, optional 
        Comment out remainder of line 
    parse_dates : bool, default False 
    keep_date_col : bool, default False 
    date_parser : function, optional 
    skiprows : list of integers 
        Row numbers to skip 
    skipfooter : int 
        Number of line at bottom of file to skip 
    converters : dict, optional 
        Dict of functions for converting values in certain columns. Keys can 
        either be integers or column labels, values are functions that take one 
        input argument, the cell (not column) content, and return the 
        transformed content. 
    encoding : str, optional 
        Encoding to use for UTF when reading/writing (ex. 'utf-8') 
    squeeze : bool, default False 
        returns Series if only one column. 
    infer_datetime_format: bool, default False 
        If True and `parse_dates` is True for a column, try to infer the 
        datetime format based on the first datetime string. If the format 
        can be inferred, there often will be a large parsing speed-up. 
    float_precision : str, optional 
        Specifies which converter the C engine should use for floating-point 
        values. The options are `None` or `high` for the ordinary converter, 
        `legacy` for the original lower precision pandas converter, and 
        `round_trip` for the round-trip converter. 
 
        .. versionchanged:: 1.2 
    &quot;&quot;&quot;</span>
    <span class="s1">kwds[</span><span class="s4">&quot;engine&quot;</span><span class="s1">] = </span><span class="s4">&quot;python&quot;</span>
    <span class="s2">return </span><span class="s1">TextFileReader(*args</span><span class="s2">, </span><span class="s1">**kwds)</span>


<span class="s2">def </span><span class="s1">count_empty_vals(vals) -&gt; int:</span>
    <span class="s2">return </span><span class="s1">sum(</span><span class="s5">1 </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">vals </span><span class="s2">if </span><span class="s1">v == </span><span class="s4">&quot;&quot; </span><span class="s2">or </span><span class="s1">v </span><span class="s2">is None</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">PythonParser(ParserBase):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">f: Union[FilePathOrBuffer</span><span class="s2">, </span><span class="s1">List]</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s0">&quot;&quot;&quot; 
        Workhorse function for processing nested list into DataFrame 
        &quot;&quot;&quot;</span>
        <span class="s1">ParserBase.__init__(self</span><span class="s2">, </span><span class="s1">kwds)</span>

        <span class="s1">self.data: Optional[Iterator[str]] = </span><span class="s2">None</span>
        <span class="s1">self.buf: List = []</span>
        <span class="s1">self.pos = </span><span class="s5">0</span>
        <span class="s1">self.line_pos = </span><span class="s5">0</span>

        <span class="s1">self.skiprows = kwds[</span><span class="s4">&quot;skiprows&quot;</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">callable(self.skiprows):</span>
            <span class="s1">self.skipfunc = self.skiprows</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.skipfunc = </span><span class="s2">lambda </span><span class="s1">x: x </span><span class="s2">in </span><span class="s1">self.skiprows</span>

        <span class="s1">self.skipfooter = _validate_skipfooter_arg(kwds[</span><span class="s4">&quot;skipfooter&quot;</span><span class="s1">])</span>
        <span class="s1">self.delimiter = kwds[</span><span class="s4">&quot;delimiter&quot;</span><span class="s1">]</span>

        <span class="s1">self.quotechar = kwds[</span><span class="s4">&quot;quotechar&quot;</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">isinstance(self.quotechar</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">self.quotechar = str(self.quotechar)</span>

        <span class="s1">self.escapechar = kwds[</span><span class="s4">&quot;escapechar&quot;</span><span class="s1">]</span>
        <span class="s1">self.doublequote = kwds[</span><span class="s4">&quot;doublequote&quot;</span><span class="s1">]</span>
        <span class="s1">self.skipinitialspace = kwds[</span><span class="s4">&quot;skipinitialspace&quot;</span><span class="s1">]</span>
        <span class="s1">self.lineterminator = kwds[</span><span class="s4">&quot;lineterminator&quot;</span><span class="s1">]</span>
        <span class="s1">self.quoting = kwds[</span><span class="s4">&quot;quoting&quot;</span><span class="s1">]</span>
        <span class="s1">self.usecols</span><span class="s2">, </span><span class="s1">_ = _validate_usecols_arg(kwds[</span><span class="s4">&quot;usecols&quot;</span><span class="s1">])</span>
        <span class="s1">self.skip_blank_lines = kwds[</span><span class="s4">&quot;skip_blank_lines&quot;</span><span class="s1">]</span>

        <span class="s1">self.warn_bad_lines = kwds[</span><span class="s4">&quot;warn_bad_lines&quot;</span><span class="s1">]</span>
        <span class="s1">self.error_bad_lines = kwds[</span><span class="s4">&quot;error_bad_lines&quot;</span><span class="s1">]</span>

        <span class="s1">self.names_passed = kwds[</span><span class="s4">&quot;names&quot;</span><span class="s1">] </span><span class="s2">or None</span>

        <span class="s1">self.has_index_names = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s4">&quot;has_index_names&quot; </span><span class="s2">in </span><span class="s1">kwds:</span>
            <span class="s1">self.has_index_names = kwds[</span><span class="s4">&quot;has_index_names&quot;</span><span class="s1">]</span>

        <span class="s1">self.verbose = kwds[</span><span class="s4">&quot;verbose&quot;</span><span class="s1">]</span>
        <span class="s1">self.converters = kwds[</span><span class="s4">&quot;converters&quot;</span><span class="s1">]</span>

        <span class="s1">self.dtype = kwds[</span><span class="s4">&quot;dtype&quot;</span><span class="s1">]</span>
        <span class="s1">self.thousands = kwds[</span><span class="s4">&quot;thousands&quot;</span><span class="s1">]</span>
        <span class="s1">self.decimal = kwds[</span><span class="s4">&quot;decimal&quot;</span><span class="s1">]</span>

        <span class="s1">self.comment = kwds[</span><span class="s4">&quot;comment&quot;</span><span class="s1">]</span>

        <span class="s3"># Set self.data to something that can read lines.</span>
        <span class="s2">if </span><span class="s1">isinstance(f</span><span class="s2">, </span><span class="s1">list):</span>
            <span class="s3"># read_excel: f is a list</span>
            <span class="s1">self.data = cast(Iterator[str]</span><span class="s2">, </span><span class="s1">f)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._open_handles(f</span><span class="s2">, </span><span class="s1">kwds)</span>
            <span class="s2">assert </span><span class="s1">self.handles </span><span class="s2">is not None</span>
            <span class="s2">assert </span><span class="s1">hasattr(self.handles.handle</span><span class="s2">, </span><span class="s4">&quot;readline&quot;</span><span class="s1">)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self._make_reader(self.handles.handle)</span>
            <span class="s2">except </span><span class="s1">(csv.Error</span><span class="s2">, </span><span class="s1">UnicodeDecodeError):</span>
                <span class="s1">self.close()</span>
                <span class="s2">raise</span>

        <span class="s3"># Get columns in two steps: infer from data, then</span>
        <span class="s3"># infer column indices from self.usecols if it is specified.</span>
        <span class="s1">self._col_indices = </span><span class="s2">None</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">(</span>
                <span class="s1">self.columns</span><span class="s2">,</span>
                <span class="s1">self.num_original_columns</span><span class="s2">,</span>
                <span class="s1">self.unnamed_cols</span><span class="s2">,</span>
            <span class="s1">) = self._infer_columns()</span>
        <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">ValueError):</span>
            <span class="s1">self.close()</span>
            <span class="s2">raise</span>

        <span class="s3"># Now self.columns has the set of columns that we will process.</span>
        <span class="s3"># The original set is stored in self.original_columns.</span>
        <span class="s2">if </span><span class="s1">len(self.columns) &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3"># we are processing a multi index column</span>
            <span class="s1">(</span>
                <span class="s1">self.columns</span><span class="s2">,</span>
                <span class="s1">self.index_names</span><span class="s2">,</span>
                <span class="s1">self.col_names</span><span class="s2">,</span>
                <span class="s1">_</span><span class="s2">,</span>
            <span class="s1">) = self._extract_multi_indexer_columns(</span>
                <span class="s1">self.columns</span><span class="s2">, </span><span class="s1">self.index_names</span><span class="s2">, </span><span class="s1">self.col_names</span>
            <span class="s1">)</span>
            <span class="s3"># Update list of original names to include all indices.</span>
            <span class="s1">self.num_original_columns = len(self.columns)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.columns = self.columns[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s3"># get popped off for index</span>
        <span class="s1">self.orig_names = list(self.columns)</span>

        <span class="s3"># needs to be cleaned/refactored</span>
        <span class="s3"># multiple date column thing turning into a real spaghetti factory</span>

        <span class="s2">if not </span><span class="s1">self._has_complex_date_col:</span>
            <span class="s1">(index_names</span><span class="s2">, </span><span class="s1">self.orig_names</span><span class="s2">, </span><span class="s1">self.columns) = self._get_index_name(</span>
                <span class="s1">self.columns</span>
            <span class="s1">)</span>
            <span class="s1">self._name_processed = </span><span class="s2">True</span>
            <span class="s2">if </span><span class="s1">self.index_names </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">self.index_names = index_names</span>

        <span class="s1">self._validate_parse_dates_presence(self.columns)</span>
        <span class="s2">if </span><span class="s1">self.parse_dates:</span>
            <span class="s1">self._no_thousands_columns = self._set_no_thousands_columns()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._no_thousands_columns = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">len(self.decimal) != </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Only length-1 decimal markers supported&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.thousands </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.nonnum = re.compile(</span><span class="s4">fr&quot;[^-^0-9^</span><span class="s2">{</span><span class="s1">self.decimal</span><span class="s2">}</span><span class="s4">]+&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.nonnum = re.compile(</span><span class="s4">fr&quot;[^-^0-9^</span><span class="s2">{</span><span class="s1">self.thousands</span><span class="s2">}</span><span class="s4">^</span><span class="s2">{</span><span class="s1">self.decimal</span><span class="s2">}</span><span class="s4">]+&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_set_no_thousands_columns(self):</span>
        <span class="s3"># Create a set of column ids that are not to be stripped of thousands</span>
        <span class="s3"># operators.</span>
        <span class="s1">noconvert_columns = set()</span>

        <span class="s2">def </span><span class="s1">_set(x):</span>
            <span class="s2">if </span><span class="s1">is_integer(x):</span>
                <span class="s1">noconvert_columns.add(x)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">noconvert_columns.add(self.columns.index(x))</span>

        <span class="s2">if </span><span class="s1">isinstance(self.parse_dates</span><span class="s2">, </span><span class="s1">list):</span>
            <span class="s2">for </span><span class="s1">val </span><span class="s2">in </span><span class="s1">self.parse_dates:</span>
                <span class="s2">if </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">list):</span>
                    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">val:</span>
                        <span class="s1">_set(k)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">_set(val)</span>

        <span class="s2">elif </span><span class="s1">isinstance(self.parse_dates</span><span class="s2">, </span><span class="s1">dict):</span>
            <span class="s2">for </span><span class="s1">val </span><span class="s2">in </span><span class="s1">self.parse_dates.values():</span>
                <span class="s2">if </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">list):</span>
                    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">val:</span>
                        <span class="s1">_set(k)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">_set(val)</span>

        <span class="s2">elif </span><span class="s1">self.parse_dates:</span>
            <span class="s2">if </span><span class="s1">isinstance(self.index_col</span><span class="s2">, </span><span class="s1">list):</span>
                <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">self.index_col:</span>
                    <span class="s1">_set(k)</span>
            <span class="s2">elif </span><span class="s1">self.index_col </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">_set(self.index_col)</span>

        <span class="s2">return </span><span class="s1">noconvert_columns</span>

    <span class="s2">def </span><span class="s1">_make_reader(self</span><span class="s2">, </span><span class="s1">f):</span>
        <span class="s1">sep = self.delimiter</span>

        <span class="s2">if </span><span class="s1">sep </span><span class="s2">is None or </span><span class="s1">len(sep) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.lineterminator:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;Custom line terminators not supported in python parser (yet)&quot;</span>
                <span class="s1">)</span>

            <span class="s2">class </span><span class="s1">MyDialect(csv.Dialect):</span>
                <span class="s1">delimiter = self.delimiter</span>
                <span class="s1">quotechar = self.quotechar</span>
                <span class="s1">escapechar = self.escapechar</span>
                <span class="s1">doublequote = self.doublequote</span>
                <span class="s1">skipinitialspace = self.skipinitialspace</span>
                <span class="s1">quoting = self.quoting</span>
                <span class="s1">lineterminator = </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span>

            <span class="s1">dia = MyDialect</span>

            <span class="s2">if </span><span class="s1">sep </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">dia.delimiter = sep</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s3"># attempt to sniff the delimiter from the first valid line,</span>
                <span class="s3"># i.e. no comment line and not in skiprows</span>
                <span class="s1">line = f.readline()</span>
                <span class="s1">lines = self._check_comments([[line]])[</span><span class="s5">0</span><span class="s1">]</span>
                <span class="s2">while </span><span class="s1">self.skipfunc(self.pos) </span><span class="s2">or not </span><span class="s1">lines:</span>
                    <span class="s1">self.pos += </span><span class="s5">1</span>
                    <span class="s1">line = f.readline()</span>
                    <span class="s1">lines = self._check_comments([[line]])[</span><span class="s5">0</span><span class="s1">]</span>

                <span class="s3"># since `line` was a string, lines will be a list containing</span>
                <span class="s3"># only a single string</span>
                <span class="s1">line = lines[</span><span class="s5">0</span><span class="s1">]</span>

                <span class="s1">self.pos += </span><span class="s5">1</span>
                <span class="s1">self.line_pos += </span><span class="s5">1</span>
                <span class="s1">sniffed = csv.Sniffer().sniff(line)</span>
                <span class="s1">dia.delimiter = sniffed.delimiter</span>

                <span class="s3"># Note: encoding is irrelevant here</span>
                <span class="s1">line_rdr = csv.reader(StringIO(line)</span><span class="s2">, </span><span class="s1">dialect=dia)</span>
                <span class="s1">self.buf.extend(list(line_rdr))</span>

            <span class="s3"># Note: encoding is irrelevant here</span>
            <span class="s1">reader = csv.reader(f</span><span class="s2">, </span><span class="s1">dialect=dia</span><span class="s2">, </span><span class="s1">strict=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s2">else</span><span class="s1">:</span>

            <span class="s2">def </span><span class="s1">_read():</span>
                <span class="s1">line = f.readline()</span>
                <span class="s1">pat = re.compile(sep)</span>

                <span class="s2">yield </span><span class="s1">pat.split(line.strip())</span>

                <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">f:</span>
                    <span class="s2">yield </span><span class="s1">pat.split(line.strip())</span>

            <span class="s1">reader = _read()</span>

        <span class="s3"># pandas\io\parsers.py:2427: error: Incompatible types in assignment</span>
        <span class="s3"># (expression has type &quot;_reader&quot;, variable has type &quot;Union[IO[Any],</span>
        <span class="s3"># RawIOBase, BufferedIOBase, TextIOBase, TextIOWrapper, mmap, None]&quot;)</span>
        <span class="s3"># [assignment]</span>
        <span class="s1">self.data = reader  </span><span class="s3"># type: ignore[assignment]</span>

    <span class="s2">def </span><span class="s1">read(self</span><span class="s2">, </span><span class="s1">rows=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">content = self._get_lines(rows)</span>
        <span class="s2">except </span><span class="s1">StopIteration:</span>
            <span class="s2">if </span><span class="s1">self._first_chunk:</span>
                <span class="s1">content = []</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.close()</span>
                <span class="s2">raise</span>

        <span class="s3"># done with first read, next time raise StopIteration</span>
        <span class="s1">self._first_chunk = </span><span class="s2">False</span>

        <span class="s3"># pandas\io\parsers.py:2480: error: Argument 1 to &quot;list&quot; has</span>
        <span class="s3"># incompatible type &quot;Optional[Any]&quot;; expected &quot;Iterable[Any]&quot;</span>
        <span class="s3"># [arg-type]</span>
        <span class="s1">columns = list(self.orig_names)  </span><span class="s3"># type: ignore[arg-type]</span>
        <span class="s2">if not </span><span class="s1">len(content):  </span><span class="s3"># pragma: no cover</span>
            <span class="s3"># DataFrame with the right metadata, even though it's length 0</span>
            <span class="s1">names = self._maybe_dedup_names(self.orig_names)</span>
            <span class="s1">index</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">col_dict = _get_empty_meta(</span>
                <span class="s1">names</span><span class="s2">, </span><span class="s1">self.index_col</span><span class="s2">, </span><span class="s1">self.index_names</span><span class="s2">, </span><span class="s1">self.dtype</span>
            <span class="s1">)</span>
            <span class="s1">columns = self._maybe_make_multi_index_columns(columns</span><span class="s2">, </span><span class="s1">self.col_names)</span>
            <span class="s2">return </span><span class="s1">index</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">col_dict</span>

        <span class="s3"># handle new style for names in index</span>
        <span class="s1">count_empty_content_vals = count_empty_vals(content[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s1">indexnamerow = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">self.has_index_names </span><span class="s2">and </span><span class="s1">count_empty_content_vals == len(columns):</span>
            <span class="s1">indexnamerow = content[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">content = content[</span><span class="s5">1</span><span class="s1">:]</span>

        <span class="s1">alldata = self._rows_to_cols(content)</span>
        <span class="s1">data = self._exclude_implicit_index(alldata)</span>

        <span class="s1">columns = self._maybe_dedup_names(self.columns)</span>
        <span class="s1">columns</span><span class="s2">, </span><span class="s1">data = self._do_date_conversions(columns</span><span class="s2">, </span><span class="s1">data)</span>

        <span class="s1">data = self._convert_data(data)</span>
        <span class="s1">index</span><span class="s2">, </span><span class="s1">columns = self._make_index(data</span><span class="s2">, </span><span class="s1">alldata</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">indexnamerow)</span>

        <span class="s2">return </span><span class="s1">index</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">data</span>

    <span class="s2">def </span><span class="s1">_exclude_implicit_index(self</span><span class="s2">, </span><span class="s1">alldata):</span>
        <span class="s1">names = self._maybe_dedup_names(self.orig_names)</span>

        <span class="s2">if </span><span class="s1">self._implicit_index:</span>
            <span class="s1">excl_indices = self.index_col</span>

            <span class="s1">data = {}</span>
            <span class="s1">offset = </span><span class="s5">0</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">col </span><span class="s2">in </span><span class="s1">enumerate(names):</span>
                <span class="s2">while </span><span class="s1">i + offset </span><span class="s2">in </span><span class="s1">excl_indices:</span>
                    <span class="s1">offset += </span><span class="s5">1</span>
                <span class="s1">data[col] = alldata[i + offset]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">data = {k: v </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">zip(names</span><span class="s2">, </span><span class="s1">alldata)}</span>

        <span class="s2">return </span><span class="s1">data</span>

    <span class="s3"># legacy</span>
    <span class="s2">def </span><span class="s1">get_chunk(self</span><span class="s2">, </span><span class="s1">size=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">size </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s3"># pandas\io\parsers.py:2528: error: &quot;PythonParser&quot; has no attribute</span>
            <span class="s3"># &quot;chunksize&quot;  [attr-defined]</span>
            <span class="s1">size = self.chunksize  </span><span class="s3"># type: ignore[attr-defined]</span>
        <span class="s2">return </span><span class="s1">self.read(rows=size)</span>

    <span class="s2">def </span><span class="s1">_convert_data(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s3"># apply converters</span>
        <span class="s2">def </span><span class="s1">_clean_mapping(mapping):</span>
            <span class="s0">&quot;&quot;&quot;converts col numbers to names&quot;&quot;&quot;</span>
            <span class="s1">clean = {}</span>
            <span class="s2">for </span><span class="s1">col</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">mapping.items():</span>
                <span class="s3"># pandas\io\parsers.py:2537: error: Unsupported right operand</span>
                <span class="s3"># type for in (&quot;Optional[Any]&quot;)  [operator]</span>
                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">isinstance(col</span><span class="s2">, </span><span class="s1">int)</span>
                    <span class="s2">and </span><span class="s1">col </span><span class="s2">not in </span><span class="s1">self.orig_names  </span><span class="s3"># type: ignore[operator]</span>
                <span class="s1">):</span>
                    <span class="s3"># pandas\io\parsers.py:2538: error: Value of type</span>
                    <span class="s3"># &quot;Optional[Any]&quot; is not indexable  [index]</span>
                    <span class="s1">col = self.orig_names[col]  </span><span class="s3"># type: ignore[index]</span>
                <span class="s1">clean[col] = v</span>
            <span class="s2">return </span><span class="s1">clean</span>

        <span class="s1">clean_conv = _clean_mapping(self.converters)</span>
        <span class="s2">if not </span><span class="s1">isinstance(self.dtype</span><span class="s2">, </span><span class="s1">dict):</span>
            <span class="s3"># handles single dtype applied to all columns</span>
            <span class="s1">clean_dtypes = self.dtype</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">clean_dtypes = _clean_mapping(self.dtype)</span>

        <span class="s3"># Apply NA values.</span>
        <span class="s1">clean_na_values = {}</span>
        <span class="s1">clean_na_fvalues = {}</span>

        <span class="s2">if </span><span class="s1">isinstance(self.na_values</span><span class="s2">, </span><span class="s1">dict):</span>
            <span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">self.na_values:</span>
                <span class="s1">na_value = self.na_values[col]</span>
                <span class="s1">na_fvalue = self.na_fvalues[col]</span>

                <span class="s3"># pandas\io\parsers.py:2558: error: Unsupported right operand</span>
                <span class="s3"># type for in (&quot;Optional[Any]&quot;)  [operator]</span>
                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">isinstance(col</span><span class="s2">, </span><span class="s1">int)</span>
                    <span class="s2">and </span><span class="s1">col </span><span class="s2">not in </span><span class="s1">self.orig_names  </span><span class="s3"># type: ignore[operator]</span>
                <span class="s1">):</span>
                    <span class="s3"># pandas\io\parsers.py:2559: error: Value of type</span>
                    <span class="s3"># &quot;Optional[Any]&quot; is not indexable  [index]</span>
                    <span class="s1">col = self.orig_names[col]  </span><span class="s3"># type: ignore[index]</span>

                <span class="s1">clean_na_values[col] = na_value</span>
                <span class="s1">clean_na_fvalues[col] = na_fvalue</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">clean_na_values = self.na_values</span>
            <span class="s1">clean_na_fvalues = self.na_fvalues</span>

        <span class="s2">return </span><span class="s1">self._convert_to_ndarrays(</span>
            <span class="s1">data</span><span class="s2">,</span>
            <span class="s1">clean_na_values</span><span class="s2">,</span>
            <span class="s1">clean_na_fvalues</span><span class="s2">,</span>
            <span class="s1">self.verbose</span><span class="s2">,</span>
            <span class="s1">clean_conv</span><span class="s2">,</span>
            <span class="s1">clean_dtypes</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_infer_columns(self):</span>
        <span class="s1">names = self.names</span>
        <span class="s1">num_original_columns = </span><span class="s5">0</span>
        <span class="s1">clear_buffer = </span><span class="s2">True</span>
        <span class="s3"># pandas\io\parsers.py:2580: error: Need type annotation for</span>
        <span class="s3"># 'unnamed_cols' (hint: &quot;unnamed_cols: Set[&lt;type&gt;] = ...&quot;)</span>
        <span class="s3"># [var-annotated]</span>
        <span class="s1">unnamed_cols = set()  </span><span class="s3"># type: ignore[var-annotated]</span>

        <span class="s2">if </span><span class="s1">self.header </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">header = self.header</span>

            <span class="s2">if </span><span class="s1">isinstance(header</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">np.ndarray)):</span>
                <span class="s1">have_mi_columns = len(header) &gt; </span><span class="s5">1</span>
                <span class="s3"># we have a mi columns, so read an extra line</span>
                <span class="s2">if </span><span class="s1">have_mi_columns:</span>
                    <span class="s1">header = list(header) + [header[-</span><span class="s5">1</span><span class="s1">] + </span><span class="s5">1</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">have_mi_columns = </span><span class="s2">False</span>
                <span class="s1">header = [header]</span>

            <span class="s3"># pandas\io\parsers.py:2594: error: Need type annotation for</span>
            <span class="s3"># 'columns' (hint: &quot;columns: List[&lt;type&gt;] = ...&quot;)  [var-annotated]</span>
            <span class="s1">columns = []  </span><span class="s3"># type: ignore[var-annotated]</span>
            <span class="s2">for </span><span class="s1">level</span><span class="s2">, </span><span class="s1">hr </span><span class="s2">in </span><span class="s1">enumerate(header):</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">line = self._buffered_line()</span>

                    <span class="s2">while </span><span class="s1">self.line_pos &lt;= hr:</span>
                        <span class="s1">line = self._next_line()</span>

                <span class="s2">except </span><span class="s1">StopIteration </span><span class="s2">as </span><span class="s1">err:</span>
                    <span class="s2">if </span><span class="s1">self.line_pos &lt; hr:</span>
                        <span class="s2">raise </span><span class="s1">ValueError(</span>
                            <span class="s4">f&quot;Passed header=</span><span class="s2">{</span><span class="s1">hr</span><span class="s2">} </span><span class="s4">but only </span><span class="s2">{</span><span class="s1">self.line_pos + </span><span class="s5">1</span><span class="s2">} </span><span class="s4">lines in &quot;</span>
                            <span class="s4">&quot;file&quot;</span>
                        <span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>

                    <span class="s3"># We have an empty file, so check</span>
                    <span class="s3"># if columns are provided. That will</span>
                    <span class="s3"># serve as the 'line' for parsing</span>
                    <span class="s2">if </span><span class="s1">have_mi_columns </span><span class="s2">and </span><span class="s1">hr &gt; </span><span class="s5">0</span><span class="s1">:</span>
                        <span class="s2">if </span><span class="s1">clear_buffer:</span>
                            <span class="s1">self._clear_buffer()</span>
                        <span class="s1">columns.append([</span><span class="s2">None</span><span class="s1">] * len(columns[-</span><span class="s5">1</span><span class="s1">]))</span>
                        <span class="s2">return </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">num_original_columns</span><span class="s2">, </span><span class="s1">unnamed_cols</span>

                    <span class="s2">if not </span><span class="s1">self.names:</span>
                        <span class="s2">raise </span><span class="s1">EmptyDataError(</span><span class="s4">&quot;No columns to parse from file&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>

                    <span class="s1">line = self.names[:]</span>

                <span class="s1">this_columns = []</span>
                <span class="s1">this_unnamed_cols = []</span>

                <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">c </span><span class="s2">in </span><span class="s1">enumerate(line):</span>
                    <span class="s2">if </span><span class="s1">c == </span><span class="s4">&quot;&quot;</span><span class="s1">:</span>
                        <span class="s2">if </span><span class="s1">have_mi_columns:</span>
                            <span class="s1">col_name = </span><span class="s4">f&quot;Unnamed: </span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">_level_</span><span class="s2">{</span><span class="s1">level</span><span class="s2">}</span><span class="s4">&quot;</span>
                        <span class="s2">else</span><span class="s1">:</span>
                            <span class="s1">col_name = </span><span class="s4">f&quot;Unnamed: </span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">&quot;</span>

                        <span class="s1">this_unnamed_cols.append(i)</span>
                        <span class="s1">this_columns.append(col_name)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">this_columns.append(c)</span>

                <span class="s2">if not </span><span class="s1">have_mi_columns </span><span class="s2">and </span><span class="s1">self.mangle_dupe_cols:</span>
                    <span class="s3"># pandas\io\parsers.py:2639: error: Need type annotation</span>
                    <span class="s3"># for 'counts'  [var-annotated]</span>
                    <span class="s1">counts = defaultdict(int)  </span><span class="s3"># type: ignore[var-annotated]</span>

                    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">col </span><span class="s2">in </span><span class="s1">enumerate(this_columns):</span>
                        <span class="s1">cur_count = counts[col]</span>

                        <span class="s2">while </span><span class="s1">cur_count &gt; </span><span class="s5">0</span><span class="s1">:</span>
                            <span class="s1">counts[col] = cur_count + </span><span class="s5">1</span>
                            <span class="s1">col = </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">col</span><span class="s2">}</span><span class="s4">.</span><span class="s2">{</span><span class="s1">cur_count</span><span class="s2">}</span><span class="s4">&quot;</span>
                            <span class="s1">cur_count = counts[col]</span>

                        <span class="s1">this_columns[i] = col</span>
                        <span class="s1">counts[col] = cur_count + </span><span class="s5">1</span>
                <span class="s2">elif </span><span class="s1">have_mi_columns:</span>

                    <span class="s3"># if we have grabbed an extra line, but its not in our</span>
                    <span class="s3"># format so save in the buffer, and create an blank extra</span>
                    <span class="s3"># line for the rest of the parsing code</span>
                    <span class="s2">if </span><span class="s1">hr == header[-</span><span class="s5">1</span><span class="s1">]:</span>
                        <span class="s1">lc = len(this_columns)</span>
                        <span class="s1">ic = len(self.index_col) </span><span class="s2">if </span><span class="s1">self.index_col </span><span class="s2">is not None else </span><span class="s5">0</span>
                        <span class="s1">unnamed_count = len(this_unnamed_cols)</span>

                        <span class="s2">if </span><span class="s1">lc != unnamed_count </span><span class="s2">and </span><span class="s1">lc - ic &gt; unnamed_count:</span>
                            <span class="s1">clear_buffer = </span><span class="s2">False</span>
                            <span class="s3"># pandas\io\parsers.py:2663: error: List item 0 has</span>
                            <span class="s3"># incompatible type &quot;None&quot;; expected &quot;str&quot;</span>
                            <span class="s3"># [list-item]</span>
                            <span class="s1">this_columns = [</span><span class="s2">None</span><span class="s1">] * lc  </span><span class="s3"># type: ignore[list-item]</span>
                            <span class="s1">self.buf = [self.buf[-</span><span class="s5">1</span><span class="s1">]]</span>

                <span class="s3"># pandas\io\parsers.py:2666: error: Argument 1 to &quot;append&quot; of</span>
                <span class="s3"># &quot;list&quot; has incompatible type &quot;List[str]&quot;; expected</span>
                <span class="s3"># &quot;List[None]&quot;  [arg-type]</span>
                <span class="s1">columns.append(this_columns)  </span><span class="s3"># type: ignore[arg-type]</span>
                <span class="s1">unnamed_cols.update({this_columns[i] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">this_unnamed_cols})</span>

                <span class="s2">if </span><span class="s1">len(columns) == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">num_original_columns = len(this_columns)</span>

            <span class="s2">if </span><span class="s1">clear_buffer:</span>
                <span class="s1">self._clear_buffer()</span>

            <span class="s2">if </span><span class="s1">names </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">(self.usecols </span><span class="s2">is not None and </span><span class="s1">len(names) != len(self.usecols)) </span><span class="s2">or </span><span class="s1">(</span>
                    <span class="s1">self.usecols </span><span class="s2">is None and </span><span class="s1">len(names) != len(columns[</span><span class="s5">0</span><span class="s1">])</span>
                <span class="s1">):</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s4">&quot;Number of passed names did not match &quot;</span>
                        <span class="s4">&quot;number of header fields in the file&quot;</span>
                    <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">len(columns) &gt; </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Cannot pass names with multi-index columns&quot;</span><span class="s1">)</span>

                <span class="s2">if </span><span class="s1">self.usecols </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s3"># Set _use_cols. We don't store columns because they are</span>
                    <span class="s3"># overwritten.</span>
                    <span class="s1">self._handle_usecols(columns</span><span class="s2">, </span><span class="s1">names)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">self._col_indices = </span><span class="s2">None</span>
                    <span class="s1">num_original_columns = len(names)</span>
                <span class="s1">columns = [names]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">columns = self._handle_usecols(columns</span><span class="s2">, </span><span class="s1">columns[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">line = self._buffered_line()</span>

            <span class="s2">except </span><span class="s1">StopIteration </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s2">if not </span><span class="s1">names:</span>
                    <span class="s2">raise </span><span class="s1">EmptyDataError(</span><span class="s4">&quot;No columns to parse from file&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>

                <span class="s1">line = names[:]</span>

            <span class="s1">ncols = len(line)</span>
            <span class="s1">num_original_columns = ncols</span>

            <span class="s2">if not </span><span class="s1">names:</span>
                <span class="s2">if </span><span class="s1">self.prefix:</span>
                    <span class="s3"># pandas\io\parsers.py:2711: error: List comprehension has</span>
                    <span class="s3"># incompatible type List[str]; expected List[None]  [misc]</span>
                    <span class="s1">columns = [</span>
                        <span class="s1">[</span>
                            <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">self.prefix</span><span class="s2">}{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">&quot;  </span><span class="s3"># type: ignore[misc]</span>
                            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(ncols)</span>
                        <span class="s1">]</span>
                    <span class="s1">]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s3"># pandas\io\parsers.py:2713: error: Argument 1 to &quot;list&quot;</span>
                    <span class="s3"># has incompatible type &quot;range&quot;; expected &quot;Iterable[None]&quot;</span>
                    <span class="s3"># [arg-type]</span>
                    <span class="s1">columns = [list(range(ncols))]  </span><span class="s3"># type: ignore[arg-type]</span>
                <span class="s1">columns = self._handle_usecols(columns</span><span class="s2">, </span><span class="s1">columns[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">self.usecols </span><span class="s2">is None or </span><span class="s1">len(names) &gt;= num_original_columns:</span>
                    <span class="s1">columns = self._handle_usecols([names]</span><span class="s2">, </span><span class="s1">names)</span>
                    <span class="s1">num_original_columns = len(names)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">if not </span><span class="s1">callable(self.usecols) </span><span class="s2">and </span><span class="s1">len(names) != len(self.usecols):</span>
                        <span class="s2">raise </span><span class="s1">ValueError(</span>
                            <span class="s4">&quot;Number of passed names did not match number of &quot;</span>
                            <span class="s4">&quot;header fields in the file&quot;</span>
                        <span class="s1">)</span>
                    <span class="s3"># Ignore output but set used columns.</span>
                    <span class="s1">self._handle_usecols([names]</span><span class="s2">, </span><span class="s1">names)</span>
                    <span class="s1">columns = [names]</span>
                    <span class="s1">num_original_columns = ncols</span>

        <span class="s2">return </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">num_original_columns</span><span class="s2">, </span><span class="s1">unnamed_cols</span>

    <span class="s2">def </span><span class="s1">_handle_usecols(self</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">usecols_key):</span>
        <span class="s0">&quot;&quot;&quot; 
        Sets self._col_indices 
 
        usecols_key is used if there are string usecols. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.usecols </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">callable(self.usecols):</span>
                <span class="s1">col_indices = _evaluate_usecols(self.usecols</span><span class="s2">, </span><span class="s1">usecols_key)</span>
            <span class="s2">elif </span><span class="s1">any(isinstance(u</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">for </span><span class="s1">u </span><span class="s2">in </span><span class="s1">self.usecols):</span>
                <span class="s2">if </span><span class="s1">len(columns) &gt; </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s4">&quot;If using multiple headers, usecols must be integers.&quot;</span>
                    <span class="s1">)</span>
                <span class="s1">col_indices = []</span>

                <span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">self.usecols:</span>
                    <span class="s2">if </span><span class="s1">isinstance(col</span><span class="s2">, </span><span class="s1">str):</span>
                        <span class="s2">try</span><span class="s1">:</span>
                            <span class="s1">col_indices.append(usecols_key.index(col))</span>
                        <span class="s2">except </span><span class="s1">ValueError:</span>
                            <span class="s1">_validate_usecols_names(self.usecols</span><span class="s2">, </span><span class="s1">usecols_key)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">col_indices.append(col)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">col_indices = self.usecols</span>

            <span class="s1">columns = [</span>
                <span class="s1">[n </span><span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">n </span><span class="s2">in </span><span class="s1">enumerate(column) </span><span class="s2">if </span><span class="s1">i </span><span class="s2">in </span><span class="s1">col_indices]</span>
                <span class="s2">for </span><span class="s1">column </span><span class="s2">in </span><span class="s1">columns</span>
            <span class="s1">]</span>
            <span class="s1">self._col_indices = col_indices</span>
        <span class="s2">return </span><span class="s1">columns</span>

    <span class="s2">def </span><span class="s1">_buffered_line(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a line from buffer, filling buffer if required. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len(self.buf) &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.buf[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._next_line()</span>

    <span class="s2">def </span><span class="s1">_check_for_bom(self</span><span class="s2">, </span><span class="s1">first_row):</span>
        <span class="s0">&quot;&quot;&quot; 
        Checks whether the file begins with the BOM character. 
        If it does, remove it. In addition, if there is quoting 
        in the field subsequent to the BOM, remove it as well 
        because it technically takes place at the beginning of 
        the name, not the middle of it. 
        &quot;&quot;&quot;</span>
        <span class="s3"># first_row will be a list, so we need to check</span>
        <span class="s3"># that that list is not empty before proceeding.</span>
        <span class="s2">if not </span><span class="s1">first_row:</span>
            <span class="s2">return </span><span class="s1">first_row</span>

        <span class="s3"># The first element of this row is the one that could have the</span>
        <span class="s3"># BOM that we want to remove. Check that the first element is a</span>
        <span class="s3"># string before proceeding.</span>
        <span class="s2">if not </span><span class="s1">isinstance(first_row[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">return </span><span class="s1">first_row</span>

        <span class="s3"># Check that the string is not empty, as that would</span>
        <span class="s3"># obviously not have a BOM at the start of it.</span>
        <span class="s2">if not </span><span class="s1">first_row[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s2">return </span><span class="s1">first_row</span>

        <span class="s3"># Since the string is non-empty, check that it does</span>
        <span class="s3"># in fact begin with a BOM.</span>
        <span class="s1">first_elt = first_row[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">first_elt != _BOM:</span>
            <span class="s2">return </span><span class="s1">first_row</span>

        <span class="s1">first_row_bom = first_row[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">len(first_row_bom) &gt; </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">first_row_bom[</span><span class="s5">1</span><span class="s1">] == self.quotechar:</span>
            <span class="s1">start = </span><span class="s5">2</span>
            <span class="s1">quote = first_row_bom[</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">end = first_row_bom[</span><span class="s5">2</span><span class="s1">:].index(quote) + </span><span class="s5">2</span>

            <span class="s3"># Extract the data between the quotation marks</span>
            <span class="s1">new_row = first_row_bom[start:end]</span>

            <span class="s3"># Extract any remaining data after the second</span>
            <span class="s3"># quotation mark.</span>
            <span class="s2">if </span><span class="s1">len(first_row_bom) &gt; end + </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">new_row += first_row_bom[end + </span><span class="s5">1 </span><span class="s1">:]</span>

        <span class="s2">else</span><span class="s1">:</span>

            <span class="s3"># No quotation so just remove BOM from first element</span>
            <span class="s1">new_row = first_row_bom[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s2">return </span><span class="s1">[new_row] + first_row[</span><span class="s5">1</span><span class="s1">:]</span>

    <span class="s2">def </span><span class="s1">_is_line_empty(self</span><span class="s2">, </span><span class="s1">line):</span>
        <span class="s0">&quot;&quot;&quot; 
        Check if a line is empty or not. 
 
        Parameters 
        ---------- 
        line : str, array-like 
            The line of data to check. 
 
        Returns 
        ------- 
        boolean : Whether or not the line is empty. 
        &quot;&quot;&quot;</span>
        <span class="s2">return not </span><span class="s1">line </span><span class="s2">or </span><span class="s1">all(</span><span class="s2">not </span><span class="s1">x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">line)</span>

    <span class="s2">def </span><span class="s1">_next_line(self):</span>
        <span class="s2">if </span><span class="s1">isinstance(self.data</span><span class="s2">, </span><span class="s1">list):</span>
            <span class="s2">while </span><span class="s1">self.skipfunc(self.pos):</span>
                <span class="s1">self.pos += </span><span class="s5">1</span>

            <span class="s2">while True</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">line = self._check_comments([self.data[self.pos]])[</span><span class="s5">0</span><span class="s1">]</span>
                    <span class="s1">self.pos += </span><span class="s5">1</span>
                    <span class="s3"># either uncommented or blank to begin with</span>
                    <span class="s2">if not </span><span class="s1">self.skip_blank_lines </span><span class="s2">and </span><span class="s1">(</span>
                        <span class="s1">self._is_line_empty(self.data[self.pos - </span><span class="s5">1</span><span class="s1">]) </span><span class="s2">or </span><span class="s1">line</span>
                    <span class="s1">):</span>
                        <span class="s2">break</span>
                    <span class="s2">elif </span><span class="s1">self.skip_blank_lines:</span>
                        <span class="s1">ret = self._remove_empty_lines([line])</span>
                        <span class="s2">if </span><span class="s1">ret:</span>
                            <span class="s1">line = ret[</span><span class="s5">0</span><span class="s1">]</span>
                            <span class="s2">break</span>
                <span class="s2">except </span><span class="s1">IndexError:</span>
                    <span class="s2">raise </span><span class="s1">StopIteration</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">while </span><span class="s1">self.skipfunc(self.pos):</span>
                <span class="s1">self.pos += </span><span class="s5">1</span>
                <span class="s3"># assert for mypy, data is Iterator[str] or None, would error in next</span>
                <span class="s2">assert </span><span class="s1">self.data </span><span class="s2">is not None</span>
                <span class="s1">next(self.data)</span>

            <span class="s2">while True</span><span class="s1">:</span>
                <span class="s1">orig_line = self._next_iter_line(row_num=self.pos + </span><span class="s5">1</span><span class="s1">)</span>
                <span class="s1">self.pos += </span><span class="s5">1</span>

                <span class="s2">if </span><span class="s1">orig_line </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">line = self._check_comments([orig_line])[</span><span class="s5">0</span><span class="s1">]</span>

                    <span class="s2">if </span><span class="s1">self.skip_blank_lines:</span>
                        <span class="s1">ret = self._remove_empty_lines([line])</span>

                        <span class="s2">if </span><span class="s1">ret:</span>
                            <span class="s1">line = ret[</span><span class="s5">0</span><span class="s1">]</span>
                            <span class="s2">break</span>
                    <span class="s2">elif </span><span class="s1">self._is_line_empty(orig_line) </span><span class="s2">or </span><span class="s1">line:</span>
                        <span class="s2">break</span>

        <span class="s3"># This was the first line of the file,</span>
        <span class="s3"># which could contain the BOM at the</span>
        <span class="s3"># beginning of it.</span>
        <span class="s2">if </span><span class="s1">self.pos == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">line = self._check_for_bom(line)</span>

        <span class="s1">self.line_pos += </span><span class="s5">1</span>
        <span class="s1">self.buf.append(line)</span>
        <span class="s2">return </span><span class="s1">line</span>

    <span class="s2">def </span><span class="s1">_alert_malformed(self</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">row_num):</span>
        <span class="s0">&quot;&quot;&quot; 
        Alert a user about a malformed row. 
 
        If `self.error_bad_lines` is True, the alert will be `ParserError`. 
        If `self.warn_bad_lines` is True, the alert will be printed out. 
 
        Parameters 
        ---------- 
        msg : The error message to display. 
        row_num : The row number where the parsing error occurred. 
                  Because this row number is displayed, we 1-index, 
                  even though we 0-index internally. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.error_bad_lines:</span>
            <span class="s2">raise </span><span class="s1">ParserError(msg)</span>
        <span class="s2">elif </span><span class="s1">self.warn_bad_lines:</span>
            <span class="s1">base = </span><span class="s4">f&quot;Skipping line </span><span class="s2">{</span><span class="s1">row_num</span><span class="s2">}</span><span class="s4">: &quot;</span>
            <span class="s1">sys.stderr.write(base + msg + </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_next_iter_line(self</span><span class="s2">, </span><span class="s1">row_num):</span>
        <span class="s0">&quot;&quot;&quot; 
        Wrapper around iterating through `self.data` (CSV source). 
 
        When a CSV error is raised, we check for specific 
        error messages that allow us to customize the 
        error message displayed to the user. 
 
        Parameters 
        ---------- 
        row_num : The row number of the line being parsed. 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s3"># assert for mypy, data is Iterator[str] or None, would error in next</span>
            <span class="s2">assert </span><span class="s1">self.data </span><span class="s2">is not None</span>
            <span class="s2">return </span><span class="s1">next(self.data)</span>
        <span class="s2">except </span><span class="s1">csv.Error </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">if </span><span class="s1">self.warn_bad_lines </span><span class="s2">or </span><span class="s1">self.error_bad_lines:</span>
                <span class="s1">msg = str(e)</span>

                <span class="s2">if </span><span class="s4">&quot;NULL byte&quot; </span><span class="s2">in </span><span class="s1">msg </span><span class="s2">or </span><span class="s4">&quot;line contains NUL&quot; </span><span class="s2">in </span><span class="s1">msg:</span>
                    <span class="s1">msg = (</span>
                        <span class="s4">&quot;NULL byte detected. This byte &quot;</span>
                        <span class="s4">&quot;cannot be processed in Python's &quot;</span>
                        <span class="s4">&quot;native csv library at the moment, &quot;</span>
                        <span class="s4">&quot;so please pass in engine='c' instead&quot;</span>
                    <span class="s1">)</span>

                <span class="s2">if </span><span class="s1">self.skipfooter &gt; </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">reason = (</span>
                        <span class="s4">&quot;Error could possibly be due to &quot;</span>
                        <span class="s4">&quot;parsing errors in the skipped footer rows &quot;</span>
                        <span class="s4">&quot;(the skipfooter keyword is only applied &quot;</span>
                        <span class="s4">&quot;after Python's csv library has parsed &quot;</span>
                        <span class="s4">&quot;all rows).&quot;</span>
                    <span class="s1">)</span>
                    <span class="s1">msg += </span><span class="s4">&quot;. &quot; </span><span class="s1">+ reason</span>

                <span class="s1">self._alert_malformed(msg</span><span class="s2">, </span><span class="s1">row_num)</span>
            <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_check_comments(self</span><span class="s2">, </span><span class="s1">lines):</span>
        <span class="s2">if </span><span class="s1">self.comment </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines</span>
        <span class="s1">ret = []</span>
        <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">lines:</span>
            <span class="s1">rl = []</span>
            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">line:</span>
                <span class="s2">if not </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">or </span><span class="s1">self.comment </span><span class="s2">not in </span><span class="s1">x:</span>
                    <span class="s1">rl.append(x)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">x = x[: x.find(self.comment)]</span>
                    <span class="s2">if </span><span class="s1">len(x) &gt; </span><span class="s5">0</span><span class="s1">:</span>
                        <span class="s1">rl.append(x)</span>
                    <span class="s2">break</span>
            <span class="s1">ret.append(rl)</span>
        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s2">def </span><span class="s1">_remove_empty_lines(self</span><span class="s2">, </span><span class="s1">lines):</span>
        <span class="s0">&quot;&quot;&quot; 
        Iterate through the lines and remove any that are 
        either empty or contain only one whitespace value 
 
        Parameters 
        ---------- 
        lines : array-like 
            The array of lines that we are to filter. 
 
        Returns 
        ------- 
        filtered_lines : array-like 
            The same array of lines with the &quot;empty&quot; ones removed. 
        &quot;&quot;&quot;</span>
        <span class="s1">ret = []</span>
        <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">lines:</span>
            <span class="s3"># Remove empty lines and lines with only one whitespace value</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">len(line) &gt; </span><span class="s5">1</span>
                <span class="s2">or </span><span class="s1">len(line) == </span><span class="s5">1</span>
                <span class="s2">and </span><span class="s1">(</span><span class="s2">not </span><span class="s1">isinstance(line[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">or </span><span class="s1">line[</span><span class="s5">0</span><span class="s1">].strip())</span>
            <span class="s1">):</span>
                <span class="s1">ret.append(line)</span>
        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s2">def </span><span class="s1">_check_thousands(self</span><span class="s2">, </span><span class="s1">lines):</span>
        <span class="s2">if </span><span class="s1">self.thousands </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines</span>

        <span class="s2">return </span><span class="s1">self._search_replace_num_columns(</span>
            <span class="s1">lines=lines</span><span class="s2">, </span><span class="s1">search=self.thousands</span><span class="s2">, </span><span class="s1">replace=</span><span class="s4">&quot;&quot;</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_search_replace_num_columns(self</span><span class="s2">, </span><span class="s1">lines</span><span class="s2">, </span><span class="s1">search</span><span class="s2">, </span><span class="s1">replace):</span>
        <span class="s1">ret = []</span>
        <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">lines:</span>
            <span class="s1">rl = []</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">enumerate(line):</span>
                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s2">not </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">str)</span>
                    <span class="s2">or </span><span class="s1">search </span><span class="s2">not in </span><span class="s1">x</span>
                    <span class="s2">or </span><span class="s1">(self._no_thousands_columns </span><span class="s2">and </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self._no_thousands_columns)</span>
                    <span class="s2">or </span><span class="s1">self.nonnum.search(x.strip())</span>
                <span class="s1">):</span>
                    <span class="s1">rl.append(x)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">rl.append(x.replace(search</span><span class="s2">, </span><span class="s1">replace))</span>
            <span class="s1">ret.append(rl)</span>
        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s2">def </span><span class="s1">_check_decimal(self</span><span class="s2">, </span><span class="s1">lines):</span>
        <span class="s2">if </span><span class="s1">self.decimal == _parser_defaults[</span><span class="s4">&quot;decimal&quot;</span><span class="s1">]:</span>
            <span class="s2">return </span><span class="s1">lines</span>

        <span class="s2">return </span><span class="s1">self._search_replace_num_columns(</span>
            <span class="s1">lines=lines</span><span class="s2">, </span><span class="s1">search=self.decimal</span><span class="s2">, </span><span class="s1">replace=</span><span class="s4">&quot;.&quot;</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_clear_buffer(self):</span>
        <span class="s1">self.buf = []</span>

    <span class="s1">_implicit_index = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">_get_index_name(self</span><span class="s2">, </span><span class="s1">columns):</span>
        <span class="s0">&quot;&quot;&quot; 
        Try several cases to get lines: 
 
        0) There are headers on row 0 and row 1 and their 
        total summed lengths equals the length of the next line. 
        Treat row 0 as columns and row 1 as indices 
        1) Look for implicit index: there are more columns 
        on row 1 than row 0. If this is true, assume that row 
        1 lists index columns and row 0 lists normal columns. 
        2) Get index from the columns if it was listed. 
        &quot;&quot;&quot;</span>
        <span class="s1">orig_names = list(columns)</span>
        <span class="s1">columns = list(columns)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">line = self._next_line()</span>
        <span class="s2">except </span><span class="s1">StopIteration:</span>
            <span class="s1">line = </span><span class="s2">None</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">next_line = self._next_line()</span>
        <span class="s2">except </span><span class="s1">StopIteration:</span>
            <span class="s1">next_line = </span><span class="s2">None</span>

        <span class="s3"># implicitly index_col=0 b/c 1 fewer column names</span>
        <span class="s1">implicit_first_cols = </span><span class="s5">0</span>
        <span class="s2">if </span><span class="s1">line </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s3"># leave it 0, #2442</span>
            <span class="s3"># Case 1</span>
            <span class="s2">if </span><span class="s1">self.index_col </span><span class="s2">is not False</span><span class="s1">:</span>
                <span class="s1">implicit_first_cols = len(line) - self.num_original_columns</span>

            <span class="s3"># Case 0</span>
            <span class="s2">if </span><span class="s1">next_line </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">len(next_line) == len(line) + self.num_original_columns:</span>
                    <span class="s3"># column and index names on diff rows</span>
                    <span class="s1">self.index_col = list(range(len(line)))</span>
                    <span class="s1">self.buf = self.buf[</span><span class="s5">1</span><span class="s1">:]</span>

                    <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">reversed(line):</span>
                        <span class="s1">columns.insert(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">c)</span>

                    <span class="s3"># Update list of original names to include all indices.</span>
                    <span class="s1">orig_names = list(columns)</span>
                    <span class="s1">self.num_original_columns = len(columns)</span>
                    <span class="s2">return </span><span class="s1">line</span><span class="s2">, </span><span class="s1">orig_names</span><span class="s2">, </span><span class="s1">columns</span>

        <span class="s2">if </span><span class="s1">implicit_first_cols &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3"># Case 1</span>
            <span class="s1">self._implicit_index = </span><span class="s2">True</span>
            <span class="s2">if </span><span class="s1">self.index_col </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">self.index_col = list(range(implicit_first_cols))</span>

            <span class="s1">index_name = </span><span class="s2">None</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># Case 2</span>
            <span class="s1">(index_name</span><span class="s2">, </span><span class="s1">columns_</span><span class="s2">, </span><span class="s1">self.index_col) = _clean_index_names(</span>
                <span class="s1">columns</span><span class="s2">, </span><span class="s1">self.index_col</span><span class="s2">, </span><span class="s1">self.unnamed_cols</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">index_name</span><span class="s2">, </span><span class="s1">orig_names</span><span class="s2">, </span><span class="s1">columns</span>

    <span class="s2">def </span><span class="s1">_rows_to_cols(self</span><span class="s2">, </span><span class="s1">content):</span>
        <span class="s1">col_len = self.num_original_columns</span>

        <span class="s2">if </span><span class="s1">self._implicit_index:</span>
            <span class="s1">col_len += len(self.index_col)</span>

        <span class="s1">max_len = max(len(row) </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">content)</span>

        <span class="s3"># Check that there are no rows with too many</span>
        <span class="s3"># elements in their row (rows with too few</span>
        <span class="s3"># elements are padded with NaN).</span>
        <span class="s2">if </span><span class="s1">max_len &gt; col_len </span><span class="s2">and </span><span class="s1">self.index_col </span><span class="s2">is not False and </span><span class="s1">self.usecols </span><span class="s2">is None</span><span class="s1">:</span>

            <span class="s1">footers = self.skipfooter </span><span class="s2">if </span><span class="s1">self.skipfooter </span><span class="s2">else </span><span class="s5">0</span>
            <span class="s1">bad_lines = []</span>

            <span class="s1">iter_content = enumerate(content)</span>
            <span class="s1">content_len = len(content)</span>
            <span class="s1">content = []</span>

            <span class="s2">for </span><span class="s1">(i</span><span class="s2">, </span><span class="s1">l) </span><span class="s2">in </span><span class="s1">iter_content:</span>
                <span class="s1">actual_len = len(l)</span>

                <span class="s2">if </span><span class="s1">actual_len &gt; col_len:</span>
                    <span class="s2">if </span><span class="s1">self.error_bad_lines </span><span class="s2">or </span><span class="s1">self.warn_bad_lines:</span>
                        <span class="s1">row_num = self.pos - (content_len - i + footers)</span>
                        <span class="s1">bad_lines.append((row_num</span><span class="s2">, </span><span class="s1">actual_len))</span>

                        <span class="s2">if </span><span class="s1">self.error_bad_lines:</span>
                            <span class="s2">break</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">content.append(l)</span>

            <span class="s2">for </span><span class="s1">row_num</span><span class="s2">, </span><span class="s1">actual_len </span><span class="s2">in </span><span class="s1">bad_lines:</span>
                <span class="s1">msg = (</span>
                    <span class="s4">f&quot;Expected </span><span class="s2">{</span><span class="s1">col_len</span><span class="s2">} </span><span class="s4">fields in line </span><span class="s2">{</span><span class="s1">row_num + </span><span class="s5">1</span><span class="s2">}</span><span class="s4">, saw &quot;</span>
                    <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">actual_len</span><span class="s2">}</span><span class="s4">&quot;</span>
                <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">self.delimiter</span>
                    <span class="s2">and </span><span class="s1">len(self.delimiter) &gt; </span><span class="s5">1</span>
                    <span class="s2">and </span><span class="s1">self.quoting != csv.QUOTE_NONE</span>
                <span class="s1">):</span>
                    <span class="s3"># see gh-13374</span>
                    <span class="s1">reason = (</span>
                        <span class="s4">&quot;Error could possibly be due to quotes being &quot;</span>
                        <span class="s4">&quot;ignored when a multi-char delimiter is used.&quot;</span>
                    <span class="s1">)</span>
                    <span class="s1">msg += </span><span class="s4">&quot;. &quot; </span><span class="s1">+ reason</span>

                <span class="s1">self._alert_malformed(msg</span><span class="s2">, </span><span class="s1">row_num + </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s3"># see gh-13320</span>
        <span class="s1">zipped_content = list(lib.to_object_array(content</span><span class="s2">, </span><span class="s1">min_width=col_len).T)</span>

        <span class="s2">if </span><span class="s1">self.usecols:</span>
            <span class="s2">if </span><span class="s1">self._implicit_index:</span>
                <span class="s1">zipped_content = [</span>
                    <span class="s1">a</span>
                    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">a </span><span class="s2">in </span><span class="s1">enumerate(zipped_content)</span>
                    <span class="s2">if </span><span class="s1">(</span>
                        <span class="s1">i &lt; len(self.index_col)</span>
                        <span class="s3"># pandas\io\parsers.py:3159: error: Unsupported right</span>
                        <span class="s3"># operand type for in (&quot;Optional[Any]&quot;)  [operator]</span>
                        <span class="s2">or </span><span class="s1">i - len(self.index_col)  </span><span class="s3"># type: ignore[operator]</span>
                        <span class="s2">in </span><span class="s1">self._col_indices</span>
                    <span class="s1">)</span>
                <span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">zipped_content = [</span>
                    <span class="s3"># pandas\io\parsers.py:3164: error: Unsupported right</span>
                    <span class="s3"># operand type for in (&quot;Optional[Any]&quot;)  [operator]</span>
                    <span class="s1">a</span>
                    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">a </span><span class="s2">in </span><span class="s1">enumerate(zipped_content)</span>
                    <span class="s2">if </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self._col_indices  </span><span class="s3"># type: ignore[operator]</span>
                <span class="s1">]</span>
        <span class="s2">return </span><span class="s1">zipped_content</span>

    <span class="s2">def </span><span class="s1">_get_lines(self</span><span class="s2">, </span><span class="s1">rows=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">lines = self.buf</span>
        <span class="s1">new_rows = </span><span class="s2">None</span>

        <span class="s3"># already fetched some number</span>
        <span class="s2">if </span><span class="s1">rows </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s3"># we already have the lines in the buffer</span>
            <span class="s2">if </span><span class="s1">len(self.buf) &gt;= rows:</span>
                <span class="s1">new_rows</span><span class="s2">, </span><span class="s1">self.buf = self.buf[:rows]</span><span class="s2">, </span><span class="s1">self.buf[rows:]</span>

            <span class="s3"># need some lines</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">rows -= len(self.buf)</span>

        <span class="s2">if </span><span class="s1">new_rows </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(self.data</span><span class="s2">, </span><span class="s1">list):</span>
                <span class="s2">if </span><span class="s1">self.pos &gt; len(self.data):</span>
                    <span class="s2">raise </span><span class="s1">StopIteration</span>
                <span class="s2">if </span><span class="s1">rows </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">new_rows = self.data[self.pos :]</span>
                    <span class="s1">new_pos = len(self.data)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">new_rows = self.data[self.pos : self.pos + rows]</span>
                    <span class="s1">new_pos = self.pos + rows</span>

                <span class="s3"># Check for stop rows. n.b.: self.skiprows is a set.</span>
                <span class="s2">if </span><span class="s1">self.skiprows:</span>
                    <span class="s1">new_rows = [</span>
                        <span class="s1">row</span>
                        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">row </span><span class="s2">in </span><span class="s1">enumerate(new_rows)</span>
                        <span class="s2">if not </span><span class="s1">self.skipfunc(i + self.pos)</span>
                    <span class="s1">]</span>

                <span class="s1">lines.extend(new_rows)</span>
                <span class="s1">self.pos = new_pos</span>

            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">new_rows = []</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">rows </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(rows):</span>
                            <span class="s3"># assert for mypy, data is Iterator[str] or None, would</span>
                            <span class="s3"># error in next</span>
                            <span class="s2">assert </span><span class="s1">self.data </span><span class="s2">is not None</span>
                            <span class="s1">new_rows.append(next(self.data))</span>
                        <span class="s1">lines.extend(new_rows)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">rows = </span><span class="s5">0</span>

                        <span class="s2">while True</span><span class="s1">:</span>
                            <span class="s1">new_row = self._next_iter_line(row_num=self.pos + rows + </span><span class="s5">1</span><span class="s1">)</span>
                            <span class="s1">rows += </span><span class="s5">1</span>

                            <span class="s2">if </span><span class="s1">new_row </span><span class="s2">is not None</span><span class="s1">:</span>
                                <span class="s1">new_rows.append(new_row)</span>

                <span class="s2">except </span><span class="s1">StopIteration:</span>
                    <span class="s2">if </span><span class="s1">self.skiprows:</span>
                        <span class="s1">new_rows = [</span>
                            <span class="s1">row</span>
                            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">row </span><span class="s2">in </span><span class="s1">enumerate(new_rows)</span>
                            <span class="s2">if not </span><span class="s1">self.skipfunc(i + self.pos)</span>
                        <span class="s1">]</span>
                    <span class="s1">lines.extend(new_rows)</span>
                    <span class="s2">if </span><span class="s1">len(lines) == </span><span class="s5">0</span><span class="s1">:</span>
                        <span class="s2">raise</span>
                <span class="s1">self.pos += len(new_rows)</span>

            <span class="s1">self.buf = []</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">lines = new_rows</span>

        <span class="s2">if </span><span class="s1">self.skipfooter:</span>
            <span class="s1">lines = lines[: -self.skipfooter]</span>

        <span class="s1">lines = self._check_comments(lines)</span>
        <span class="s2">if </span><span class="s1">self.skip_blank_lines:</span>
            <span class="s1">lines = self._remove_empty_lines(lines)</span>
        <span class="s1">lines = self._check_thousands(lines)</span>
        <span class="s2">return </span><span class="s1">self._check_decimal(lines)</span>


<span class="s2">def </span><span class="s1">_make_date_converter(</span>
    <span class="s1">date_parser=</span><span class="s2">None, </span><span class="s1">dayfirst=</span><span class="s2">False, </span><span class="s1">infer_datetime_format=</span><span class="s2">False, </span><span class="s1">cache_dates=</span><span class="s2">True</span>
<span class="s1">):</span>
    <span class="s2">def </span><span class="s1">converter(*date_cols):</span>
        <span class="s2">if </span><span class="s1">date_parser </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">strs = parsing.concat_date_cols(date_cols)</span>

            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">tools.to_datetime(</span>
                    <span class="s1">ensure_object(strs)</span><span class="s2">,</span>
                    <span class="s1">utc=</span><span class="s2">None,</span>
                    <span class="s1">dayfirst=dayfirst</span><span class="s2">,</span>
                    <span class="s1">errors=</span><span class="s4">&quot;ignore&quot;</span><span class="s2">,</span>
                    <span class="s1">infer_datetime_format=infer_datetime_format</span><span class="s2">,</span>
                    <span class="s1">cache=cache_dates</span><span class="s2">,</span>
                <span class="s1">).to_numpy()</span>

            <span class="s2">except </span><span class="s1">ValueError:</span>
                <span class="s2">return </span><span class="s1">tools.to_datetime(</span>
                    <span class="s1">parsing.try_parse_dates(strs</span><span class="s2">, </span><span class="s1">dayfirst=dayfirst)</span><span class="s2">, </span><span class="s1">cache=cache_dates</span>
                <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">result = tools.to_datetime(</span>
                    <span class="s1">date_parser(*date_cols)</span><span class="s2">, </span><span class="s1">errors=</span><span class="s4">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">cache=cache_dates</span>
                <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">datetime.datetime):</span>
                    <span class="s2">raise </span><span class="s1">Exception(</span><span class="s4">&quot;scalar parser&quot;</span><span class="s1">)</span>
                <span class="s2">return </span><span class="s1">result</span>
            <span class="s2">except </span><span class="s1">Exception:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">tools.to_datetime(</span>
                        <span class="s1">parsing.try_parse_dates(</span>
                            <span class="s1">parsing.concat_date_cols(date_cols)</span><span class="s2">,</span>
                            <span class="s1">parser=date_parser</span><span class="s2">,</span>
                            <span class="s1">dayfirst=dayfirst</span><span class="s2">,</span>
                        <span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">errors=</span><span class="s4">&quot;ignore&quot;</span><span class="s2">,</span>
                    <span class="s1">)</span>
                <span class="s2">except </span><span class="s1">Exception:</span>
                    <span class="s2">return </span><span class="s1">generic_parser(date_parser</span><span class="s2">, </span><span class="s1">*date_cols)</span>

    <span class="s2">return </span><span class="s1">converter</span>


<span class="s2">def </span><span class="s1">_process_date_conversion(</span>
    <span class="s1">data_dict</span><span class="s2">,</span>
    <span class="s1">converter</span><span class="s2">,</span>
    <span class="s1">parse_spec</span><span class="s2">,</span>
    <span class="s1">index_col</span><span class="s2">,</span>
    <span class="s1">index_names</span><span class="s2">,</span>
    <span class="s1">columns</span><span class="s2">,</span>
    <span class="s1">keep_date_col=</span><span class="s2">False,</span>
<span class="s1">):</span>
    <span class="s2">def </span><span class="s1">_isindex(colspec):</span>
        <span class="s2">return </span><span class="s1">(isinstance(index_col</span><span class="s2">, </span><span class="s1">list) </span><span class="s2">and </span><span class="s1">colspec </span><span class="s2">in </span><span class="s1">index_col) </span><span class="s2">or </span><span class="s1">(</span>
            <span class="s1">isinstance(index_names</span><span class="s2">, </span><span class="s1">list) </span><span class="s2">and </span><span class="s1">colspec </span><span class="s2">in </span><span class="s1">index_names</span>
        <span class="s1">)</span>

    <span class="s1">new_cols = []</span>
    <span class="s1">new_data = {}</span>

    <span class="s1">orig_names = columns</span>
    <span class="s1">columns = list(columns)</span>

    <span class="s1">date_cols = set()</span>

    <span class="s2">if </span><span class="s1">parse_spec </span><span class="s2">is None or </span><span class="s1">isinstance(parse_spec</span><span class="s2">, </span><span class="s1">bool):</span>
        <span class="s2">return </span><span class="s1">data_dict</span><span class="s2">, </span><span class="s1">columns</span>

    <span class="s2">if </span><span class="s1">isinstance(parse_spec</span><span class="s2">, </span><span class="s1">list):</span>
        <span class="s3"># list of column lists</span>
        <span class="s2">for </span><span class="s1">colspec </span><span class="s2">in </span><span class="s1">parse_spec:</span>
            <span class="s2">if </span><span class="s1">is_scalar(colspec):</span>
                <span class="s2">if </span><span class="s1">isinstance(colspec</span><span class="s2">, </span><span class="s1">int) </span><span class="s2">and </span><span class="s1">colspec </span><span class="s2">not in </span><span class="s1">data_dict:</span>
                    <span class="s1">colspec = orig_names[colspec]</span>
                <span class="s2">if </span><span class="s1">_isindex(colspec):</span>
                    <span class="s2">continue</span>
                <span class="s1">data_dict[colspec] = converter(data_dict[colspec])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">new_name</span><span class="s2">, </span><span class="s1">col</span><span class="s2">, </span><span class="s1">old_names = _try_convert_dates(</span>
                    <span class="s1">converter</span><span class="s2">, </span><span class="s1">colspec</span><span class="s2">, </span><span class="s1">data_dict</span><span class="s2">, </span><span class="s1">orig_names</span>
                <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">new_name </span><span class="s2">in </span><span class="s1">data_dict:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;New date column already in dict </span><span class="s2">{</span><span class="s1">new_name</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
                <span class="s1">new_data[new_name] = col</span>
                <span class="s1">new_cols.append(new_name)</span>
                <span class="s1">date_cols.update(old_names)</span>

    <span class="s2">elif </span><span class="s1">isinstance(parse_spec</span><span class="s2">, </span><span class="s1">dict):</span>
        <span class="s3"># dict of new name to column list</span>
        <span class="s2">for </span><span class="s1">new_name</span><span class="s2">, </span><span class="s1">colspec </span><span class="s2">in </span><span class="s1">parse_spec.items():</span>
            <span class="s2">if </span><span class="s1">new_name </span><span class="s2">in </span><span class="s1">data_dict:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Date column </span><span class="s2">{</span><span class="s1">new_name</span><span class="s2">} </span><span class="s4">already in dict&quot;</span><span class="s1">)</span>

            <span class="s1">_</span><span class="s2">, </span><span class="s1">col</span><span class="s2">, </span><span class="s1">old_names = _try_convert_dates(</span>
                <span class="s1">converter</span><span class="s2">, </span><span class="s1">colspec</span><span class="s2">, </span><span class="s1">data_dict</span><span class="s2">, </span><span class="s1">orig_names</span>
            <span class="s1">)</span>

            <span class="s1">new_data[new_name] = col</span>
            <span class="s1">new_cols.append(new_name)</span>
            <span class="s1">date_cols.update(old_names)</span>

    <span class="s1">data_dict.update(new_data)</span>
    <span class="s1">new_cols.extend(columns)</span>

    <span class="s2">if not </span><span class="s1">keep_date_col:</span>
        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">list(date_cols):</span>
            <span class="s1">data_dict.pop(c)</span>
            <span class="s1">new_cols.remove(c)</span>

    <span class="s2">return </span><span class="s1">data_dict</span><span class="s2">, </span><span class="s1">new_cols</span>


<span class="s2">def </span><span class="s1">_try_convert_dates(parser</span><span class="s2">, </span><span class="s1">colspec</span><span class="s2">, </span><span class="s1">data_dict</span><span class="s2">, </span><span class="s1">columns):</span>
    <span class="s1">colset = set(columns)</span>
    <span class="s1">colnames = []</span>

    <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">colspec:</span>
        <span class="s2">if </span><span class="s1">c </span><span class="s2">in </span><span class="s1">colset:</span>
            <span class="s1">colnames.append(c)</span>
        <span class="s2">elif </span><span class="s1">isinstance(c</span><span class="s2">, </span><span class="s1">int) </span><span class="s2">and </span><span class="s1">c </span><span class="s2">not in </span><span class="s1">columns:</span>
            <span class="s1">colnames.append(columns[c])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">colnames.append(c)</span>

    <span class="s1">new_name = </span><span class="s4">&quot;_&quot;</span><span class="s1">.join(str(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">colnames)</span>
    <span class="s1">to_parse = [data_dict[c] </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">colnames </span><span class="s2">if </span><span class="s1">c </span><span class="s2">in </span><span class="s1">data_dict]</span>

    <span class="s1">new_col = parser(*to_parse)</span>
    <span class="s2">return </span><span class="s1">new_name</span><span class="s2">, </span><span class="s1">new_col</span><span class="s2">, </span><span class="s1">colnames</span>


<span class="s2">def </span><span class="s1">_clean_na_values(na_values</span><span class="s2">, </span><span class="s1">keep_default_na=</span><span class="s2">True</span><span class="s1">):</span>

    <span class="s2">if </span><span class="s1">na_values </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">keep_default_na:</span>
            <span class="s1">na_values = STR_NA_VALUES</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">na_values = set()</span>
        <span class="s3"># pandas\io\parsers.py:3387: error: Need type annotation for</span>
        <span class="s3"># 'na_fvalues' (hint: &quot;na_fvalues: Set[&lt;type&gt;] = ...&quot;)  [var-annotated]</span>
        <span class="s1">na_fvalues = set()  </span><span class="s3"># type: ignore[var-annotated]</span>
    <span class="s2">elif </span><span class="s1">isinstance(na_values</span><span class="s2">, </span><span class="s1">dict):</span>
        <span class="s1">old_na_values = na_values.copy()</span>
        <span class="s1">na_values = {}  </span><span class="s3"># Prevent aliasing.</span>

        <span class="s3"># Convert the values in the na_values dictionary</span>
        <span class="s3"># into array-likes for further use. This is also</span>
        <span class="s3"># where we append the default NaN values, provided</span>
        <span class="s3"># that `keep_default_na=True`.</span>
        <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">old_na_values.items():</span>
            <span class="s2">if not </span><span class="s1">is_list_like(v):</span>
                <span class="s1">v = [v]</span>

            <span class="s2">if </span><span class="s1">keep_default_na:</span>
                <span class="s1">v = set(v) | STR_NA_VALUES</span>

            <span class="s1">na_values[k] = v</span>
        <span class="s3"># pandas\io\parsers.py:3404: error: Incompatible types in assignment</span>
        <span class="s3"># (expression has type &quot;Dict[Any, Any]&quot;, variable has type &quot;Set[Any]&quot;)</span>
        <span class="s3"># [assignment]</span>
        <span class="s1">na_fvalues = {  </span><span class="s3"># type: ignore[assignment]</span>
            <span class="s1">k: _floatify_na_values(v) </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">na_values.items()</span>
        <span class="s1">}</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if not </span><span class="s1">is_list_like(na_values):</span>
            <span class="s1">na_values = [na_values]</span>
        <span class="s1">na_values = _stringify_na_values(na_values)</span>
        <span class="s2">if </span><span class="s1">keep_default_na:</span>
            <span class="s1">na_values = na_values | STR_NA_VALUES</span>

        <span class="s1">na_fvalues = _floatify_na_values(na_values)</span>

    <span class="s2">return </span><span class="s1">na_values</span><span class="s2">, </span><span class="s1">na_fvalues</span>


<span class="s2">def </span><span class="s1">_clean_index_names(columns</span><span class="s2">, </span><span class="s1">index_col</span><span class="s2">, </span><span class="s1">unnamed_cols):</span>
    <span class="s2">if not </span><span class="s1">_is_index_col(index_col):</span>
        <span class="s2">return None, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">index_col</span>

    <span class="s1">columns = list(columns)</span>

    <span class="s1">cp_cols = list(columns)</span>
    <span class="s1">index_names = []</span>

    <span class="s3"># don't mutate</span>
    <span class="s1">index_col = list(index_col)</span>

    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">c </span><span class="s2">in </span><span class="s1">enumerate(index_col):</span>
        <span class="s2">if </span><span class="s1">isinstance(c</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">index_names.append(c)</span>
            <span class="s2">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">enumerate(cp_cols):</span>
                <span class="s2">if </span><span class="s1">name == c:</span>
                    <span class="s1">index_col[i] = j</span>
                    <span class="s1">columns.remove(name)</span>
                    <span class="s2">break</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">name = cp_cols[c]</span>
            <span class="s1">columns.remove(name)</span>
            <span class="s1">index_names.append(name)</span>

    <span class="s3"># Only clean index names that were placeholders.</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">enumerate(index_names):</span>
        <span class="s2">if </span><span class="s1">isinstance(name</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">name </span><span class="s2">in </span><span class="s1">unnamed_cols:</span>
            <span class="s3"># pandas\io\parsers.py:3445: error: No overload variant of</span>
            <span class="s3"># &quot;__setitem__&quot; of &quot;list&quot; matches argument types &quot;int&quot;, &quot;None&quot;</span>
            <span class="s3"># [call-overload]</span>
            <span class="s1">index_names[i] = </span><span class="s2">None  </span><span class="s3"># type: ignore[call-overload]</span>

    <span class="s2">return </span><span class="s1">index_names</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">index_col</span>


<span class="s2">def </span><span class="s1">_get_empty_meta(columns</span><span class="s2">, </span><span class="s1">index_col</span><span class="s2">, </span><span class="s1">index_names</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s1">columns = list(columns)</span>

    <span class="s3"># Convert `dtype` to a defaultdict of some kind.</span>
    <span class="s3"># This will enable us to write `dtype[col_name]`</span>
    <span class="s3"># without worrying about KeyError issues later on.</span>
    <span class="s2">if not </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">dict):</span>
        <span class="s3"># if dtype == None, default will be object.</span>
        <span class="s1">default_dtype = dtype </span><span class="s2">or </span><span class="s1">object</span>
        <span class="s1">dtype = defaultdict(</span><span class="s2">lambda</span><span class="s1">: default_dtype)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s3"># Save a copy of the dictionary.</span>
        <span class="s1">_dtype = dtype.copy()</span>
        <span class="s1">dtype = defaultdict(</span><span class="s2">lambda</span><span class="s1">: object)</span>

        <span class="s3"># Convert column indexes to column names.</span>
        <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">_dtype.items():</span>
            <span class="s1">col = columns[k] </span><span class="s2">if </span><span class="s1">is_integer(k) </span><span class="s2">else </span><span class="s1">k</span>
            <span class="s1">dtype[col] = v</span>

    <span class="s3"># Even though we have no data, the &quot;index&quot; of the empty DataFrame</span>
    <span class="s3"># could for example still be an empty MultiIndex. Thus, we need to</span>
    <span class="s3"># check whether we have any index columns specified, via either:</span>
    <span class="s3">#</span>
    <span class="s3"># 1) index_col (column indices)</span>
    <span class="s3"># 2) index_names (column names)</span>
    <span class="s3">#</span>
    <span class="s3"># Both must be non-null to ensure a successful construction. Otherwise,</span>
    <span class="s3"># we have to create a generic empty Index.</span>
    <span class="s2">if </span><span class="s1">(index_col </span><span class="s2">is None or </span><span class="s1">index_col </span><span class="s2">is False</span><span class="s1">) </span><span class="s2">or </span><span class="s1">index_names </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">index = Index([])</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">data = [Series([]</span><span class="s2">, </span><span class="s1">dtype=dtype[name]) </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">index_names]</span>
        <span class="s1">index = ensure_index_from_sequences(data</span><span class="s2">, </span><span class="s1">names=index_names)</span>
        <span class="s1">index_col.sort()</span>

        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">n </span><span class="s2">in </span><span class="s1">enumerate(index_col):</span>
            <span class="s1">columns.pop(n - i)</span>

    <span class="s1">col_dict = {col_name: Series([]</span><span class="s2">, </span><span class="s1">dtype=dtype[col_name]) </span><span class="s2">for </span><span class="s1">col_name </span><span class="s2">in </span><span class="s1">columns}</span>

    <span class="s2">return </span><span class="s1">index</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">col_dict</span>


<span class="s2">def </span><span class="s1">_floatify_na_values(na_values):</span>
    <span class="s3"># create float versions of the na_values</span>
    <span class="s1">result = set()</span>
    <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">na_values:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">v = float(v)</span>
            <span class="s2">if not </span><span class="s1">np.isnan(v):</span>
                <span class="s1">result.add(v)</span>
        <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">OverflowError):</span>
            <span class="s2">pass</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">_stringify_na_values(na_values):</span>
    <span class="s0">&quot;&quot;&quot; return a stringified and numeric for these values &quot;&quot;&quot;</span>
    <span class="s1">result = []</span>
    <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">na_values:</span>
        <span class="s1">result.append(str(x))</span>
        <span class="s1">result.append(x)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">v = float(x)</span>

            <span class="s3"># we are like 999 here</span>
            <span class="s2">if </span><span class="s1">v == int(v):</span>
                <span class="s1">v = int(v)</span>
                <span class="s1">result.append(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">v</span><span class="s2">}</span><span class="s4">.0&quot;</span><span class="s1">)</span>
                <span class="s1">result.append(str(v))</span>

            <span class="s3"># pandas\io\parsers.py:3522: error: Argument 1 to &quot;append&quot; of</span>
            <span class="s3"># &quot;list&quot; has incompatible type &quot;float&quot;; expected &quot;str&quot;  [arg-type]</span>
            <span class="s1">result.append(v)  </span><span class="s3"># type: ignore[arg-type]</span>
        <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">OverflowError):</span>
            <span class="s2">pass</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s3"># pandas\io\parsers.py:3526: error: Argument 1 to &quot;append&quot; of</span>
            <span class="s3"># &quot;list&quot; has incompatible type &quot;int&quot;; expected &quot;str&quot;  [arg-type]</span>
            <span class="s1">result.append(int(x))  </span><span class="s3"># type: ignore[arg-type]</span>
        <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">OverflowError):</span>
            <span class="s2">pass</span>
    <span class="s2">return </span><span class="s1">set(result)</span>


<span class="s2">def </span><span class="s1">_get_na_values(col</span><span class="s2">, </span><span class="s1">na_values</span><span class="s2">, </span><span class="s1">na_fvalues</span><span class="s2">, </span><span class="s1">keep_default_na):</span>
    <span class="s0">&quot;&quot;&quot; 
    Get the NaN values for a given column. 
 
    Parameters 
    ---------- 
    col : str 
        The name of the column. 
    na_values : array-like, dict 
        The object listing the NaN values as strings. 
    na_fvalues : array-like, dict 
        The object listing the NaN values as floats. 
    keep_default_na : bool 
        If `na_values` is a dict, and the column is not mapped in the 
        dictionary, whether to return the default NaN values or the empty set. 
 
    Returns 
    ------- 
    nan_tuple : A length-two tuple composed of 
 
        1) na_values : the string NaN values for that column. 
        2) na_fvalues : the float NaN values for that column. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(na_values</span><span class="s2">, </span><span class="s1">dict):</span>
        <span class="s2">if </span><span class="s1">col </span><span class="s2">in </span><span class="s1">na_values:</span>
            <span class="s2">return </span><span class="s1">na_values[col]</span><span class="s2">, </span><span class="s1">na_fvalues[col]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">keep_default_na:</span>
                <span class="s2">return </span><span class="s1">STR_NA_VALUES</span><span class="s2">, </span><span class="s1">set()</span>

            <span class="s2">return </span><span class="s1">set()</span><span class="s2">, </span><span class="s1">set()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">na_values</span><span class="s2">, </span><span class="s1">na_fvalues</span>


<span class="s2">def </span><span class="s1">_get_col_names(colspec</span><span class="s2">, </span><span class="s1">columns):</span>
    <span class="s1">colset = set(columns)</span>
    <span class="s1">colnames = []</span>
    <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">colspec:</span>
        <span class="s2">if </span><span class="s1">c </span><span class="s2">in </span><span class="s1">colset:</span>
            <span class="s1">colnames.append(c)</span>
        <span class="s2">elif </span><span class="s1">isinstance(c</span><span class="s2">, </span><span class="s1">int):</span>
            <span class="s1">colnames.append(columns[c])</span>
    <span class="s2">return </span><span class="s1">colnames</span>


<span class="s2">class </span><span class="s1">FixedWidthReader(abc.Iterator):</span>
    <span class="s0">&quot;&quot;&quot; 
    A reader of fixed-width lines. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">colspecs</span><span class="s2">, </span><span class="s1">delimiter</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">, </span><span class="s1">skiprows=</span><span class="s2">None, </span><span class="s1">infer_nrows=</span><span class="s5">100</span><span class="s1">):</span>
        <span class="s1">self.f = f</span>
        <span class="s1">self.buffer = </span><span class="s2">None</span>
        <span class="s1">self.delimiter = </span><span class="s4">&quot;</span><span class="s2">\r\n</span><span class="s4">&quot; </span><span class="s1">+ delimiter </span><span class="s2">if </span><span class="s1">delimiter </span><span class="s2">else </span><span class="s4">&quot;</span><span class="s2">\n\r\t </span><span class="s4">&quot;</span>
        <span class="s1">self.comment = comment</span>
        <span class="s2">if </span><span class="s1">colspecs == </span><span class="s4">&quot;infer&quot;</span><span class="s1">:</span>
            <span class="s1">self.colspecs = self.detect_colspecs(</span>
                <span class="s1">infer_nrows=infer_nrows</span><span class="s2">, </span><span class="s1">skiprows=skiprows</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.colspecs = colspecs</span>

        <span class="s2">if not </span><span class="s1">isinstance(self.colspecs</span><span class="s2">, </span><span class="s1">(tuple</span><span class="s2">, </span><span class="s1">list)):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;column specifications must be a list or tuple, &quot;</span>
                <span class="s4">f&quot;input was a </span><span class="s2">{</span><span class="s1">type(colspecs).__name__</span><span class="s2">}</span><span class="s4">&quot;</span>
            <span class="s1">)</span>

        <span class="s2">for </span><span class="s1">colspec </span><span class="s2">in </span><span class="s1">self.colspecs:</span>
            <span class="s2">if not </span><span class="s1">(</span>
                <span class="s1">isinstance(colspec</span><span class="s2">, </span><span class="s1">(tuple</span><span class="s2">, </span><span class="s1">list))</span>
                <span class="s2">and </span><span class="s1">len(colspec) == </span><span class="s5">2</span>
                <span class="s2">and </span><span class="s1">isinstance(colspec[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">(int</span><span class="s2">, </span><span class="s1">np.integer</span><span class="s2">, </span><span class="s1">type(</span><span class="s2">None</span><span class="s1">)))</span>
                <span class="s2">and </span><span class="s1">isinstance(colspec[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">(int</span><span class="s2">, </span><span class="s1">np.integer</span><span class="s2">, </span><span class="s1">type(</span><span class="s2">None</span><span class="s1">)))</span>
            <span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s4">&quot;Each column specification must be &quot;</span>
                    <span class="s4">&quot;2 element tuple or list of integers&quot;</span>
                <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_rows(self</span><span class="s2">, </span><span class="s1">infer_nrows</span><span class="s2">, </span><span class="s1">skiprows=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Read rows from self.f, skipping as specified. 
 
        We distinguish buffer_rows (the first &lt;= infer_nrows 
        lines) from the rows returned to detect_colspecs 
        because it's simpler to leave the other locations 
        with skiprows logic alone than to modify them to 
        deal with the fact we skipped some rows here as 
        well. 
 
        Parameters 
        ---------- 
        infer_nrows : int 
            Number of rows to read from self.f, not counting 
            rows that are skipped. 
        skiprows: set, optional 
            Indices of rows to skip. 
 
        Returns 
        ------- 
        detect_rows : list of str 
            A list containing the rows to read. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">skiprows </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">skiprows = set()</span>
        <span class="s1">buffer_rows = []</span>
        <span class="s1">detect_rows = []</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">row </span><span class="s2">in </span><span class="s1">enumerate(self.f):</span>
            <span class="s2">if </span><span class="s1">i </span><span class="s2">not in </span><span class="s1">skiprows:</span>
                <span class="s1">detect_rows.append(row)</span>
            <span class="s1">buffer_rows.append(row)</span>
            <span class="s2">if </span><span class="s1">len(detect_rows) &gt;= infer_nrows:</span>
                <span class="s2">break</span>
        <span class="s1">self.buffer = iter(buffer_rows)</span>
        <span class="s2">return </span><span class="s1">detect_rows</span>

    <span class="s2">def </span><span class="s1">detect_colspecs(self</span><span class="s2">, </span><span class="s1">infer_nrows=</span><span class="s5">100</span><span class="s2">, </span><span class="s1">skiprows=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s3"># Regex escape the delimiters</span>
        <span class="s1">delimiters = </span><span class="s4">&quot;&quot;</span><span class="s1">.join(</span><span class="s4">fr&quot;\</span><span class="s2">{</span><span class="s1">x</span><span class="s2">}</span><span class="s4">&quot; </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self.delimiter)</span>
        <span class="s1">pattern = re.compile(</span><span class="s4">f&quot;([^</span><span class="s2">{</span><span class="s1">delimiters</span><span class="s2">}</span><span class="s4">]+)&quot;</span><span class="s1">)</span>
        <span class="s1">rows = self.get_rows(infer_nrows</span><span class="s2">, </span><span class="s1">skiprows)</span>
        <span class="s2">if not </span><span class="s1">rows:</span>
            <span class="s2">raise </span><span class="s1">EmptyDataError(</span><span class="s4">&quot;No rows from which to infer column width&quot;</span><span class="s1">)</span>
        <span class="s1">max_len = max(map(len</span><span class="s2">, </span><span class="s1">rows))</span>
        <span class="s1">mask = np.zeros(max_len + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype=int)</span>
        <span class="s2">if </span><span class="s1">self.comment </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">rows = [row.partition(self.comment)[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">rows]</span>
        <span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">rows:</span>
            <span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">pattern.finditer(row):</span>
                <span class="s1">mask[m.start() : m.end()] = </span><span class="s5">1</span>
        <span class="s1">shifted = np.roll(mask</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">shifted[</span><span class="s5">0</span><span class="s1">] = </span><span class="s5">0</span>
        <span class="s1">edges = np.where((mask ^ shifted) == </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">edge_pairs = list(zip(edges[::</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">edges[</span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s1">]))</span>
        <span class="s2">return </span><span class="s1">edge_pairs</span>

    <span class="s2">def </span><span class="s1">__next__(self):</span>
        <span class="s2">if </span><span class="s1">self.buffer </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">line = next(self.buffer)</span>
            <span class="s2">except </span><span class="s1">StopIteration:</span>
                <span class="s1">self.buffer = </span><span class="s2">None</span>
                <span class="s1">line = next(self.f)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">line = next(self.f)</span>
        <span class="s3"># Note: 'colspecs' is a sequence of half-open intervals.</span>
        <span class="s2">return </span><span class="s1">[line[fromm:to].strip(self.delimiter) </span><span class="s2">for </span><span class="s1">(fromm</span><span class="s2">, </span><span class="s1">to) </span><span class="s2">in </span><span class="s1">self.colspecs]</span>


<span class="s2">class </span><span class="s1">FixedWidthFieldParser(PythonParser):</span>
    <span class="s0">&quot;&quot;&quot; 
    Specialization that Converts fixed-width fields into DataFrames. 
    See PythonParser for details. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s3"># Support iterators, convert to a list.</span>
        <span class="s1">self.colspecs = kwds.pop(</span><span class="s4">&quot;colspecs&quot;</span><span class="s1">)</span>
        <span class="s1">self.infer_nrows = kwds.pop(</span><span class="s4">&quot;infer_nrows&quot;</span><span class="s1">)</span>
        <span class="s1">PythonParser.__init__(self</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">**kwds)</span>

    <span class="s2">def </span><span class="s1">_make_reader(self</span><span class="s2">, </span><span class="s1">f):</span>
        <span class="s1">self.data = FixedWidthReader(</span>
            <span class="s1">f</span><span class="s2">,</span>
            <span class="s1">self.colspecs</span><span class="s2">,</span>
            <span class="s1">self.delimiter</span><span class="s2">,</span>
            <span class="s1">self.comment</span><span class="s2">,</span>
            <span class="s1">self.skiprows</span><span class="s2">,</span>
            <span class="s1">self.infer_nrows</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_remove_empty_lines(self</span><span class="s2">, </span><span class="s1">lines) -&gt; List:</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns the list of lines without the empty ones. With fixed-width 
        fields, empty lines become arrays of empty strings. 
 
        See PythonParser._remove_empty_lines. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">[</span>
            <span class="s1">line</span>
            <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">lines</span>
            <span class="s2">if </span><span class="s1">any(</span><span class="s2">not </span><span class="s1">isinstance(e</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">or </span><span class="s1">e.strip() </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">line)</span>
        <span class="s1">]</span>


<span class="s2">def </span><span class="s1">_refine_defaults_read(</span>
    <span class="s1">dialect: Union[str</span><span class="s2">, </span><span class="s1">csv.Dialect]</span><span class="s2">,</span>
    <span class="s1">delimiter: Union[str</span><span class="s2">, </span><span class="s1">object]</span><span class="s2">,</span>
    <span class="s1">delim_whitespace: bool</span><span class="s2">,</span>
    <span class="s1">engine: str</span><span class="s2">,</span>
    <span class="s1">sep: Union[str</span><span class="s2">, </span><span class="s1">object]</span><span class="s2">,</span>
    <span class="s1">defaults: Dict[str</span><span class="s2">, </span><span class="s1">Any]</span><span class="s2">,</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Validate/refine default values of input parameters of read_csv, read_table. 
 
    Parameters 
    ---------- 
    dialect : str or csv.Dialect 
        If provided, this parameter will override values (default or not) for the 
        following parameters: `delimiter`, `doublequote`, `escapechar`, 
        `skipinitialspace`, `quotechar`, and `quoting`. If it is necessary to 
        override values, a ParserWarning will be issued. See csv.Dialect 
        documentation for more details. 
    delimiter : str or object 
        Alias for sep. 
    delim_whitespace : bool 
        Specifies whether or not whitespace (e.g. ``' '`` or ``'\t'``) will be 
        used as the sep. Equivalent to setting ``sep='\\s+'``. If this option 
        is set to True, nothing should be passed in for the ``delimiter`` 
        parameter. 
    engine : {{'c', 'python'}} 
        Parser engine to use. The C engine is faster while the python engine is 
        currently more feature-complete. 
    sep : str or object 
        A delimiter provided by the user (str) or a sentinel value, i.e. 
        pandas._libs.lib.no_default. 
    defaults: dict 
        Default values of input parameters. 
 
    Returns 
    ------- 
    kwds : dict 
        Input parameters with correct values. 
 
    Raises 
    ------ 
    ValueError : If a delimiter was specified with ``sep`` (or ``delimiter``) and 
        ``delim_whitespace=True``. 
    &quot;&quot;&quot;</span>
    <span class="s3"># fix types for sep, delimiter to Union(str, Any)</span>
    <span class="s1">delim_default = defaults[</span><span class="s4">&quot;delimiter&quot;</span><span class="s1">]</span>
    <span class="s1">kwds: Dict[str</span><span class="s2">, </span><span class="s1">Any] = {}</span>
    <span class="s3"># gh-23761</span>
    <span class="s3">#</span>
    <span class="s3"># When a dialect is passed, it overrides any of the overlapping</span>
    <span class="s3"># parameters passed in directly. We don't want to warn if the</span>
    <span class="s3"># default parameters were passed in (since it probably means</span>
    <span class="s3"># that the user didn't pass them in explicitly in the first place).</span>
    <span class="s3">#</span>
    <span class="s3"># &quot;delimiter&quot; is the annoying corner case because we alias it to</span>
    <span class="s3"># &quot;sep&quot; before doing comparison to the dialect values later on.</span>
    <span class="s3"># Thus, we need a flag to indicate that we need to &quot;override&quot;</span>
    <span class="s3"># the comparison to dialect values by checking if default values</span>
    <span class="s3"># for BOTH &quot;delimiter&quot; and &quot;sep&quot; were provided.</span>
    <span class="s2">if </span><span class="s1">dialect </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">kwds[</span><span class="s4">&quot;sep_override&quot;</span><span class="s1">] = delimiter </span><span class="s2">is None and </span><span class="s1">(</span>
            <span class="s1">sep </span><span class="s2">is </span><span class="s1">lib.no_default </span><span class="s2">or </span><span class="s1">sep == delim_default</span>
        <span class="s1">)</span>

    <span class="s3"># Alias sep -&gt; delimiter.</span>
    <span class="s2">if </span><span class="s1">delimiter </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">delimiter = sep</span>

    <span class="s2">if </span><span class="s1">delim_whitespace </span><span class="s2">and </span><span class="s1">(delimiter </span><span class="s2">is not </span><span class="s1">lib.no_default):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s4">&quot;Specified a delimiter with both sep and &quot;</span>
            <span class="s4">&quot;delim_whitespace=True; you can only specify one.&quot;</span>
        <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">delimiter </span><span class="s2">is </span><span class="s1">lib.no_default:</span>
        <span class="s3"># assign default separator value</span>
        <span class="s1">kwds[</span><span class="s4">&quot;delimiter&quot;</span><span class="s1">] = delim_default</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">kwds[</span><span class="s4">&quot;delimiter&quot;</span><span class="s1">] = delimiter</span>

    <span class="s2">if </span><span class="s1">engine </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">kwds[</span><span class="s4">&quot;engine_specified&quot;</span><span class="s1">] = </span><span class="s2">True</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">kwds[</span><span class="s4">&quot;engine&quot;</span><span class="s1">] = </span><span class="s4">&quot;c&quot;</span>
        <span class="s1">kwds[</span><span class="s4">&quot;engine_specified&quot;</span><span class="s1">] = </span><span class="s2">False</span>

    <span class="s2">return </span><span class="s1">kwds</span>


<span class="s2">def </span><span class="s1">_extract_dialect(kwds: Dict[str</span><span class="s2">, </span><span class="s1">Any]) -&gt; Optional[csv.Dialect]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Extract concrete csv dialect instance. 
 
    Returns 
    ------- 
    csv.Dialect or None 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">kwds.get(</span><span class="s4">&quot;dialect&quot;</span><span class="s1">) </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return None</span>

    <span class="s1">dialect = kwds[</span><span class="s4">&quot;dialect&quot;</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s1">dialect </span><span class="s2">in </span><span class="s1">csv.list_dialects():</span>
        <span class="s1">dialect = csv.get_dialect(dialect)</span>

    <span class="s1">_validate_dialect(dialect)</span>

    <span class="s2">return </span><span class="s1">dialect</span>


<span class="s1">MANDATORY_DIALECT_ATTRS = (</span>
    <span class="s4">&quot;delimiter&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;doublequote&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;escapechar&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;skipinitialspace&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;quotechar&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;quoting&quot;</span><span class="s2">,</span>
<span class="s1">)</span>


<span class="s2">def </span><span class="s1">_validate_dialect(dialect: csv.Dialect) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Validate csv dialect instance. 
 
    Raises 
    ------ 
    ValueError 
        If incorrect dialect is provided. 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">param </span><span class="s2">in </span><span class="s1">MANDATORY_DIALECT_ATTRS:</span>
        <span class="s2">if not </span><span class="s1">hasattr(dialect</span><span class="s2">, </span><span class="s1">param):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Invalid dialect </span><span class="s2">{</span><span class="s1">dialect</span><span class="s2">} </span><span class="s4">provided&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_merge_with_dialect_properties(</span>
    <span class="s1">dialect: csv.Dialect</span><span class="s2">,</span>
    <span class="s1">defaults: Dict[str</span><span class="s2">, </span><span class="s1">Any]</span><span class="s2">,</span>
<span class="s1">) -&gt; Dict[str</span><span class="s2">, </span><span class="s1">Any]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Merge default kwargs in TextFileReader with dialect parameters. 
 
    Parameters 
    ---------- 
    dialect : csv.Dialect 
        Concrete csv dialect. See csv.Dialect documentation for more details. 
    defaults : dict 
        Keyword arguments passed to TextFileReader. 
 
    Returns 
    ------- 
    kwds : dict 
        Updated keyword arguments, merged with dialect parameters. 
    &quot;&quot;&quot;</span>
    <span class="s1">kwds = defaults.copy()</span>

    <span class="s2">for </span><span class="s1">param </span><span class="s2">in </span><span class="s1">MANDATORY_DIALECT_ATTRS:</span>
        <span class="s1">dialect_val = getattr(dialect</span><span class="s2">, </span><span class="s1">param)</span>

        <span class="s1">parser_default = _parser_defaults[param]</span>
        <span class="s1">provided = kwds.get(param</span><span class="s2">, </span><span class="s1">parser_default)</span>

        <span class="s3"># Messages for conflicting values between the dialect</span>
        <span class="s3"># instance and the actual parameters provided.</span>
        <span class="s1">conflict_msgs = []</span>

        <span class="s3"># Don't warn if the default parameter was passed in,</span>
        <span class="s3"># even if it conflicts with the dialect (gh-23761).</span>
        <span class="s2">if </span><span class="s1">provided != parser_default </span><span class="s2">and </span><span class="s1">provided != dialect_val:</span>
            <span class="s1">msg = (</span>
                <span class="s4">f&quot;Conflicting values for '</span><span class="s2">{</span><span class="s1">param</span><span class="s2">}</span><span class="s4">': '</span><span class="s2">{</span><span class="s1">provided</span><span class="s2">}</span><span class="s4">' was &quot;</span>
                <span class="s4">f&quot;provided, but the dialect specifies '</span><span class="s2">{</span><span class="s1">dialect_val</span><span class="s2">}</span><span class="s4">'. &quot;</span>
                <span class="s4">&quot;Using the dialect-specified value.&quot;</span>
            <span class="s1">)</span>

            <span class="s3"># Annoying corner case for not warning about</span>
            <span class="s3"># conflicts between dialect and delimiter parameter.</span>
            <span class="s3"># Refer to the outer &quot;_read_&quot; function for more info.</span>
            <span class="s2">if not </span><span class="s1">(param == </span><span class="s4">&quot;delimiter&quot; </span><span class="s2">and </span><span class="s1">kwds.pop(</span><span class="s4">&quot;sep_override&quot;</span><span class="s2">, False</span><span class="s1">)):</span>
                <span class="s1">conflict_msgs.append(msg)</span>

        <span class="s2">if </span><span class="s1">conflict_msgs:</span>
            <span class="s1">warnings.warn(</span><span class="s4">&quot;</span><span class="s2">\n\n</span><span class="s4">&quot;</span><span class="s1">.join(conflict_msgs)</span><span class="s2">, </span><span class="s1">ParserWarning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">kwds[param] = dialect_val</span>
    <span class="s2">return </span><span class="s1">kwds</span>


<span class="s2">def </span><span class="s1">_validate_skipfooter(kwds: Dict[str</span><span class="s2">, </span><span class="s1">Any]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Check whether skipfooter is compatible with other kwargs in TextFileReader. 
 
    Parameters 
    ---------- 
    kwds : dict 
        Keyword arguments passed to TextFileReader. 
 
    Raises 
    ------ 
    ValueError 
        If skipfooter is not compatible with other parameters. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">kwds.get(</span><span class="s4">&quot;skipfooter&quot;</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">kwds.get(</span><span class="s4">&quot;iterator&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s1">kwds.get(</span><span class="s4">&quot;chunksize&quot;</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;'skipfooter' not supported for iteration&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">kwds.get(</span><span class="s4">&quot;nrows&quot;</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;'skipfooter' not supported with 'nrows'&quot;</span><span class="s1">)</span>
</pre>
</body>
</html>