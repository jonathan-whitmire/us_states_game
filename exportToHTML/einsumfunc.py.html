<html>
<head>
<title>einsumfunc.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
einsumfunc.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Implementation of optimized einsum. 
 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">operator</span>

<span class="s2">from </span><span class="s1">numpy.core.multiarray </span><span class="s2">import </span><span class="s1">c_einsum</span>
<span class="s2">from </span><span class="s1">numpy.core.numeric </span><span class="s2">import </span><span class="s1">asanyarray</span><span class="s2">, </span><span class="s1">tensordot</span>
<span class="s2">from </span><span class="s1">numpy.core.overrides </span><span class="s2">import </span><span class="s1">array_function_dispatch</span>

<span class="s1">__all__ = [</span><span class="s3">'einsum'</span><span class="s2">, </span><span class="s3">'einsum_path'</span><span class="s1">]</span>

<span class="s1">einsum_symbols = </span><span class="s3">'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span>
<span class="s1">einsum_symbols_set = set(einsum_symbols)</span>


<span class="s2">def </span><span class="s1">_flop_count(idx_contraction</span><span class="s2">, </span><span class="s1">inner</span><span class="s2">, </span><span class="s1">num_terms</span><span class="s2">, </span><span class="s1">size_dictionary):</span>
    <span class="s0">&quot;&quot;&quot; 
    Computes the number of FLOPS in the contraction. 
 
    Parameters 
    ---------- 
    idx_contraction : iterable 
        The indices involved in the contraction 
    inner : bool 
        Does this contraction require an inner product? 
    num_terms : int 
        The number of terms in a contraction 
    size_dictionary : dict 
        The size of each of the indices in idx_contraction 
 
    Returns 
    ------- 
    flop_count : int 
        The total number of FLOPS required for the contraction. 
 
    Examples 
    -------- 
 
    &gt;&gt;&gt; _flop_count('abc', False, 1, {'a': 2, 'b':3, 'c':5}) 
    30 
 
    &gt;&gt;&gt; _flop_count('abc', True, 2, {'a': 2, 'b':3, 'c':5}) 
    60 
 
    &quot;&quot;&quot;</span>

    <span class="s1">overall_size = _compute_size_by_dict(idx_contraction</span><span class="s2">, </span><span class="s1">size_dictionary)</span>
    <span class="s1">op_factor = max(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">num_terms - </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">inner:</span>
        <span class="s1">op_factor += </span><span class="s4">1</span>

    <span class="s2">return </span><span class="s1">overall_size * op_factor</span>

<span class="s2">def </span><span class="s1">_compute_size_by_dict(indices</span><span class="s2">, </span><span class="s1">idx_dict):</span>
    <span class="s0">&quot;&quot;&quot; 
    Computes the product of the elements in indices based on the dictionary 
    idx_dict. 
 
    Parameters 
    ---------- 
    indices : iterable 
        Indices to base the product on. 
    idx_dict : dictionary 
        Dictionary of index sizes 
 
    Returns 
    ------- 
    ret : int 
        The resulting product. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; _compute_size_by_dict('abbc', {'a': 2, 'b':3, 'c':5}) 
    90 
 
    &quot;&quot;&quot;</span>
    <span class="s1">ret = </span><span class="s4">1</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">indices:</span>
        <span class="s1">ret *= idx_dict[i]</span>
    <span class="s2">return </span><span class="s1">ret</span>


<span class="s2">def </span><span class="s1">_find_contraction(positions</span><span class="s2">, </span><span class="s1">input_sets</span><span class="s2">, </span><span class="s1">output_set):</span>
    <span class="s0">&quot;&quot;&quot; 
    Finds the contraction for a given set of input and output sets. 
 
    Parameters 
    ---------- 
    positions : iterable 
        Integer positions of terms used in the contraction. 
    input_sets : list 
        List of sets that represent the lhs side of the einsum subscript 
    output_set : set 
        Set that represents the rhs side of the overall einsum subscript 
 
    Returns 
    ------- 
    new_result : set 
        The indices of the resulting contraction 
    remaining : list 
        List of sets that have not been contracted, the new set is appended to 
        the end of this list 
    idx_removed : set 
        Indices removed from the entire contraction 
    idx_contraction : set 
        The indices used in the current contraction 
 
    Examples 
    -------- 
 
    # A simple dot product test case 
    &gt;&gt;&gt; pos = (0, 1) 
    &gt;&gt;&gt; isets = [set('ab'), set('bc')] 
    &gt;&gt;&gt; oset = set('ac') 
    &gt;&gt;&gt; _find_contraction(pos, isets, oset) 
    ({'a', 'c'}, [{'a', 'c'}], {'b'}, {'a', 'b', 'c'}) 
 
    # A more complex case with additional terms in the contraction 
    &gt;&gt;&gt; pos = (0, 2) 
    &gt;&gt;&gt; isets = [set('abd'), set('ac'), set('bdc')] 
    &gt;&gt;&gt; oset = set('ac') 
    &gt;&gt;&gt; _find_contraction(pos, isets, oset) 
    ({'a', 'c'}, [{'a', 'c'}, {'a', 'c'}], {'b', 'd'}, {'a', 'b', 'c', 'd'}) 
    &quot;&quot;&quot;</span>

    <span class="s1">idx_contract = set()</span>
    <span class="s1">idx_remain = output_set.copy()</span>
    <span class="s1">remaining = []</span>
    <span class="s2">for </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">enumerate(input_sets):</span>
        <span class="s2">if </span><span class="s1">ind </span><span class="s2">in </span><span class="s1">positions:</span>
            <span class="s1">idx_contract |= value</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">remaining.append(value)</span>
            <span class="s1">idx_remain |= value</span>

    <span class="s1">new_result = idx_remain &amp; idx_contract</span>
    <span class="s1">idx_removed = (idx_contract - new_result)</span>
    <span class="s1">remaining.append(new_result)</span>

    <span class="s2">return </span><span class="s1">(new_result</span><span class="s2">, </span><span class="s1">remaining</span><span class="s2">, </span><span class="s1">idx_removed</span><span class="s2">, </span><span class="s1">idx_contract)</span>


<span class="s2">def </span><span class="s1">_optimal_path(input_sets</span><span class="s2">, </span><span class="s1">output_set</span><span class="s2">, </span><span class="s1">idx_dict</span><span class="s2">, </span><span class="s1">memory_limit):</span>
    <span class="s0">&quot;&quot;&quot; 
    Computes all possible pair contractions, sieves the results based 
    on ``memory_limit`` and returns the lowest cost path. This algorithm 
    scales factorial with respect to the elements in the list ``input_sets``. 
 
    Parameters 
    ---------- 
    input_sets : list 
        List of sets that represent the lhs side of the einsum subscript 
    output_set : set 
        Set that represents the rhs side of the overall einsum subscript 
    idx_dict : dictionary 
        Dictionary of index sizes 
    memory_limit : int 
        The maximum number of elements in a temporary array 
 
    Returns 
    ------- 
    path : list 
        The optimal contraction order within the memory limit constraint. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; isets = [set('abd'), set('ac'), set('bdc')] 
    &gt;&gt;&gt; oset = set() 
    &gt;&gt;&gt; idx_sizes = {'a': 1, 'b':2, 'c':3, 'd':4} 
    &gt;&gt;&gt; _optimal_path(isets, oset, idx_sizes, 5000) 
    [(0, 2), (0, 1)] 
    &quot;&quot;&quot;</span>

    <span class="s1">full_results = [(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">input_sets)]</span>
    <span class="s2">for </span><span class="s1">iteration </span><span class="s2">in </span><span class="s1">range(len(input_sets) - </span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">iter_results = []</span>

        <span class="s5"># Compute all unique pairs</span>
        <span class="s2">for </span><span class="s1">curr </span><span class="s2">in </span><span class="s1">full_results:</span>
            <span class="s1">cost</span><span class="s2">, </span><span class="s1">positions</span><span class="s2">, </span><span class="s1">remaining = curr</span>
            <span class="s2">for </span><span class="s1">con </span><span class="s2">in </span><span class="s1">itertools.combinations(range(len(input_sets) - iteration)</span><span class="s2">, </span><span class="s4">2</span><span class="s1">):</span>

                <span class="s5"># Find the contraction</span>
                <span class="s1">cont = _find_contraction(con</span><span class="s2">, </span><span class="s1">remaining</span><span class="s2">, </span><span class="s1">output_set)</span>
                <span class="s1">new_result</span><span class="s2">, </span><span class="s1">new_input_sets</span><span class="s2">, </span><span class="s1">idx_removed</span><span class="s2">, </span><span class="s1">idx_contract = cont</span>

                <span class="s5"># Sieve the results based on memory_limit</span>
                <span class="s1">new_size = _compute_size_by_dict(new_result</span><span class="s2">, </span><span class="s1">idx_dict)</span>
                <span class="s2">if </span><span class="s1">new_size &gt; memory_limit:</span>
                    <span class="s2">continue</span>

                <span class="s5"># Build (total_cost, positions, indices_remaining)</span>
                <span class="s1">total_cost =  cost + _flop_count(idx_contract</span><span class="s2">, </span><span class="s1">idx_removed</span><span class="s2">, </span><span class="s1">len(con)</span><span class="s2">, </span><span class="s1">idx_dict)</span>
                <span class="s1">new_pos = positions + [con]</span>
                <span class="s1">iter_results.append((total_cost</span><span class="s2">, </span><span class="s1">new_pos</span><span class="s2">, </span><span class="s1">new_input_sets))</span>

        <span class="s5"># Update combinatorial list, if we did not find anything return best</span>
        <span class="s5"># path + remaining contractions</span>
        <span class="s2">if </span><span class="s1">iter_results:</span>
            <span class="s1">full_results = iter_results</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">path = min(full_results</span><span class="s2">, </span><span class="s1">key=</span><span class="s2">lambda </span><span class="s1">x: x[</span><span class="s4">0</span><span class="s1">])[</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">path += [tuple(range(len(input_sets) - iteration))]</span>
            <span class="s2">return </span><span class="s1">path</span>

    <span class="s5"># If we have not found anything return single einsum contraction</span>
    <span class="s2">if </span><span class="s1">len(full_results) == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">[tuple(range(len(input_sets)))]</span>

    <span class="s1">path = min(full_results</span><span class="s2">, </span><span class="s1">key=</span><span class="s2">lambda </span><span class="s1">x: x[</span><span class="s4">0</span><span class="s1">])[</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s2">return </span><span class="s1">path</span>

<span class="s2">def </span><span class="s1">_parse_possible_contraction(positions</span><span class="s2">, </span><span class="s1">input_sets</span><span class="s2">, </span><span class="s1">output_set</span><span class="s2">, </span><span class="s1">idx_dict</span><span class="s2">, </span><span class="s1">memory_limit</span><span class="s2">, </span><span class="s1">path_cost</span><span class="s2">, </span><span class="s1">naive_cost):</span>
    <span class="s0">&quot;&quot;&quot;Compute the cost (removed size + flops) and resultant indices for 
    performing the contraction specified by ``positions``. 
 
    Parameters 
    ---------- 
    positions : tuple of int 
        The locations of the proposed tensors to contract. 
    input_sets : list of sets 
        The indices found on each tensors. 
    output_set : set 
        The output indices of the expression. 
    idx_dict : dict 
        Mapping of each index to its size. 
    memory_limit : int 
        The total allowed size for an intermediary tensor. 
    path_cost : int 
        The contraction cost so far. 
    naive_cost : int 
        The cost of the unoptimized expression. 
 
    Returns 
    ------- 
    cost : (int, int) 
        A tuple containing the size of any indices removed, and the flop cost. 
    positions : tuple of int 
        The locations of the proposed tensors to contract. 
    new_input_sets : list of sets 
        The resulting new list of indices if this proposed contraction is performed. 
 
    &quot;&quot;&quot;</span>

    <span class="s5"># Find the contraction</span>
    <span class="s1">contract = _find_contraction(positions</span><span class="s2">, </span><span class="s1">input_sets</span><span class="s2">, </span><span class="s1">output_set)</span>
    <span class="s1">idx_result</span><span class="s2">, </span><span class="s1">new_input_sets</span><span class="s2">, </span><span class="s1">idx_removed</span><span class="s2">, </span><span class="s1">idx_contract = contract</span>

    <span class="s5"># Sieve the results based on memory_limit</span>
    <span class="s1">new_size = _compute_size_by_dict(idx_result</span><span class="s2">, </span><span class="s1">idx_dict)</span>
    <span class="s2">if </span><span class="s1">new_size &gt; memory_limit:</span>
        <span class="s2">return None</span>

    <span class="s5"># Build sort tuple</span>
    <span class="s1">old_sizes = (_compute_size_by_dict(input_sets[p]</span><span class="s2">, </span><span class="s1">idx_dict) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">positions)</span>
    <span class="s1">removed_size = sum(old_sizes) - new_size</span>

    <span class="s5"># NB: removed_size used to be just the size of any removed indices i.e.:</span>
    <span class="s5">#     helpers.compute_size_by_dict(idx_removed, idx_dict)</span>
    <span class="s1">cost = _flop_count(idx_contract</span><span class="s2">, </span><span class="s1">idx_removed</span><span class="s2">, </span><span class="s1">len(positions)</span><span class="s2">, </span><span class="s1">idx_dict)</span>
    <span class="s1">sort = (-removed_size</span><span class="s2">, </span><span class="s1">cost)</span>

    <span class="s5"># Sieve based on total cost as well</span>
    <span class="s2">if </span><span class="s1">(path_cost + cost) &gt; naive_cost:</span>
        <span class="s2">return None</span>

    <span class="s5"># Add contraction to possible choices</span>
    <span class="s2">return </span><span class="s1">[sort</span><span class="s2">, </span><span class="s1">positions</span><span class="s2">, </span><span class="s1">new_input_sets]</span>


<span class="s2">def </span><span class="s1">_update_other_results(results</span><span class="s2">, </span><span class="s1">best):</span>
    <span class="s0">&quot;&quot;&quot;Update the positions and provisional input_sets of ``results`` based on 
    performing the contraction result ``best``. Remove any involving the tensors 
    contracted. 
 
    Parameters 
    ---------- 
    results : list 
        List of contraction results produced by ``_parse_possible_contraction``. 
    best : list 
        The best contraction of ``results`` i.e. the one that will be performed. 
 
    Returns 
    ------- 
    mod_results : list 
        The list of modified results, updated with outcome of ``best`` contraction. 
    &quot;&quot;&quot;</span>

    <span class="s1">best_con = best[</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">bx</span><span class="s2">, </span><span class="s1">by = best_con</span>
    <span class="s1">mod_results = []</span>

    <span class="s2">for </span><span class="s1">cost</span><span class="s2">, </span><span class="s1">(x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">, </span><span class="s1">con_sets </span><span class="s2">in </span><span class="s1">results:</span>

        <span class="s5"># Ignore results involving tensors just contracted</span>
        <span class="s2">if </span><span class="s1">x </span><span class="s2">in </span><span class="s1">best_con </span><span class="s2">or </span><span class="s1">y </span><span class="s2">in </span><span class="s1">best_con:</span>
            <span class="s2">continue</span>

        <span class="s5"># Update the input_sets</span>
        <span class="s2">del </span><span class="s1">con_sets[by - int(by &gt; x) - int(by &gt; y)]</span>
        <span class="s2">del </span><span class="s1">con_sets[bx - int(bx &gt; x) - int(bx &gt; y)]</span>
        <span class="s1">con_sets.insert(-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">best[</span><span class="s4">2</span><span class="s1">][-</span><span class="s4">1</span><span class="s1">])</span>

        <span class="s5"># Update the position indices</span>
        <span class="s1">mod_con = x - int(x &gt; bx) - int(x &gt; by)</span><span class="s2">, </span><span class="s1">y - int(y &gt; bx) - int(y &gt; by)</span>
        <span class="s1">mod_results.append((cost</span><span class="s2">, </span><span class="s1">mod_con</span><span class="s2">, </span><span class="s1">con_sets))</span>

    <span class="s2">return </span><span class="s1">mod_results</span>

<span class="s2">def </span><span class="s1">_greedy_path(input_sets</span><span class="s2">, </span><span class="s1">output_set</span><span class="s2">, </span><span class="s1">idx_dict</span><span class="s2">, </span><span class="s1">memory_limit):</span>
    <span class="s0">&quot;&quot;&quot; 
    Finds the path by contracting the best pair until the input list is 
    exhausted. The best pair is found by minimizing the tuple 
    ``(-prod(indices_removed), cost)``.  What this amounts to is prioritizing 
    matrix multiplication or inner product operations, then Hadamard like 
    operations, and finally outer operations. Outer products are limited by 
    ``memory_limit``. This algorithm scales cubically with respect to the 
    number of elements in the list ``input_sets``. 
 
    Parameters 
    ---------- 
    input_sets : list 
        List of sets that represent the lhs side of the einsum subscript 
    output_set : set 
        Set that represents the rhs side of the overall einsum subscript 
    idx_dict : dictionary 
        Dictionary of index sizes 
    memory_limit_limit : int 
        The maximum number of elements in a temporary array 
 
    Returns 
    ------- 
    path : list 
        The greedy contraction order within the memory limit constraint. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; isets = [set('abd'), set('ac'), set('bdc')] 
    &gt;&gt;&gt; oset = set() 
    &gt;&gt;&gt; idx_sizes = {'a': 1, 'b':2, 'c':3, 'd':4} 
    &gt;&gt;&gt; _greedy_path(isets, oset, idx_sizes, 5000) 
    [(0, 2), (0, 1)] 
    &quot;&quot;&quot;</span>

    <span class="s5"># Handle trivial cases that leaked through</span>
    <span class="s2">if </span><span class="s1">len(input_sets) == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">[(</span><span class="s4">0</span><span class="s2">,</span><span class="s1">)]</span>
    <span class="s2">elif </span><span class="s1">len(input_sets) == </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">[(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)]</span>

    <span class="s5"># Build up a naive cost</span>
    <span class="s1">contract = _find_contraction(range(len(input_sets))</span><span class="s2">, </span><span class="s1">input_sets</span><span class="s2">, </span><span class="s1">output_set)</span>
    <span class="s1">idx_result</span><span class="s2">, </span><span class="s1">new_input_sets</span><span class="s2">, </span><span class="s1">idx_removed</span><span class="s2">, </span><span class="s1">idx_contract = contract</span>
    <span class="s1">naive_cost = _flop_count(idx_contract</span><span class="s2">, </span><span class="s1">idx_removed</span><span class="s2">, </span><span class="s1">len(input_sets)</span><span class="s2">, </span><span class="s1">idx_dict)</span>

    <span class="s5"># Initially iterate over all pairs</span>
    <span class="s1">comb_iter = itertools.combinations(range(len(input_sets))</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">known_contractions = []</span>

    <span class="s1">path_cost = </span><span class="s4">0</span>
    <span class="s1">path = []</span>

    <span class="s2">for </span><span class="s1">iteration </span><span class="s2">in </span><span class="s1">range(len(input_sets) - </span><span class="s4">1</span><span class="s1">):</span>

        <span class="s5"># Iterate over all pairs on first step, only previously found pairs on subsequent steps</span>
        <span class="s2">for </span><span class="s1">positions </span><span class="s2">in </span><span class="s1">comb_iter:</span>

            <span class="s5"># Always initially ignore outer products</span>
            <span class="s2">if </span><span class="s1">input_sets[positions[</span><span class="s4">0</span><span class="s1">]].isdisjoint(input_sets[positions[</span><span class="s4">1</span><span class="s1">]]):</span>
                <span class="s2">continue</span>

            <span class="s1">result = _parse_possible_contraction(positions</span><span class="s2">, </span><span class="s1">input_sets</span><span class="s2">, </span><span class="s1">output_set</span><span class="s2">, </span><span class="s1">idx_dict</span><span class="s2">, </span><span class="s1">memory_limit</span><span class="s2">, </span><span class="s1">path_cost</span><span class="s2">,</span>
                                                 <span class="s1">naive_cost)</span>
            <span class="s2">if </span><span class="s1">result </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">known_contractions.append(result)</span>

        <span class="s5"># If we do not have a inner contraction, rescan pairs including outer products</span>
        <span class="s2">if </span><span class="s1">len(known_contractions) == </span><span class="s4">0</span><span class="s1">:</span>

            <span class="s5"># Then check the outer products</span>
            <span class="s2">for </span><span class="s1">positions </span><span class="s2">in </span><span class="s1">itertools.combinations(range(len(input_sets))</span><span class="s2">, </span><span class="s4">2</span><span class="s1">):</span>
                <span class="s1">result = _parse_possible_contraction(positions</span><span class="s2">, </span><span class="s1">input_sets</span><span class="s2">, </span><span class="s1">output_set</span><span class="s2">, </span><span class="s1">idx_dict</span><span class="s2">, </span><span class="s1">memory_limit</span><span class="s2">,</span>
                                                     <span class="s1">path_cost</span><span class="s2">, </span><span class="s1">naive_cost)</span>
                <span class="s2">if </span><span class="s1">result </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">known_contractions.append(result)</span>

            <span class="s5"># If we still did not find any remaining contractions, default back to einsum like behavior</span>
            <span class="s2">if </span><span class="s1">len(known_contractions) == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">path.append(tuple(range(len(input_sets))))</span>
                <span class="s2">break</span>

        <span class="s5"># Sort based on first index</span>
        <span class="s1">best = min(known_contractions</span><span class="s2">, </span><span class="s1">key=</span><span class="s2">lambda </span><span class="s1">x: x[</span><span class="s4">0</span><span class="s1">])</span>

        <span class="s5"># Now propagate as many unused contractions as possible to next iteration</span>
        <span class="s1">known_contractions = _update_other_results(known_contractions</span><span class="s2">, </span><span class="s1">best)</span>

        <span class="s5"># Next iteration only compute contractions with the new tensor</span>
        <span class="s5"># All other contractions have been accounted for</span>
        <span class="s1">input_sets = best[</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">new_tensor_pos = len(input_sets) - </span><span class="s4">1</span>
        <span class="s1">comb_iter = ((i</span><span class="s2">, </span><span class="s1">new_tensor_pos) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(new_tensor_pos))</span>

        <span class="s5"># Update path and total cost</span>
        <span class="s1">path.append(best[</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">path_cost += best[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s2">return </span><span class="s1">path</span>


<span class="s2">def </span><span class="s1">_can_dot(inputs</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">idx_removed):</span>
    <span class="s0">&quot;&quot;&quot; 
    Checks if we can use BLAS (np.tensordot) call and its beneficial to do so. 
 
    Parameters 
    ---------- 
    inputs : list of str 
        Specifies the subscripts for summation. 
    result : str 
        Resulting summation. 
    idx_removed : set 
        Indices that are removed in the summation 
 
 
    Returns 
    ------- 
    type : bool 
        Returns true if BLAS should and can be used, else False 
 
    Notes 
    ----- 
    If the operations is BLAS level 1 or 2 and is not already aligned 
    we default back to einsum as the memory movement to copy is more 
    costly than the operation itself. 
 
 
    Examples 
    -------- 
 
    # Standard GEMM operation 
    &gt;&gt;&gt; _can_dot(['ij', 'jk'], 'ik', set('j')) 
    True 
 
    # Can use the standard BLAS, but requires odd data movement 
    &gt;&gt;&gt; _can_dot(['ijj', 'jk'], 'ik', set('j')) 
    False 
 
    # DDOT where the memory is not aligned 
    &gt;&gt;&gt; _can_dot(['ijk', 'ikj'], '', set('ijk')) 
    False 
 
    &quot;&quot;&quot;</span>

    <span class="s5"># All `dot` calls remove indices</span>
    <span class="s2">if </span><span class="s1">len(idx_removed) == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">return False</span>

    <span class="s5"># BLAS can only handle two operands</span>
    <span class="s2">if </span><span class="s1">len(inputs) != </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s2">return False</span>

    <span class="s1">input_left</span><span class="s2">, </span><span class="s1">input_right = inputs</span>

    <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">set(input_left + input_right):</span>
        <span class="s5"># can't deal with repeated indices on same input or more than 2 total</span>
        <span class="s1">nl</span><span class="s2">, </span><span class="s1">nr = input_left.count(c)</span><span class="s2">, </span><span class="s1">input_right.count(c)</span>
        <span class="s2">if </span><span class="s1">(nl &gt; </span><span class="s4">1</span><span class="s1">) </span><span class="s2">or </span><span class="s1">(nr &gt; </span><span class="s4">1</span><span class="s1">) </span><span class="s2">or </span><span class="s1">(nl + nr &gt; </span><span class="s4">2</span><span class="s1">):</span>
            <span class="s2">return False</span>

        <span class="s5"># can't do implicit summation or dimension collapse e.g.</span>
        <span class="s5">#     &quot;ab,bc-&gt;c&quot; (implicitly sum over 'a')</span>
        <span class="s5">#     &quot;ab,ca-&gt;ca&quot; (take diagonal of 'a')</span>
        <span class="s2">if </span><span class="s1">nl + nr - </span><span class="s4">1 </span><span class="s1">== int(c </span><span class="s2">in </span><span class="s1">result):</span>
            <span class="s2">return False</span>

    <span class="s5"># Build a few temporaries</span>
    <span class="s1">set_left = set(input_left)</span>
    <span class="s1">set_right = set(input_right)</span>
    <span class="s1">keep_left = set_left - idx_removed</span>
    <span class="s1">keep_right = set_right - idx_removed</span>
    <span class="s1">rs = len(idx_removed)</span>

    <span class="s5"># At this point we are a DOT, GEMV, or GEMM operation</span>

    <span class="s5"># Handle inner products</span>

    <span class="s5"># DDOT with aligned data</span>
    <span class="s2">if </span><span class="s1">input_left == input_right:</span>
        <span class="s2">return True</span>

    <span class="s5"># DDOT without aligned data (better to use einsum)</span>
    <span class="s2">if </span><span class="s1">set_left == set_right:</span>
        <span class="s2">return False</span>

    <span class="s5"># Handle the 4 possible (aligned) GEMV or GEMM cases</span>

    <span class="s5"># GEMM or GEMV no transpose</span>
    <span class="s2">if </span><span class="s1">input_left[-rs:] == input_right[:rs]:</span>
        <span class="s2">return True</span>

    <span class="s5"># GEMM or GEMV transpose both</span>
    <span class="s2">if </span><span class="s1">input_left[:rs] == input_right[-rs:]:</span>
        <span class="s2">return True</span>

    <span class="s5"># GEMM or GEMV transpose right</span>
    <span class="s2">if </span><span class="s1">input_left[-rs:] == input_right[-rs:]:</span>
        <span class="s2">return True</span>

    <span class="s5"># GEMM or GEMV transpose left</span>
    <span class="s2">if </span><span class="s1">input_left[:rs] == input_right[:rs]:</span>
        <span class="s2">return True</span>

    <span class="s5"># Einsum is faster than GEMV if we have to copy data</span>
    <span class="s2">if not </span><span class="s1">keep_left </span><span class="s2">or not </span><span class="s1">keep_right:</span>
        <span class="s2">return False</span>

    <span class="s5"># We are a matrix-matrix product, but we need to copy data</span>
    <span class="s2">return True</span>


<span class="s2">def </span><span class="s1">_parse_einsum_input(operands):</span>
    <span class="s0">&quot;&quot;&quot; 
    A reproduction of einsum c side einsum parsing in python. 
 
    Returns 
    ------- 
    input_strings : str 
        Parsed input strings 
    output_string : str 
        Parsed output string 
    operands : list of array_like 
        The operands to use in the numpy contraction 
 
    Examples 
    -------- 
    The operand list is simplified to reduce printing: 
 
    &gt;&gt;&gt; np.random.seed(123) 
    &gt;&gt;&gt; a = np.random.rand(4, 4) 
    &gt;&gt;&gt; b = np.random.rand(4, 4, 4) 
    &gt;&gt;&gt; _parse_einsum_input(('...a,...a-&gt;...', a, b)) 
    ('za,xza', 'xz', [a, b]) # may vary 
 
    &gt;&gt;&gt; _parse_einsum_input((a, [Ellipsis, 0], b, [Ellipsis, 0])) 
    ('za,xza', 'xz', [a, b]) # may vary 
    &quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">len(operands) == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;No input operands&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">isinstance(operands[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s1">subscripts = operands[</span><span class="s4">0</span><span class="s1">].replace(</span><span class="s3">&quot; &quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">operands = [asanyarray(v) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">operands[</span><span class="s4">1</span><span class="s1">:]]</span>

        <span class="s5"># Ensure all characters are valid</span>
        <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">subscripts:</span>
            <span class="s2">if </span><span class="s1">s </span><span class="s2">in </span><span class="s3">'.,-&gt;'</span><span class="s1">:</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">s </span><span class="s2">not in </span><span class="s1">einsum_symbols:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Character %s is not a valid symbol.&quot; </span><span class="s1">% s)</span>

    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">tmp_operands = list(operands)</span>
        <span class="s1">operand_list = []</span>
        <span class="s1">subscript_list = []</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range(len(operands) // </span><span class="s4">2</span><span class="s1">):</span>
            <span class="s1">operand_list.append(tmp_operands.pop(</span><span class="s4">0</span><span class="s1">))</span>
            <span class="s1">subscript_list.append(tmp_operands.pop(</span><span class="s4">0</span><span class="s1">))</span>

        <span class="s1">output_list = tmp_operands[-</span><span class="s4">1</span><span class="s1">] </span><span class="s2">if </span><span class="s1">len(tmp_operands) </span><span class="s2">else None</span>
        <span class="s1">operands = [asanyarray(v) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">operand_list]</span>
        <span class="s1">subscripts = </span><span class="s3">&quot;&quot;</span>
        <span class="s1">last = len(subscript_list) - </span><span class="s4">1</span>
        <span class="s2">for </span><span class="s1">num</span><span class="s2">, </span><span class="s1">sub </span><span class="s2">in </span><span class="s1">enumerate(subscript_list):</span>
            <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">sub:</span>
                <span class="s2">if </span><span class="s1">s </span><span class="s2">is </span><span class="s1">Ellipsis:</span>
                    <span class="s1">subscripts += </span><span class="s3">&quot;...&quot;</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">s = operator.index(s)</span>
                    <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">e:</span>
                        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;For this input type lists must contain &quot;</span>
                                        <span class="s3">&quot;either int or Ellipsis&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">e</span>
                    <span class="s1">subscripts += einsum_symbols[s]</span>
            <span class="s2">if </span><span class="s1">num != last:</span>
                <span class="s1">subscripts += </span><span class="s3">&quot;,&quot;</span>

        <span class="s2">if </span><span class="s1">output_list </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">subscripts += </span><span class="s3">&quot;-&gt;&quot;</span>
            <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">output_list:</span>
                <span class="s2">if </span><span class="s1">s </span><span class="s2">is </span><span class="s1">Ellipsis:</span>
                    <span class="s1">subscripts += </span><span class="s3">&quot;...&quot;</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">s = operator.index(s)</span>
                    <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">e:</span>
                        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;For this input type lists must contain &quot;</span>
                                        <span class="s3">&quot;either int or Ellipsis&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">e</span>
                    <span class="s1">subscripts += einsum_symbols[s]</span>
    <span class="s5"># Check for proper &quot;-&gt;&quot;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s3">&quot;-&quot; </span><span class="s2">in </span><span class="s1">subscripts) </span><span class="s2">or </span><span class="s1">(</span><span class="s3">&quot;&gt;&quot; </span><span class="s2">in </span><span class="s1">subscripts):</span>
        <span class="s1">invalid = (subscripts.count(</span><span class="s3">&quot;-&quot;</span><span class="s1">) &gt; </span><span class="s4">1</span><span class="s1">) </span><span class="s2">or </span><span class="s1">(subscripts.count(</span><span class="s3">&quot;&gt;&quot;</span><span class="s1">) &gt; </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">invalid </span><span class="s2">or </span><span class="s1">(subscripts.count(</span><span class="s3">&quot;-&gt;&quot;</span><span class="s1">) != </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Subscripts can only contain one '-&gt;'.&quot;</span><span class="s1">)</span>

    <span class="s5"># Parse ellipses</span>
    <span class="s2">if </span><span class="s3">&quot;.&quot; </span><span class="s2">in </span><span class="s1">subscripts:</span>
        <span class="s1">used = subscripts.replace(</span><span class="s3">&quot;.&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">).replace(</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">).replace(</span><span class="s3">&quot;-&gt;&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">unused = list(einsum_symbols_set - set(used))</span>
        <span class="s1">ellipse_inds = </span><span class="s3">&quot;&quot;</span><span class="s1">.join(unused)</span>
        <span class="s1">longest = </span><span class="s4">0</span>

        <span class="s2">if </span><span class="s3">&quot;-&gt;&quot; </span><span class="s2">in </span><span class="s1">subscripts:</span>
            <span class="s1">input_tmp</span><span class="s2">, </span><span class="s1">output_sub = subscripts.split(</span><span class="s3">&quot;-&gt;&quot;</span><span class="s1">)</span>
            <span class="s1">split_subscripts = input_tmp.split(</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span>
            <span class="s1">out_sub = </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">split_subscripts = subscripts.split(</span><span class="s3">','</span><span class="s1">)</span>
            <span class="s1">out_sub = </span><span class="s2">False</span>

        <span class="s2">for </span><span class="s1">num</span><span class="s2">, </span><span class="s1">sub </span><span class="s2">in </span><span class="s1">enumerate(split_subscripts):</span>
            <span class="s2">if </span><span class="s3">&quot;.&quot; </span><span class="s2">in </span><span class="s1">sub:</span>
                <span class="s2">if </span><span class="s1">(sub.count(</span><span class="s3">&quot;.&quot;</span><span class="s1">) != </span><span class="s4">3</span><span class="s1">) </span><span class="s2">or </span><span class="s1">(sub.count(</span><span class="s3">&quot;...&quot;</span><span class="s1">) != </span><span class="s4">1</span><span class="s1">):</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Invalid Ellipses.&quot;</span><span class="s1">)</span>

                <span class="s5"># Take into account numerical values</span>
                <span class="s2">if </span><span class="s1">operands[num].shape == ():</span>
                    <span class="s1">ellipse_count = </span><span class="s4">0</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">ellipse_count = max(operands[num].ndim</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
                    <span class="s1">ellipse_count -= (len(sub) - </span><span class="s4">3</span><span class="s1">)</span>

                <span class="s2">if </span><span class="s1">ellipse_count &gt; longest:</span>
                    <span class="s1">longest = ellipse_count</span>

                <span class="s2">if </span><span class="s1">ellipse_count &lt; </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Ellipses lengths do not match.&quot;</span><span class="s1">)</span>
                <span class="s2">elif </span><span class="s1">ellipse_count == </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">split_subscripts[num] = sub.replace(</span><span class="s3">'...'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">rep_inds = ellipse_inds[-ellipse_count:]</span>
                    <span class="s1">split_subscripts[num] = sub.replace(</span><span class="s3">'...'</span><span class="s2">, </span><span class="s1">rep_inds)</span>

        <span class="s1">subscripts = </span><span class="s3">&quot;,&quot;</span><span class="s1">.join(split_subscripts)</span>
        <span class="s2">if </span><span class="s1">longest == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">out_ellipse = </span><span class="s3">&quot;&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">out_ellipse = ellipse_inds[-longest:]</span>

        <span class="s2">if </span><span class="s1">out_sub:</span>
            <span class="s1">subscripts += </span><span class="s3">&quot;-&gt;&quot; </span><span class="s1">+ output_sub.replace(</span><span class="s3">&quot;...&quot;</span><span class="s2">, </span><span class="s1">out_ellipse)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># Special care for outputless ellipses</span>
            <span class="s1">output_subscript = </span><span class="s3">&quot;&quot;</span>
            <span class="s1">tmp_subscripts = subscripts.replace(</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">sorted(set(tmp_subscripts)):</span>
                <span class="s2">if </span><span class="s1">s </span><span class="s2">not in </span><span class="s1">(einsum_symbols):</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Character %s is not a valid symbol.&quot; </span><span class="s1">% s)</span>
                <span class="s2">if </span><span class="s1">tmp_subscripts.count(s) == </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s1">output_subscript += s</span>
            <span class="s1">normal_inds = </span><span class="s3">''</span><span class="s1">.join(sorted(set(output_subscript) -</span>
                                         <span class="s1">set(out_ellipse)))</span>

            <span class="s1">subscripts += </span><span class="s3">&quot;-&gt;&quot; </span><span class="s1">+ out_ellipse + normal_inds</span>

    <span class="s5"># Build output string if does not exist</span>
    <span class="s2">if </span><span class="s3">&quot;-&gt;&quot; </span><span class="s2">in </span><span class="s1">subscripts:</span>
        <span class="s1">input_subscripts</span><span class="s2">, </span><span class="s1">output_subscript = subscripts.split(</span><span class="s3">&quot;-&gt;&quot;</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">input_subscripts = subscripts</span>
        <span class="s5"># Build output subscripts</span>
        <span class="s1">tmp_subscripts = subscripts.replace(</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">output_subscript = </span><span class="s3">&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">sorted(set(tmp_subscripts)):</span>
            <span class="s2">if </span><span class="s1">s </span><span class="s2">not in </span><span class="s1">einsum_symbols:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Character %s is not a valid symbol.&quot; </span><span class="s1">% s)</span>
            <span class="s2">if </span><span class="s1">tmp_subscripts.count(s) == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">output_subscript += s</span>

    <span class="s5"># Make sure output subscripts are in the input</span>
    <span class="s2">for </span><span class="s1">char </span><span class="s2">in </span><span class="s1">output_subscript:</span>
        <span class="s2">if </span><span class="s1">char </span><span class="s2">not in </span><span class="s1">input_subscripts:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Output character %s did not appear in the input&quot;</span>
                             <span class="s1">% char)</span>

    <span class="s5"># Make sure number operands is equivalent to the number of terms</span>
    <span class="s2">if </span><span class="s1">len(input_subscripts.split(</span><span class="s3">','</span><span class="s1">)) != len(operands):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Number of einsum subscripts must be equal to the &quot;</span>
                         <span class="s3">&quot;number of operands.&quot;</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">(input_subscripts</span><span class="s2">, </span><span class="s1">output_subscript</span><span class="s2">, </span><span class="s1">operands)</span>


<span class="s2">def </span><span class="s1">_einsum_path_dispatcher(*operands</span><span class="s2">, </span><span class="s1">optimize=</span><span class="s2">None, </span><span class="s1">einsum_call=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s5"># NOTE: technically, we should only dispatch on array-like arguments, not</span>
    <span class="s5"># subscripts (given as strings). But separating operands into</span>
    <span class="s5"># arrays/subscripts is a little tricky/slow (given einsum's two supported</span>
    <span class="s5"># signatures), so as a practical shortcut we dispatch on everything.</span>
    <span class="s5"># Strings will be ignored for dispatching since they don't define</span>
    <span class="s5"># __array_function__.</span>
    <span class="s2">return </span><span class="s1">operands</span>


<span class="s1">@array_function_dispatch(_einsum_path_dispatcher</span><span class="s2">, </span><span class="s1">module=</span><span class="s3">'numpy'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">einsum_path(*operands</span><span class="s2">, </span><span class="s1">optimize=</span><span class="s3">'greedy'</span><span class="s2">, </span><span class="s1">einsum_call=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    einsum_path(subscripts, *operands, optimize='greedy') 
 
    Evaluates the lowest cost contraction order for an einsum expression by 
    considering the creation of intermediate arrays. 
 
    Parameters 
    ---------- 
    subscripts : str 
        Specifies the subscripts for summation. 
    *operands : list of array_like 
        These are the arrays for the operation. 
    optimize : {bool, list, tuple, 'greedy', 'optimal'} 
        Choose the type of path. If a tuple is provided, the second argument is 
        assumed to be the maximum intermediate size created. If only a single 
        argument is provided the largest input or output array size is used 
        as a maximum intermediate size. 
 
        * if a list is given that starts with ``einsum_path``, uses this as the 
          contraction path 
        * if False no optimization is taken 
        * if True defaults to the 'greedy' algorithm 
        * 'optimal' An algorithm that combinatorially explores all possible 
          ways of contracting the listed tensors and choosest the least costly 
          path. Scales exponentially with the number of terms in the 
          contraction. 
        * 'greedy' An algorithm that chooses the best pair contraction 
          at each step. Effectively, this algorithm searches the largest inner, 
          Hadamard, and then outer products at each step. Scales cubically with 
          the number of terms in the contraction. Equivalent to the 'optimal' 
          path for most contractions. 
 
        Default is 'greedy'. 
 
    Returns 
    ------- 
    path : list of tuples 
        A list representation of the einsum path. 
    string_repr : str 
        A printable representation of the einsum path. 
 
    Notes 
    ----- 
    The resulting path indicates which terms of the input contraction should be 
    contracted first, the result of this contraction is then appended to the 
    end of the contraction list. This list can then be iterated over until all 
    intermediate contractions are complete. 
 
    See Also 
    -------- 
    einsum, linalg.multi_dot 
 
    Examples 
    -------- 
 
    We can begin with a chain dot example. In this case, it is optimal to 
    contract the ``b`` and ``c`` tensors first as represented by the first 
    element of the path ``(1, 2)``. The resulting tensor is added to the end 
    of the contraction and the remaining contraction ``(0, 1)`` is then 
    completed. 
 
    &gt;&gt;&gt; np.random.seed(123) 
    &gt;&gt;&gt; a = np.random.rand(2, 2) 
    &gt;&gt;&gt; b = np.random.rand(2, 5) 
    &gt;&gt;&gt; c = np.random.rand(5, 2) 
    &gt;&gt;&gt; path_info = np.einsum_path('ij,jk,kl-&gt;il', a, b, c, optimize='greedy') 
    &gt;&gt;&gt; print(path_info[0]) 
    ['einsum_path', (1, 2), (0, 1)] 
    &gt;&gt;&gt; print(path_info[1]) 
      Complete contraction:  ij,jk,kl-&gt;il # may vary 
             Naive scaling:  4 
         Optimized scaling:  3 
          Naive FLOP count:  1.600e+02 
      Optimized FLOP count:  5.600e+01 
       Theoretical speedup:  2.857 
      Largest intermediate:  4.000e+00 elements 
    ------------------------------------------------------------------------- 
    scaling                  current                                remaining 
    ------------------------------------------------------------------------- 
       3                   kl,jk-&gt;jl                                ij,jl-&gt;il 
       3                   jl,ij-&gt;il                                   il-&gt;il 
 
 
    A more complex index transformation example. 
 
    &gt;&gt;&gt; I = np.random.rand(10, 10, 10, 10) 
    &gt;&gt;&gt; C = np.random.rand(10, 10) 
    &gt;&gt;&gt; path_info = np.einsum_path('ea,fb,abcd,gc,hd-&gt;efgh', C, C, I, C, C, 
    ...                            optimize='greedy') 
 
    &gt;&gt;&gt; print(path_info[0]) 
    ['einsum_path', (0, 2), (0, 3), (0, 2), (0, 1)] 
    &gt;&gt;&gt; print(path_info[1])  
      Complete contraction:  ea,fb,abcd,gc,hd-&gt;efgh # may vary 
             Naive scaling:  8 
         Optimized scaling:  5 
          Naive FLOP count:  8.000e+08 
      Optimized FLOP count:  8.000e+05 
       Theoretical speedup:  1000.000 
      Largest intermediate:  1.000e+04 elements 
    -------------------------------------------------------------------------- 
    scaling                  current                                remaining 
    -------------------------------------------------------------------------- 
       5               abcd,ea-&gt;bcde                      fb,gc,hd,bcde-&gt;efgh 
       5               bcde,fb-&gt;cdef                         gc,hd,cdef-&gt;efgh 
       5               cdef,gc-&gt;defg                            hd,defg-&gt;efgh 
       5               defg,hd-&gt;efgh                               efgh-&gt;efgh 
    &quot;&quot;&quot;</span>

    <span class="s5"># Figure out what the path really is</span>
    <span class="s1">path_type = optimize</span>
    <span class="s2">if </span><span class="s1">path_type </span><span class="s2">is True</span><span class="s1">:</span>
        <span class="s1">path_type = </span><span class="s3">'greedy'</span>
    <span class="s2">if </span><span class="s1">path_type </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">path_type = </span><span class="s2">False</span>

    <span class="s1">memory_limit = </span><span class="s2">None</span>

    <span class="s5"># No optimization or a named path algorithm</span>
    <span class="s2">if </span><span class="s1">(path_type </span><span class="s2">is False</span><span class="s1">) </span><span class="s2">or </span><span class="s1">isinstance(path_type</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s2">pass</span>

    <span class="s5"># Given an explicit path</span>
    <span class="s2">elif </span><span class="s1">len(path_type) </span><span class="s2">and </span><span class="s1">(path_type[</span><span class="s4">0</span><span class="s1">] == </span><span class="s3">'einsum_path'</span><span class="s1">):</span>
        <span class="s2">pass</span>

    <span class="s5"># Path tuple with memory limit</span>
    <span class="s2">elif </span><span class="s1">((len(path_type) == </span><span class="s4">2</span><span class="s1">) </span><span class="s2">and </span><span class="s1">isinstance(path_type[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and</span>
            <span class="s1">isinstance(path_type[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">(int</span><span class="s2">, </span><span class="s1">float))):</span>
        <span class="s1">memory_limit = int(path_type[</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">path_type = path_type[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Did not understand the path: %s&quot; </span><span class="s1">% str(path_type))</span>

    <span class="s5"># Hidden option, only einsum should call this</span>
    <span class="s1">einsum_call_arg = einsum_call</span>

    <span class="s5"># Python side parsing</span>
    <span class="s1">input_subscripts</span><span class="s2">, </span><span class="s1">output_subscript</span><span class="s2">, </span><span class="s1">operands = _parse_einsum_input(operands)</span>

    <span class="s5"># Build a few useful list and sets</span>
    <span class="s1">input_list = input_subscripts.split(</span><span class="s3">','</span><span class="s1">)</span>
    <span class="s1">input_sets = [set(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">input_list]</span>
    <span class="s1">output_set = set(output_subscript)</span>
    <span class="s1">indices = set(input_subscripts.replace(</span><span class="s3">','</span><span class="s2">, </span><span class="s3">''</span><span class="s1">))</span>

    <span class="s5"># Get length of each unique dimension and ensure all dimensions are correct</span>
    <span class="s1">dimension_dict = {}</span>
    <span class="s1">broadcast_indices = [[] </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">range(len(input_list))]</span>
    <span class="s2">for </span><span class="s1">tnum</span><span class="s2">, </span><span class="s1">term </span><span class="s2">in </span><span class="s1">enumerate(input_list):</span>
        <span class="s1">sh = operands[tnum].shape</span>
        <span class="s2">if </span><span class="s1">len(sh) != len(term):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Einstein sum subscript %s does not contain the &quot;</span>
                             <span class="s3">&quot;correct number of indices for operand %d.&quot;</span>
                             <span class="s1">% (input_subscripts[tnum]</span><span class="s2">, </span><span class="s1">tnum))</span>
        <span class="s2">for </span><span class="s1">cnum</span><span class="s2">, </span><span class="s1">char </span><span class="s2">in </span><span class="s1">enumerate(term):</span>
            <span class="s1">dim = sh[cnum]</span>

            <span class="s5"># Build out broadcast indices</span>
            <span class="s2">if </span><span class="s1">dim == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">broadcast_indices[tnum].append(char)</span>

            <span class="s2">if </span><span class="s1">char </span><span class="s2">in </span><span class="s1">dimension_dict.keys():</span>
                <span class="s5"># For broadcasting cases we always want the largest dim size</span>
                <span class="s2">if </span><span class="s1">dimension_dict[char] == </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s1">dimension_dict[char] = dim</span>
                <span class="s2">elif </span><span class="s1">dim </span><span class="s2">not in </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">dimension_dict[char]):</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Size of label '%s' for operand %d (%d) &quot;</span>
                                     <span class="s3">&quot;does not match previous terms (%d).&quot;</span>
                                     <span class="s1">% (char</span><span class="s2">, </span><span class="s1">tnum</span><span class="s2">, </span><span class="s1">dimension_dict[char]</span><span class="s2">, </span><span class="s1">dim))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">dimension_dict[char] = dim</span>

    <span class="s5"># Convert broadcast inds to sets</span>
    <span class="s1">broadcast_indices = [set(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">broadcast_indices]</span>

    <span class="s5"># Compute size of each input array plus the output array</span>
    <span class="s1">size_list = [_compute_size_by_dict(term</span><span class="s2">, </span><span class="s1">dimension_dict)</span>
                 <span class="s2">for </span><span class="s1">term </span><span class="s2">in </span><span class="s1">input_list + [output_subscript]]</span>
    <span class="s1">max_size = max(size_list)</span>

    <span class="s2">if </span><span class="s1">memory_limit </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">memory_arg = max_size</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">memory_arg = memory_limit</span>

    <span class="s5"># Compute naive cost</span>
    <span class="s5"># This isn't quite right, need to look into exactly how einsum does this</span>
    <span class="s1">inner_product = (sum(len(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">input_sets) - len(indices)) &gt; </span><span class="s4">0</span>
    <span class="s1">naive_cost = _flop_count(indices</span><span class="s2">, </span><span class="s1">inner_product</span><span class="s2">, </span><span class="s1">len(input_list)</span><span class="s2">, </span><span class="s1">dimension_dict)</span>

    <span class="s5"># Compute the path</span>
    <span class="s2">if </span><span class="s1">(path_type </span><span class="s2">is False</span><span class="s1">) </span><span class="s2">or </span><span class="s1">(len(input_list) </span><span class="s2">in </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]) </span><span class="s2">or </span><span class="s1">(indices == output_set):</span>
        <span class="s5"># Nothing to be optimized, leave it to einsum</span>
        <span class="s1">path = [tuple(range(len(input_list)))]</span>
    <span class="s2">elif </span><span class="s1">path_type == </span><span class="s3">&quot;greedy&quot;</span><span class="s1">:</span>
        <span class="s1">path = _greedy_path(input_sets</span><span class="s2">, </span><span class="s1">output_set</span><span class="s2">, </span><span class="s1">dimension_dict</span><span class="s2">, </span><span class="s1">memory_arg)</span>
    <span class="s2">elif </span><span class="s1">path_type == </span><span class="s3">&quot;optimal&quot;</span><span class="s1">:</span>
        <span class="s1">path = _optimal_path(input_sets</span><span class="s2">, </span><span class="s1">output_set</span><span class="s2">, </span><span class="s1">dimension_dict</span><span class="s2">, </span><span class="s1">memory_arg)</span>
    <span class="s2">elif </span><span class="s1">path_type[</span><span class="s4">0</span><span class="s1">] == </span><span class="s3">'einsum_path'</span><span class="s1">:</span>
        <span class="s1">path = path_type[</span><span class="s4">1</span><span class="s1">:]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">KeyError(</span><span class="s3">&quot;Path name %s not found&quot;</span><span class="s2">, </span><span class="s1">path_type)</span>

    <span class="s1">cost_list</span><span class="s2">, </span><span class="s1">scale_list</span><span class="s2">, </span><span class="s1">size_list</span><span class="s2">, </span><span class="s1">contraction_list = []</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[]</span>

    <span class="s5"># Build contraction tuple (positions, gemm, einsum_str, remaining)</span>
    <span class="s2">for </span><span class="s1">cnum</span><span class="s2">, </span><span class="s1">contract_inds </span><span class="s2">in </span><span class="s1">enumerate(path):</span>
        <span class="s5"># Make sure we remove inds from right to left</span>
        <span class="s1">contract_inds = tuple(sorted(list(contract_inds)</span><span class="s2">, </span><span class="s1">reverse=</span><span class="s2">True</span><span class="s1">))</span>

        <span class="s1">contract = _find_contraction(contract_inds</span><span class="s2">, </span><span class="s1">input_sets</span><span class="s2">, </span><span class="s1">output_set)</span>
        <span class="s1">out_inds</span><span class="s2">, </span><span class="s1">input_sets</span><span class="s2">, </span><span class="s1">idx_removed</span><span class="s2">, </span><span class="s1">idx_contract = contract</span>

        <span class="s1">cost = _flop_count(idx_contract</span><span class="s2">, </span><span class="s1">idx_removed</span><span class="s2">, </span><span class="s1">len(contract_inds)</span><span class="s2">, </span><span class="s1">dimension_dict)</span>
        <span class="s1">cost_list.append(cost)</span>
        <span class="s1">scale_list.append(len(idx_contract))</span>
        <span class="s1">size_list.append(_compute_size_by_dict(out_inds</span><span class="s2">, </span><span class="s1">dimension_dict))</span>

        <span class="s1">bcast = set()</span>
        <span class="s1">tmp_inputs = []</span>
        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">contract_inds:</span>
            <span class="s1">tmp_inputs.append(input_list.pop(x))</span>
            <span class="s1">bcast |= broadcast_indices.pop(x)</span>

        <span class="s1">new_bcast_inds = bcast - idx_removed</span>

        <span class="s5"># If we're broadcasting, nix blas</span>
        <span class="s2">if not </span><span class="s1">len(idx_removed &amp; bcast):</span>
            <span class="s1">do_blas = _can_dot(tmp_inputs</span><span class="s2">, </span><span class="s1">out_inds</span><span class="s2">, </span><span class="s1">idx_removed)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">do_blas = </span><span class="s2">False</span>

        <span class="s5"># Last contraction</span>
        <span class="s2">if </span><span class="s1">(cnum - len(path)) == -</span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">idx_result = output_subscript</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">sort_result = [(dimension_dict[ind]</span><span class="s2">, </span><span class="s1">ind) </span><span class="s2">for </span><span class="s1">ind </span><span class="s2">in </span><span class="s1">out_inds]</span>
            <span class="s1">idx_result = </span><span class="s3">&quot;&quot;</span><span class="s1">.join([x[</span><span class="s4">1</span><span class="s1">] </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">sorted(sort_result)])</span>

        <span class="s1">input_list.append(idx_result)</span>
        <span class="s1">broadcast_indices.append(new_bcast_inds)</span>
        <span class="s1">einsum_str = </span><span class="s3">&quot;,&quot;</span><span class="s1">.join(tmp_inputs) + </span><span class="s3">&quot;-&gt;&quot; </span><span class="s1">+ idx_result</span>

        <span class="s1">contraction = (contract_inds</span><span class="s2">, </span><span class="s1">idx_removed</span><span class="s2">, </span><span class="s1">einsum_str</span><span class="s2">, </span><span class="s1">input_list[:]</span><span class="s2">, </span><span class="s1">do_blas)</span>
        <span class="s1">contraction_list.append(contraction)</span>

    <span class="s1">opt_cost = sum(cost_list) + </span><span class="s4">1</span>

    <span class="s2">if </span><span class="s1">einsum_call_arg:</span>
        <span class="s2">return </span><span class="s1">(operands</span><span class="s2">, </span><span class="s1">contraction_list)</span>

    <span class="s5"># Return the path along with a nice string representation</span>
    <span class="s1">overall_contraction = input_subscripts + </span><span class="s3">&quot;-&gt;&quot; </span><span class="s1">+ output_subscript</span>
    <span class="s1">header = (</span><span class="s3">&quot;scaling&quot;</span><span class="s2">, </span><span class="s3">&quot;current&quot;</span><span class="s2">, </span><span class="s3">&quot;remaining&quot;</span><span class="s1">)</span>

    <span class="s1">speedup = naive_cost / opt_cost</span>
    <span class="s1">max_i = max(size_list)</span>

    <span class="s1">path_print  = </span><span class="s3">&quot;  Complete contraction:  %s</span><span class="s2">\n</span><span class="s3">&quot; </span><span class="s1">% overall_contraction</span>
    <span class="s1">path_print += </span><span class="s3">&quot;         Naive scaling:  %d</span><span class="s2">\n</span><span class="s3">&quot; </span><span class="s1">% len(indices)</span>
    <span class="s1">path_print += </span><span class="s3">&quot;     Optimized scaling:  %d</span><span class="s2">\n</span><span class="s3">&quot; </span><span class="s1">% max(scale_list)</span>
    <span class="s1">path_print += </span><span class="s3">&quot;      Naive FLOP count:  %.3e</span><span class="s2">\n</span><span class="s3">&quot; </span><span class="s1">% naive_cost</span>
    <span class="s1">path_print += </span><span class="s3">&quot;  Optimized FLOP count:  %.3e</span><span class="s2">\n</span><span class="s3">&quot; </span><span class="s1">% opt_cost</span>
    <span class="s1">path_print += </span><span class="s3">&quot;   Theoretical speedup:  %3.3f</span><span class="s2">\n</span><span class="s3">&quot; </span><span class="s1">% speedup</span>
    <span class="s1">path_print += </span><span class="s3">&quot;  Largest intermediate:  %.3e elements</span><span class="s2">\n</span><span class="s3">&quot; </span><span class="s1">% max_i</span>
    <span class="s1">path_print += </span><span class="s3">&quot;-&quot; </span><span class="s1">* </span><span class="s4">74 </span><span class="s1">+ </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s1">path_print += </span><span class="s3">&quot;%6s %24s %40s</span><span class="s2">\n</span><span class="s3">&quot; </span><span class="s1">% header</span>
    <span class="s1">path_print += </span><span class="s3">&quot;-&quot; </span><span class="s1">* </span><span class="s4">74</span>

    <span class="s2">for </span><span class="s1">n</span><span class="s2">, </span><span class="s1">contraction </span><span class="s2">in </span><span class="s1">enumerate(contraction_list):</span>
        <span class="s1">inds</span><span class="s2">, </span><span class="s1">idx_rm</span><span class="s2">, </span><span class="s1">einsum_str</span><span class="s2">, </span><span class="s1">remaining</span><span class="s2">, </span><span class="s1">blas = contraction</span>
        <span class="s1">remaining_str = </span><span class="s3">&quot;,&quot;</span><span class="s1">.join(remaining) + </span><span class="s3">&quot;-&gt;&quot; </span><span class="s1">+ output_subscript</span>
        <span class="s1">path_run = (scale_list[n]</span><span class="s2">, </span><span class="s1">einsum_str</span><span class="s2">, </span><span class="s1">remaining_str)</span>
        <span class="s1">path_print += </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">%4d    %24s %40s&quot; </span><span class="s1">% path_run</span>

    <span class="s1">path = [</span><span class="s3">'einsum_path'</span><span class="s1">] + path</span>
    <span class="s2">return </span><span class="s1">(path</span><span class="s2">, </span><span class="s1">path_print)</span>


<span class="s2">def </span><span class="s1">_einsum_dispatcher(*operands</span><span class="s2">, </span><span class="s1">out=</span><span class="s2">None, </span><span class="s1">optimize=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
    <span class="s5"># Arguably we dispatch on more arguments that we really should; see note in</span>
    <span class="s5"># _einsum_path_dispatcher for why.</span>
    <span class="s2">yield from </span><span class="s1">operands</span>
    <span class="s2">yield </span><span class="s1">out</span>


<span class="s5"># Rewrite einsum to handle different cases</span>
<span class="s1">@array_function_dispatch(_einsum_dispatcher</span><span class="s2">, </span><span class="s1">module=</span><span class="s3">'numpy'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">einsum(*operands</span><span class="s2">, </span><span class="s1">out=</span><span class="s2">None, </span><span class="s1">optimize=</span><span class="s2">False, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    einsum(subscripts, *operands, out=None, dtype=None, order='K', 
           casting='safe', optimize=False) 
 
    Evaluates the Einstein summation convention on the operands. 
 
    Using the Einstein summation convention, many common multi-dimensional, 
    linear algebraic array operations can be represented in a simple fashion. 
    In *implicit* mode `einsum` computes these values. 
 
    In *explicit* mode, `einsum` provides further flexibility to compute 
    other array operations that might not be considered classical Einstein 
    summation operations, by disabling, or forcing summation over specified 
    subscript labels. 
 
    See the notes and examples for clarification. 
 
    Parameters 
    ---------- 
    subscripts : str 
        Specifies the subscripts for summation as comma separated list of 
        subscript labels. An implicit (classical Einstein summation) 
        calculation is performed unless the explicit indicator '-&gt;' is 
        included as well as subscript labels of the precise output form. 
    operands : list of array_like 
        These are the arrays for the operation. 
    out : ndarray, optional 
        If provided, the calculation is done into this array. 
    dtype : {data-type, None}, optional 
        If provided, forces the calculation to use the data type specified. 
        Note that you may have to also give a more liberal `casting` 
        parameter to allow the conversions. Default is None. 
    order : {'C', 'F', 'A', 'K'}, optional 
        Controls the memory layout of the output. 'C' means it should 
        be C contiguous. 'F' means it should be Fortran contiguous, 
        'A' means it should be 'F' if the inputs are all 'F', 'C' otherwise. 
        'K' means it should be as close to the layout as the inputs as 
        is possible, including arbitrarily permuted axes. 
        Default is 'K'. 
    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional 
        Controls what kind of data casting may occur.  Setting this to 
        'unsafe' is not recommended, as it can adversely affect accumulations. 
 
          * 'no' means the data types should not be cast at all. 
          * 'equiv' means only byte-order changes are allowed. 
          * 'safe' means only casts which can preserve values are allowed. 
          * 'same_kind' means only safe casts or casts within a kind, 
            like float64 to float32, are allowed. 
          * 'unsafe' means any data conversions may be done. 
 
        Default is 'safe'. 
    optimize : {False, True, 'greedy', 'optimal'}, optional 
        Controls if intermediate optimization should occur. No optimization 
        will occur if False and True will default to the 'greedy' algorithm. 
        Also accepts an explicit contraction list from the ``np.einsum_path`` 
        function. See ``np.einsum_path`` for more details. Defaults to False. 
 
    Returns 
    ------- 
    output : ndarray 
        The calculation based on the Einstein summation convention. 
 
    See Also 
    -------- 
    einsum_path, dot, inner, outer, tensordot, linalg.multi_dot 
 
    einops: 
        similar verbose interface is provided by 
        `einops &lt;https://github.com/arogozhnikov/einops&gt;`_ package to cover 
        additional operations: transpose, reshape/flatten, repeat/tile, 
        squeeze/unsqueeze and reductions. 
 
    opt_einsum: 
        `opt_einsum &lt;https://optimized-einsum.readthedocs.io/en/stable/&gt;`_ 
        optimizes contraction order for einsum-like expressions 
        in backend-agnostic manner. 
 
    Notes 
    ----- 
    .. versionadded:: 1.6.0 
 
    The Einstein summation convention can be used to compute 
    many multi-dimensional, linear algebraic array operations. `einsum` 
    provides a succinct way of representing these. 
 
    A non-exhaustive list of these operations, 
    which can be computed by `einsum`, is shown below along with examples: 
 
    * Trace of an array, :py:func:`numpy.trace`. 
    * Return a diagonal, :py:func:`numpy.diag`. 
    * Array axis summations, :py:func:`numpy.sum`. 
    * Transpositions and permutations, :py:func:`numpy.transpose`. 
    * Matrix multiplication and dot product, :py:func:`numpy.matmul` :py:func:`numpy.dot`. 
    * Vector inner and outer products, :py:func:`numpy.inner` :py:func:`numpy.outer`. 
    * Broadcasting, element-wise and scalar multiplication, :py:func:`numpy.multiply`. 
    * Tensor contractions, :py:func:`numpy.tensordot`. 
    * Chained array operations, in efficient calculation order, :py:func:`numpy.einsum_path`. 
 
    The subscripts string is a comma-separated list of subscript labels, 
    where each label refers to a dimension of the corresponding operand. 
    Whenever a label is repeated it is summed, so ``np.einsum('i,i', a, b)`` 
    is equivalent to :py:func:`np.inner(a,b) &lt;numpy.inner&gt;`. If a label 
    appears only once, it is not summed, so ``np.einsum('i', a)`` produces a 
    view of ``a`` with no changes. A further example ``np.einsum('ij,jk', a, b)`` 
    describes traditional matrix multiplication and is equivalent to 
    :py:func:`np.matmul(a,b) &lt;numpy.matmul&gt;`. Repeated subscript labels in one 
    operand take the diagonal. For example, ``np.einsum('ii', a)`` is equivalent 
    to :py:func:`np.trace(a) &lt;numpy.trace&gt;`. 
 
    In *implicit mode*, the chosen subscripts are important 
    since the axes of the output are reordered alphabetically.  This 
    means that ``np.einsum('ij', a)`` doesn't affect a 2D array, while 
    ``np.einsum('ji', a)`` takes its transpose. Additionally, 
    ``np.einsum('ij,jk', a, b)`` returns a matrix multiplication, while, 
    ``np.einsum('ij,jh', a, b)`` returns the transpose of the 
    multiplication since subscript 'h' precedes subscript 'i'. 
 
    In *explicit mode* the output can be directly controlled by 
    specifying output subscript labels.  This requires the 
    identifier '-&gt;' as well as the list of output subscript labels. 
    This feature increases the flexibility of the function since 
    summing can be disabled or forced when required. The call 
    ``np.einsum('i-&gt;', a)`` is like :py:func:`np.sum(a, axis=-1) &lt;numpy.sum&gt;`, 
    and ``np.einsum('ii-&gt;i', a)`` is like :py:func:`np.diag(a) &lt;numpy.diag&gt;`. 
    The difference is that `einsum` does not allow broadcasting by default. 
    Additionally ``np.einsum('ij,jh-&gt;ih', a, b)`` directly specifies the 
    order of the output subscript labels and therefore returns matrix 
    multiplication, unlike the example above in implicit mode. 
 
    To enable and control broadcasting, use an ellipsis.  Default 
    NumPy-style broadcasting is done by adding an ellipsis 
    to the left of each term, like ``np.einsum('...ii-&gt;...i', a)``. 
    To take the trace along the first and last axes, 
    you can do ``np.einsum('i...i', a)``, or to do a matrix-matrix 
    product with the left-most indices instead of rightmost, one can do 
    ``np.einsum('ij...,jk...-&gt;ik...', a, b)``. 
 
    When there is only one operand, no axes are summed, and no output 
    parameter is provided, a view into the operand is returned instead 
    of a new array.  Thus, taking the diagonal as ``np.einsum('ii-&gt;i', a)`` 
    produces a view (changed in version 1.10.0). 
 
    `einsum` also provides an alternative way to provide the subscripts 
    and operands as ``einsum(op0, sublist0, op1, sublist1, ..., [sublistout])``. 
    If the output shape is not provided in this format `einsum` will be 
    calculated in implicit mode, otherwise it will be performed explicitly. 
    The examples below have corresponding `einsum` calls with the two 
    parameter methods. 
 
    .. versionadded:: 1.10.0 
 
    Views returned from einsum are now writeable whenever the input array 
    is writeable. For example, ``np.einsum('ijk...-&gt;kji...', a)`` will now 
    have the same effect as :py:func:`np.swapaxes(a, 0, 2) &lt;numpy.swapaxes&gt;` 
    and ``np.einsum('ii-&gt;i', a)`` will return a writeable view of the diagonal 
    of a 2D array. 
 
    .. versionadded:: 1.12.0 
 
    Added the ``optimize`` argument which will optimize the contraction order 
    of an einsum expression. For a contraction with three or more operands this 
    can greatly increase the computational efficiency at the cost of a larger 
    memory footprint during computation. 
 
    Typically a 'greedy' algorithm is applied which empirical tests have shown 
    returns the optimal path in the majority of cases. In some cases 'optimal' 
    will return the superlative path through a more expensive, exhaustive search. 
    For iterative calculations it may be advisable to calculate the optimal path 
    once and reuse that path by supplying it as an argument. An example is given 
    below. 
 
    See :py:func:`numpy.einsum_path` for more details. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; a = np.arange(25).reshape(5,5) 
    &gt;&gt;&gt; b = np.arange(5) 
    &gt;&gt;&gt; c = np.arange(6).reshape(2,3) 
 
    Trace of a matrix: 
 
    &gt;&gt;&gt; np.einsum('ii', a) 
    60 
    &gt;&gt;&gt; np.einsum(a, [0,0]) 
    60 
    &gt;&gt;&gt; np.trace(a) 
    60 
 
    Extract the diagonal (requires explicit form): 
 
    &gt;&gt;&gt; np.einsum('ii-&gt;i', a) 
    array([ 0,  6, 12, 18, 24]) 
    &gt;&gt;&gt; np.einsum(a, [0,0], [0]) 
    array([ 0,  6, 12, 18, 24]) 
    &gt;&gt;&gt; np.diag(a) 
    array([ 0,  6, 12, 18, 24]) 
 
    Sum over an axis (requires explicit form): 
 
    &gt;&gt;&gt; np.einsum('ij-&gt;i', a) 
    array([ 10,  35,  60,  85, 110]) 
    &gt;&gt;&gt; np.einsum(a, [0,1], [0]) 
    array([ 10,  35,  60,  85, 110]) 
    &gt;&gt;&gt; np.sum(a, axis=1) 
    array([ 10,  35,  60,  85, 110]) 
 
    For higher dimensional arrays summing a single axis can be done with ellipsis: 
 
    &gt;&gt;&gt; np.einsum('...j-&gt;...', a) 
    array([ 10,  35,  60,  85, 110]) 
    &gt;&gt;&gt; np.einsum(a, [Ellipsis,1], [Ellipsis]) 
    array([ 10,  35,  60,  85, 110]) 
 
    Compute a matrix transpose, or reorder any number of axes: 
 
    &gt;&gt;&gt; np.einsum('ji', c) 
    array([[0, 3], 
           [1, 4], 
           [2, 5]]) 
    &gt;&gt;&gt; np.einsum('ij-&gt;ji', c) 
    array([[0, 3], 
           [1, 4], 
           [2, 5]]) 
    &gt;&gt;&gt; np.einsum(c, [1,0]) 
    array([[0, 3], 
           [1, 4], 
           [2, 5]]) 
    &gt;&gt;&gt; np.transpose(c) 
    array([[0, 3], 
           [1, 4], 
           [2, 5]]) 
 
    Vector inner products: 
 
    &gt;&gt;&gt; np.einsum('i,i', b, b) 
    30 
    &gt;&gt;&gt; np.einsum(b, [0], b, [0]) 
    30 
    &gt;&gt;&gt; np.inner(b,b) 
    30 
 
    Matrix vector multiplication: 
 
    &gt;&gt;&gt; np.einsum('ij,j', a, b) 
    array([ 30,  80, 130, 180, 230]) 
    &gt;&gt;&gt; np.einsum(a, [0,1], b, [1]) 
    array([ 30,  80, 130, 180, 230]) 
    &gt;&gt;&gt; np.dot(a, b) 
    array([ 30,  80, 130, 180, 230]) 
    &gt;&gt;&gt; np.einsum('...j,j', a, b) 
    array([ 30,  80, 130, 180, 230]) 
 
    Broadcasting and scalar multiplication: 
 
    &gt;&gt;&gt; np.einsum('..., ...', 3, c) 
    array([[ 0,  3,  6], 
           [ 9, 12, 15]]) 
    &gt;&gt;&gt; np.einsum(',ij', 3, c) 
    array([[ 0,  3,  6], 
           [ 9, 12, 15]]) 
    &gt;&gt;&gt; np.einsum(3, [Ellipsis], c, [Ellipsis]) 
    array([[ 0,  3,  6], 
           [ 9, 12, 15]]) 
    &gt;&gt;&gt; np.multiply(3, c) 
    array([[ 0,  3,  6], 
           [ 9, 12, 15]]) 
 
    Vector outer product: 
 
    &gt;&gt;&gt; np.einsum('i,j', np.arange(2)+1, b) 
    array([[0, 1, 2, 3, 4], 
           [0, 2, 4, 6, 8]]) 
    &gt;&gt;&gt; np.einsum(np.arange(2)+1, [0], b, [1]) 
    array([[0, 1, 2, 3, 4], 
           [0, 2, 4, 6, 8]]) 
    &gt;&gt;&gt; np.outer(np.arange(2)+1, b) 
    array([[0, 1, 2, 3, 4], 
           [0, 2, 4, 6, 8]]) 
 
    Tensor contraction: 
 
    &gt;&gt;&gt; a = np.arange(60.).reshape(3,4,5) 
    &gt;&gt;&gt; b = np.arange(24.).reshape(4,3,2) 
    &gt;&gt;&gt; np.einsum('ijk,jil-&gt;kl', a, b) 
    array([[4400., 4730.], 
           [4532., 4874.], 
           [4664., 5018.], 
           [4796., 5162.], 
           [4928., 5306.]]) 
    &gt;&gt;&gt; np.einsum(a, [0,1,2], b, [1,0,3], [2,3]) 
    array([[4400., 4730.], 
           [4532., 4874.], 
           [4664., 5018.], 
           [4796., 5162.], 
           [4928., 5306.]]) 
    &gt;&gt;&gt; np.tensordot(a,b, axes=([1,0],[0,1])) 
    array([[4400., 4730.], 
           [4532., 4874.], 
           [4664., 5018.], 
           [4796., 5162.], 
           [4928., 5306.]]) 
 
    Writeable returned arrays (since version 1.10.0): 
 
    &gt;&gt;&gt; a = np.zeros((3, 3)) 
    &gt;&gt;&gt; np.einsum('ii-&gt;i', a)[:] = 1 
    &gt;&gt;&gt; a 
    array([[1., 0., 0.], 
           [0., 1., 0.], 
           [0., 0., 1.]]) 
 
    Example of ellipsis use: 
 
    &gt;&gt;&gt; a = np.arange(6).reshape((3,2)) 
    &gt;&gt;&gt; b = np.arange(12).reshape((4,3)) 
    &gt;&gt;&gt; np.einsum('ki,jk-&gt;ij', a, b) 
    array([[10, 28, 46, 64], 
           [13, 40, 67, 94]]) 
    &gt;&gt;&gt; np.einsum('ki,...k-&gt;i...', a, b) 
    array([[10, 28, 46, 64], 
           [13, 40, 67, 94]]) 
    &gt;&gt;&gt; np.einsum('k...,jk', a, b) 
    array([[10, 28, 46, 64], 
           [13, 40, 67, 94]]) 
 
    Chained array operations. For more complicated contractions, speed ups 
    might be achieved by repeatedly computing a 'greedy' path or pre-computing the 
    'optimal' path and repeatedly applying it, using an 
    `einsum_path` insertion (since version 1.12.0). Performance improvements can be 
    particularly significant with larger arrays: 
 
    &gt;&gt;&gt; a = np.ones(64).reshape(2,4,8) 
 
    Basic `einsum`: ~1520ms  (benchmarked on 3.1GHz Intel i5.) 
 
    &gt;&gt;&gt; for iteration in range(500): 
    ...     _ = np.einsum('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a) 
 
    Sub-optimal `einsum` (due to repeated path calculation time): ~330ms 
 
    &gt;&gt;&gt; for iteration in range(500): 
    ...     _ = np.einsum('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a, optimize='optimal') 
 
    Greedy `einsum` (faster optimal path approximation): ~160ms 
 
    &gt;&gt;&gt; for iteration in range(500): 
    ...     _ = np.einsum('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a, optimize='greedy') 
 
    Optimal `einsum` (best usage pattern in some use cases): ~110ms 
 
    &gt;&gt;&gt; path = np.einsum_path('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a, optimize='optimal')[0] 
    &gt;&gt;&gt; for iteration in range(500): 
    ...     _ = np.einsum('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a, optimize=path) 
 
    &quot;&quot;&quot;</span>
    <span class="s5"># Special handling if out is specified</span>
    <span class="s1">specified_out = out </span><span class="s2">is not None</span>

    <span class="s5"># If no optimization, run pure einsum</span>
    <span class="s2">if </span><span class="s1">optimize </span><span class="s2">is False</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">specified_out:</span>
            <span class="s1">kwargs[</span><span class="s3">'out'</span><span class="s1">] = out</span>
        <span class="s2">return </span><span class="s1">c_einsum(*operands</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s5"># Check the kwargs to avoid a more cryptic error later, without having to</span>
    <span class="s5"># repeat default values here</span>
    <span class="s1">valid_einsum_kwargs = [</span><span class="s3">'dtype'</span><span class="s2">, </span><span class="s3">'order'</span><span class="s2">, </span><span class="s3">'casting'</span><span class="s1">]</span>
    <span class="s1">unknown_kwargs = [k </span><span class="s2">for </span><span class="s1">(k</span><span class="s2">, </span><span class="s1">v) </span><span class="s2">in </span><span class="s1">kwargs.items() </span><span class="s2">if</span>
                      <span class="s1">k </span><span class="s2">not in </span><span class="s1">valid_einsum_kwargs]</span>
    <span class="s2">if </span><span class="s1">len(unknown_kwargs):</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Did not understand the following kwargs: %s&quot;</span>
                        <span class="s1">% unknown_kwargs)</span>

    <span class="s5"># Build the contraction list and operand</span>
    <span class="s1">operands</span><span class="s2">, </span><span class="s1">contraction_list = einsum_path(*operands</span><span class="s2">, </span><span class="s1">optimize=optimize</span><span class="s2">,</span>
                                             <span class="s1">einsum_call=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s5"># Handle order kwarg for output array, c_einsum allows mixed case</span>
    <span class="s1">output_order = kwargs.pop(</span><span class="s3">'order'</span><span class="s2">, </span><span class="s3">'K'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">output_order.upper() == </span><span class="s3">'A'</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">all(arr.flags.f_contiguous </span><span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">operands):</span>
            <span class="s1">output_order = </span><span class="s3">'F'</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">output_order = </span><span class="s3">'C'</span>

    <span class="s5"># Start contraction loop</span>
    <span class="s2">for </span><span class="s1">num</span><span class="s2">, </span><span class="s1">contraction </span><span class="s2">in </span><span class="s1">enumerate(contraction_list):</span>
        <span class="s1">inds</span><span class="s2">, </span><span class="s1">idx_rm</span><span class="s2">, </span><span class="s1">einsum_str</span><span class="s2">, </span><span class="s1">remaining</span><span class="s2">, </span><span class="s1">blas = contraction</span>
        <span class="s1">tmp_operands = [operands.pop(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">inds]</span>

        <span class="s5"># Do we need to deal with the output?</span>
        <span class="s1">handle_out = specified_out </span><span class="s2">and </span><span class="s1">((num + </span><span class="s4">1</span><span class="s1">) == len(contraction_list))</span>

        <span class="s5"># Call tensordot if still possible</span>
        <span class="s2">if </span><span class="s1">blas:</span>
            <span class="s5"># Checks have already been handled</span>
            <span class="s1">input_str</span><span class="s2">, </span><span class="s1">results_index = einsum_str.split(</span><span class="s3">'-&gt;'</span><span class="s1">)</span>
            <span class="s1">input_left</span><span class="s2">, </span><span class="s1">input_right = input_str.split(</span><span class="s3">','</span><span class="s1">)</span>

            <span class="s1">tensor_result = input_left + input_right</span>
            <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">idx_rm:</span>
                <span class="s1">tensor_result = tensor_result.replace(s</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>

            <span class="s5"># Find indices to contract over</span>
            <span class="s1">left_pos</span><span class="s2">, </span><span class="s1">right_pos = []</span><span class="s2">, </span><span class="s1">[]</span>
            <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">sorted(idx_rm):</span>
                <span class="s1">left_pos.append(input_left.find(s))</span>
                <span class="s1">right_pos.append(input_right.find(s))</span>

            <span class="s5"># Contract!</span>
            <span class="s1">new_view = tensordot(*tmp_operands</span><span class="s2">, </span><span class="s1">axes=(tuple(left_pos)</span><span class="s2">, </span><span class="s1">tuple(right_pos)))</span>

            <span class="s5"># Build a new view if needed</span>
            <span class="s2">if </span><span class="s1">(tensor_result != results_index) </span><span class="s2">or </span><span class="s1">handle_out:</span>
                <span class="s2">if </span><span class="s1">handle_out:</span>
                    <span class="s1">kwargs[</span><span class="s3">&quot;out&quot;</span><span class="s1">] = out</span>
                <span class="s1">new_view = c_einsum(tensor_result + </span><span class="s3">'-&gt;' </span><span class="s1">+ results_index</span><span class="s2">, </span><span class="s1">new_view</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s5"># Call einsum</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># If out was specified</span>
            <span class="s2">if </span><span class="s1">handle_out:</span>
                <span class="s1">kwargs[</span><span class="s3">&quot;out&quot;</span><span class="s1">] = out</span>

            <span class="s5"># Do the contraction</span>
            <span class="s1">new_view = c_einsum(einsum_str</span><span class="s2">, </span><span class="s1">*tmp_operands</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s5"># Append new items and dereference what we can</span>
        <span class="s1">operands.append(new_view)</span>
        <span class="s2">del </span><span class="s1">tmp_operands</span><span class="s2">, </span><span class="s1">new_view</span>

    <span class="s2">if </span><span class="s1">specified_out:</span>
        <span class="s2">return </span><span class="s1">out</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">asanyarray(operands[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=output_order)</span>
</pre>
</body>
</html>