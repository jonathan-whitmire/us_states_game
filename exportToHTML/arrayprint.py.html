<html>
<head>
<title>arrayprint.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
arrayprint.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Array printing function 
 
$Id: arrayprint.py,v 1.9 2005/09/13 13:58:44 teoliphant Exp $ 
 
&quot;&quot;&quot;</span>
<span class="s1">__all__ = [</span><span class="s2">&quot;array2string&quot;</span><span class="s3">, </span><span class="s2">&quot;array_str&quot;</span><span class="s3">, </span><span class="s2">&quot;array_repr&quot;</span><span class="s3">, </span><span class="s2">&quot;set_string_function&quot;</span><span class="s3">,</span>
           <span class="s2">&quot;set_printoptions&quot;</span><span class="s3">, </span><span class="s2">&quot;get_printoptions&quot;</span><span class="s3">, </span><span class="s2">&quot;printoptions&quot;</span><span class="s3">,</span>
           <span class="s2">&quot;format_float_positional&quot;</span><span class="s3">, </span><span class="s2">&quot;format_float_scientific&quot;</span><span class="s1">]</span>
<span class="s1">__docformat__ = </span><span class="s2">'restructuredtext'</span>

<span class="s4">#</span>
<span class="s4"># Written by Konrad Hinsen &lt;hinsenk@ere.umontreal.ca&gt;</span>
<span class="s4"># last revision: 1996-3-13</span>
<span class="s4"># modified by Jim Hugunin 1997-3-3 for repr's and str's (and other details)</span>
<span class="s4"># and by Perry Greenfield 2000-4-1 for numarray</span>
<span class="s4"># and by Travis Oliphant  2005-8-22 for numpy</span>


<span class="s4"># Note: Both scalartypes.c.src and arrayprint.py implement strs for numpy</span>
<span class="s4"># scalars but for different purposes. scalartypes.c.src has str/reprs for when</span>
<span class="s4"># the scalar is printed on its own, while arrayprint.py has strs for when</span>
<span class="s4"># scalars are printed inside an ndarray. Only the latter strs are currently</span>
<span class="s4"># user-customizable.</span>

<span class="s3">import </span><span class="s1">functools</span>
<span class="s3">import </span><span class="s1">numbers</span>
<span class="s3">try</span><span class="s1">:</span>
    <span class="s3">from </span><span class="s1">_thread </span><span class="s3">import </span><span class="s1">get_ident</span>
<span class="s3">except </span><span class="s1">ImportError:</span>
    <span class="s3">from </span><span class="s1">_dummy_thread </span><span class="s3">import </span><span class="s1">get_ident</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">numerictypes </span><span class="s3">as </span><span class="s1">_nt</span>
<span class="s3">from </span><span class="s1">.umath </span><span class="s3">import </span><span class="s1">absolute</span><span class="s3">, </span><span class="s1">isinf</span><span class="s3">, </span><span class="s1">isfinite</span><span class="s3">, </span><span class="s1">isnat</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">multiarray</span>
<span class="s3">from </span><span class="s1">.multiarray </span><span class="s3">import </span><span class="s1">(array</span><span class="s3">, </span><span class="s1">dragon4_positional</span><span class="s3">, </span><span class="s1">dragon4_scientific</span><span class="s3">,</span>
                         <span class="s1">datetime_as_string</span><span class="s3">, </span><span class="s1">datetime_data</span><span class="s3">, </span><span class="s1">ndarray</span><span class="s3">,</span>
                         <span class="s1">set_legacy_print_mode)</span>
<span class="s3">from </span><span class="s1">.fromnumeric </span><span class="s3">import </span><span class="s1">any</span>
<span class="s3">from </span><span class="s1">.numeric </span><span class="s3">import </span><span class="s1">concatenate</span><span class="s3">, </span><span class="s1">asarray</span><span class="s3">, </span><span class="s1">errstate</span>
<span class="s3">from </span><span class="s1">.numerictypes </span><span class="s3">import </span><span class="s1">(longlong</span><span class="s3">, </span><span class="s1">intc</span><span class="s3">, </span><span class="s1">int_</span><span class="s3">, </span><span class="s1">float_</span><span class="s3">, </span><span class="s1">complex_</span><span class="s3">, </span><span class="s1">bool_</span><span class="s3">,</span>
                           <span class="s1">flexible)</span>
<span class="s3">from </span><span class="s1">.overrides </span><span class="s3">import </span><span class="s1">array_function_dispatch</span><span class="s3">, </span><span class="s1">set_module</span>
<span class="s3">import </span><span class="s1">warnings</span>
<span class="s3">import </span><span class="s1">contextlib</span>

<span class="s1">_format_options = {</span>
    <span class="s2">'edgeitems'</span><span class="s1">: </span><span class="s5">3</span><span class="s3">,  </span><span class="s4"># repr N leading and trailing items of each dimension</span>
    <span class="s2">'threshold'</span><span class="s1">: </span><span class="s5">1000</span><span class="s3">,  </span><span class="s4"># total items &gt; triggers array summarization</span>
    <span class="s2">'floatmode'</span><span class="s1">: </span><span class="s2">'maxprec'</span><span class="s3">,</span>
    <span class="s2">'precision'</span><span class="s1">: </span><span class="s5">8</span><span class="s3">,  </span><span class="s4"># precision of floating point representations</span>
    <span class="s2">'suppress'</span><span class="s1">: </span><span class="s3">False,  </span><span class="s4"># suppress printing small floating values in exp format</span>
    <span class="s2">'linewidth'</span><span class="s1">: </span><span class="s5">75</span><span class="s3">,</span>
    <span class="s2">'nanstr'</span><span class="s1">: </span><span class="s2">'nan'</span><span class="s3">,</span>
    <span class="s2">'infstr'</span><span class="s1">: </span><span class="s2">'inf'</span><span class="s3">,</span>
    <span class="s2">'sign'</span><span class="s1">: </span><span class="s2">'-'</span><span class="s3">,</span>
    <span class="s2">'formatter'</span><span class="s1">: </span><span class="s3">None,</span>
    <span class="s2">'legacy'</span><span class="s1">: </span><span class="s3">False</span><span class="s1">}</span>

<span class="s3">def </span><span class="s1">_make_options_dict(precision=</span><span class="s3">None, </span><span class="s1">threshold=</span><span class="s3">None, </span><span class="s1">edgeitems=</span><span class="s3">None,</span>
                       <span class="s1">linewidth=</span><span class="s3">None, </span><span class="s1">suppress=</span><span class="s3">None, </span><span class="s1">nanstr=</span><span class="s3">None, </span><span class="s1">infstr=</span><span class="s3">None,</span>
                       <span class="s1">sign=</span><span class="s3">None, </span><span class="s1">formatter=</span><span class="s3">None, </span><span class="s1">floatmode=</span><span class="s3">None, </span><span class="s1">legacy=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; make a dictionary out of the non-None arguments, plus sanity checks &quot;&quot;&quot;</span>

    <span class="s1">options = {k: v </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">locals().items() </span><span class="s3">if </span><span class="s1">v </span><span class="s3">is not None</span><span class="s1">}</span>

    <span class="s3">if </span><span class="s1">suppress </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">options[</span><span class="s2">'suppress'</span><span class="s1">] = bool(suppress)</span>

    <span class="s1">modes = [</span><span class="s2">'fixed'</span><span class="s3">, </span><span class="s2">'unique'</span><span class="s3">, </span><span class="s2">'maxprec'</span><span class="s3">, </span><span class="s2">'maxprec_equal'</span><span class="s1">]</span>
    <span class="s3">if </span><span class="s1">floatmode </span><span class="s3">not in </span><span class="s1">modes + [</span><span class="s3">None</span><span class="s1">]:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;floatmode option must be one of &quot; </span><span class="s1">+</span>
                         <span class="s2">&quot;, &quot;</span><span class="s1">.join(</span><span class="s2">'&quot;{}&quot;'</span><span class="s1">.format(m) </span><span class="s3">for </span><span class="s1">m </span><span class="s3">in </span><span class="s1">modes))</span>

    <span class="s3">if </span><span class="s1">sign </span><span class="s3">not in </span><span class="s1">[</span><span class="s3">None, </span><span class="s2">'-'</span><span class="s3">, </span><span class="s2">'+'</span><span class="s3">, </span><span class="s2">' '</span><span class="s1">]:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;sign option must be one of ' ', '+', or '-'&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">legacy </span><span class="s3">not in </span><span class="s1">[</span><span class="s3">None, False, </span><span class="s2">'1.13'</span><span class="s1">]:</span>
        <span class="s1">warnings.warn(</span><span class="s2">&quot;legacy printing option can currently only be '1.13' or &quot;</span>
                      <span class="s2">&quot;`False`&quot;</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">3</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">threshold </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s4"># forbid the bad threshold arg suggested by stack overflow, gh-12351</span>
        <span class="s3">if not </span><span class="s1">isinstance(threshold</span><span class="s3">, </span><span class="s1">numbers.Number):</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;threshold must be numeric&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">np.isnan(threshold):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;threshold must be non-NAN, try &quot;</span>
                             <span class="s2">&quot;sys.maxsize for untruncated representation&quot;</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">options</span>


<span class="s1">@set_module(</span><span class="s2">'numpy'</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">set_printoptions(precision=</span><span class="s3">None, </span><span class="s1">threshold=</span><span class="s3">None, </span><span class="s1">edgeitems=</span><span class="s3">None,</span>
                     <span class="s1">linewidth=</span><span class="s3">None, </span><span class="s1">suppress=</span><span class="s3">None, </span><span class="s1">nanstr=</span><span class="s3">None, </span><span class="s1">infstr=</span><span class="s3">None,</span>
                     <span class="s1">formatter=</span><span class="s3">None, </span><span class="s1">sign=</span><span class="s3">None, </span><span class="s1">floatmode=</span><span class="s3">None, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">legacy=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Set printing options. 
 
    These options determine the way floating point numbers, arrays and 
    other NumPy objects are displayed. 
 
    Parameters 
    ---------- 
    precision : int or None, optional 
        Number of digits of precision for floating point output (default 8). 
        May be None if `floatmode` is not `fixed`, to print as many digits as 
        necessary to uniquely specify the value. 
    threshold : int, optional 
        Total number of array elements which trigger summarization 
        rather than full repr (default 1000). 
        To always use the full repr without summarization, pass `sys.maxsize`. 
    edgeitems : int, optional 
        Number of array items in summary at beginning and end of 
        each dimension (default 3). 
    linewidth : int, optional 
        The number of characters per line for the purpose of inserting 
        line breaks (default 75). 
    suppress : bool, optional 
        If True, always print floating point numbers using fixed point 
        notation, in which case numbers equal to zero in the current precision 
        will print as zero.  If False, then scientific notation is used when 
        absolute value of the smallest number is &lt; 1e-4 or the ratio of the 
        maximum absolute value to the minimum is &gt; 1e3. The default is False. 
    nanstr : str, optional 
        String representation of floating point not-a-number (default nan). 
    infstr : str, optional 
        String representation of floating point infinity (default inf). 
    sign : string, either '-', '+', or ' ', optional 
        Controls printing of the sign of floating-point types. If '+', always 
        print the sign of positive values. If ' ', always prints a space 
        (whitespace character) in the sign position of positive values.  If 
        '-', omit the sign character of positive values. (default '-') 
    formatter : dict of callables, optional 
        If not None, the keys should indicate the type(s) that the respective 
        formatting function applies to.  Callables should return a string. 
        Types that are not specified (by their corresponding keys) are handled 
        by the default formatters.  Individual types for which a formatter 
        can be set are: 
 
        - 'bool' 
        - 'int' 
        - 'timedelta' : a `numpy.timedelta64` 
        - 'datetime' : a `numpy.datetime64` 
        - 'float' 
        - 'longfloat' : 128-bit floats 
        - 'complexfloat' 
        - 'longcomplexfloat' : composed of two 128-bit floats 
        - 'numpystr' : types `numpy.string_` and `numpy.unicode_` 
        - 'object' : `np.object_` arrays 
        - 'str' : all other strings 
 
        Other keys that can be used to set a group of types at once are: 
 
        - 'all' : sets all types 
        - 'int_kind' : sets 'int' 
        - 'float_kind' : sets 'float' and 'longfloat' 
        - 'complex_kind' : sets 'complexfloat' and 'longcomplexfloat' 
        - 'str_kind' : sets 'str' and 'numpystr' 
    floatmode : str, optional 
        Controls the interpretation of the `precision` option for 
        floating-point types. Can take the following values 
        (default maxprec_equal): 
 
        * 'fixed': Always print exactly `precision` fractional digits, 
                even if this would print more or fewer digits than 
                necessary to specify the value uniquely. 
        * 'unique': Print the minimum number of fractional digits necessary 
                to represent each value uniquely. Different elements may 
                have a different number of digits. The value of the 
                `precision` option is ignored. 
        * 'maxprec': Print at most `precision` fractional digits, but if 
                an element can be uniquely represented with fewer digits 
                only print it with that many. 
        * 'maxprec_equal': Print at most `precision` fractional digits, 
                but if every element in the array can be uniquely 
                represented with an equal number of fewer digits, use that 
                many digits for all elements. 
    legacy : string or `False`, optional 
        If set to the string `'1.13'` enables 1.13 legacy printing mode. This 
        approximates numpy 1.13 print output by including a space in the sign 
        position of floats and different behavior for 0d arrays. If set to 
        `False`, disables legacy mode. Unrecognized strings will be ignored 
        with a warning for forward compatibility. 
 
        .. versionadded:: 1.14.0 
 
    See Also 
    -------- 
    get_printoptions, printoptions, set_string_function, array2string 
 
    Notes 
    ----- 
    `formatter` is always reset with a call to `set_printoptions`. 
 
    Use `printoptions` as a context manager to set the values temporarily. 
 
    Examples 
    -------- 
    Floating point precision can be set: 
 
    &gt;&gt;&gt; np.set_printoptions(precision=4) 
    &gt;&gt;&gt; np.array([1.123456789]) 
    [1.1235] 
 
    Long arrays can be summarised: 
 
    &gt;&gt;&gt; np.set_printoptions(threshold=5) 
    &gt;&gt;&gt; np.arange(10) 
    array([0, 1, 2, ..., 7, 8, 9]) 
 
    Small results can be suppressed: 
 
    &gt;&gt;&gt; eps = np.finfo(float).eps 
    &gt;&gt;&gt; x = np.arange(4.) 
    &gt;&gt;&gt; x**2 - (x + eps)**2 
    array([-4.9304e-32, -4.4409e-16,  0.0000e+00,  0.0000e+00]) 
    &gt;&gt;&gt; np.set_printoptions(suppress=True) 
    &gt;&gt;&gt; x**2 - (x + eps)**2 
    array([-0., -0.,  0.,  0.]) 
 
    A custom formatter can be used to display array elements as desired: 
 
    &gt;&gt;&gt; np.set_printoptions(formatter={'all':lambda x: 'int: '+str(-x)}) 
    &gt;&gt;&gt; x = np.arange(3) 
    &gt;&gt;&gt; x 
    array([int: 0, int: -1, int: -2]) 
    &gt;&gt;&gt; np.set_printoptions()  # formatter gets reset 
    &gt;&gt;&gt; x 
    array([0, 1, 2]) 
 
    To put back the default options, you can use: 
 
    &gt;&gt;&gt; np.set_printoptions(edgeitems=3, infstr='inf', 
    ... linewidth=75, nanstr='nan', precision=8, 
    ... suppress=False, threshold=1000, formatter=None) 
 
    Also to temporarily override options, use `printoptions` as a context manager: 
 
    &gt;&gt;&gt; with np.printoptions(precision=2, suppress=True, threshold=5): 
    ...     np.linspace(0, 10, 10) 
    array([ 0.  ,  1.11,  2.22, ...,  7.78,  8.89, 10.  ]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">opt = _make_options_dict(precision</span><span class="s3">, </span><span class="s1">threshold</span><span class="s3">, </span><span class="s1">edgeitems</span><span class="s3">, </span><span class="s1">linewidth</span><span class="s3">,</span>
                             <span class="s1">suppress</span><span class="s3">, </span><span class="s1">nanstr</span><span class="s3">, </span><span class="s1">infstr</span><span class="s3">, </span><span class="s1">sign</span><span class="s3">, </span><span class="s1">formatter</span><span class="s3">,</span>
                             <span class="s1">floatmode</span><span class="s3">, </span><span class="s1">legacy)</span>
    <span class="s4"># formatter is always reset</span>
    <span class="s1">opt[</span><span class="s2">'formatter'</span><span class="s1">] = formatter</span>
    <span class="s1">_format_options.update(opt)</span>

    <span class="s4"># set the C variable for legacy mode</span>
    <span class="s3">if </span><span class="s1">_format_options[</span><span class="s2">'legacy'</span><span class="s1">] == </span><span class="s2">'1.13'</span><span class="s1">:</span>
        <span class="s1">set_legacy_print_mode(</span><span class="s5">113</span><span class="s1">)</span>
        <span class="s4"># reset the sign option in legacy mode to avoid confusion</span>
        <span class="s1">_format_options[</span><span class="s2">'sign'</span><span class="s1">] = </span><span class="s2">'-'</span>
    <span class="s3">elif </span><span class="s1">_format_options[</span><span class="s2">'legacy'</span><span class="s1">] </span><span class="s3">is False</span><span class="s1">:</span>
        <span class="s1">set_legacy_print_mode(</span><span class="s5">0</span><span class="s1">)</span>


<span class="s1">@set_module(</span><span class="s2">'numpy'</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">get_printoptions():</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the current print options. 
 
    Returns 
    ------- 
    print_opts : dict 
        Dictionary of current print options with keys 
 
          - precision : int 
          - threshold : int 
          - edgeitems : int 
          - linewidth : int 
          - suppress : bool 
          - nanstr : str 
          - infstr : str 
          - formatter : dict of callables 
          - sign : str 
 
        For a full description of these options, see `set_printoptions`. 
 
    See Also 
    -------- 
    set_printoptions, printoptions, set_string_function 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_format_options.copy()</span>


<span class="s1">@set_module(</span><span class="s2">'numpy'</span><span class="s1">)</span>
<span class="s1">@contextlib.contextmanager</span>
<span class="s3">def </span><span class="s1">printoptions(*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot;Context manager for setting print options. 
 
    Set print options for the scope of the `with` block, and restore the old 
    options at the end. See `set_printoptions` for the full description of 
    available options. 
 
    Examples 
    -------- 
 
    &gt;&gt;&gt; from numpy.testing import assert_equal 
    &gt;&gt;&gt; with np.printoptions(precision=2): 
    ...     np.array([2.0]) / 3 
    array([0.67]) 
 
    The `as`-clause of the `with`-statement gives the current print options: 
 
    &gt;&gt;&gt; with np.printoptions(precision=2) as opts: 
    ...      assert_equal(opts, np.get_printoptions()) 
 
    See Also 
    -------- 
    set_printoptions, get_printoptions 
 
    &quot;&quot;&quot;</span>
    <span class="s1">opts = np.get_printoptions()</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">np.set_printoptions(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s3">yield </span><span class="s1">np.get_printoptions()</span>
    <span class="s3">finally</span><span class="s1">:</span>
        <span class="s1">np.set_printoptions(**opts)</span>


<span class="s3">def </span><span class="s1">_leading_trailing(a</span><span class="s3">, </span><span class="s1">edgeitems</span><span class="s3">, </span><span class="s1">index=()):</span>
    <span class="s0">&quot;&quot;&quot; 
    Keep only the N-D corners (leading and trailing edges) of an array. 
 
    Should be passed a base-class ndarray, since it makes no guarantees about 
    preserving subclasses. 
    &quot;&quot;&quot;</span>
    <span class="s1">axis = len(index)</span>
    <span class="s3">if </span><span class="s1">axis == a.ndim:</span>
        <span class="s3">return </span><span class="s1">a[index]</span>

    <span class="s3">if </span><span class="s1">a.shape[axis] &gt; </span><span class="s5">2</span><span class="s1">*edgeitems:</span>
        <span class="s3">return </span><span class="s1">concatenate((</span>
            <span class="s1">_leading_trailing(a</span><span class="s3">, </span><span class="s1">edgeitems</span><span class="s3">, </span><span class="s1">index + np.index_exp[ :edgeitems])</span><span class="s3">,</span>
            <span class="s1">_leading_trailing(a</span><span class="s3">, </span><span class="s1">edgeitems</span><span class="s3">, </span><span class="s1">index + np.index_exp[-edgeitems:])</span>
        <span class="s1">)</span><span class="s3">, </span><span class="s1">axis=axis)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">_leading_trailing(a</span><span class="s3">, </span><span class="s1">edgeitems</span><span class="s3">, </span><span class="s1">index + np.index_exp[:])</span>


<span class="s3">def </span><span class="s1">_object_format(o):</span>
    <span class="s0">&quot;&quot;&quot; Object arrays containing lists should be printed unambiguously &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">type(o) </span><span class="s3">is </span><span class="s1">list:</span>
        <span class="s1">fmt = </span><span class="s2">'list({!r})'</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">fmt = </span><span class="s2">'{!r}'</span>
    <span class="s3">return </span><span class="s1">fmt.format(o)</span>

<span class="s3">def </span><span class="s1">repr_format(x):</span>
    <span class="s3">return </span><span class="s1">repr(x)</span>

<span class="s3">def </span><span class="s1">str_format(x):</span>
    <span class="s3">return </span><span class="s1">str(x)</span>

<span class="s3">def </span><span class="s1">_get_formatdict(data</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">precision</span><span class="s3">, </span><span class="s1">floatmode</span><span class="s3">, </span><span class="s1">suppress</span><span class="s3">, </span><span class="s1">sign</span><span class="s3">, </span><span class="s1">legacy</span><span class="s3">,</span>
                    <span class="s1">formatter</span><span class="s3">, </span><span class="s1">**kwargs):</span>
    <span class="s4"># note: extra arguments in kwargs are ignored</span>

    <span class="s4"># wrapped in lambdas to avoid taking a code path with the wrong type of data</span>
    <span class="s1">formatdict = {</span>
        <span class="s2">'bool'</span><span class="s1">: </span><span class="s3">lambda</span><span class="s1">: BoolFormat(data)</span><span class="s3">,</span>
        <span class="s2">'int'</span><span class="s1">: </span><span class="s3">lambda</span><span class="s1">: IntegerFormat(data)</span><span class="s3">,</span>
        <span class="s2">'float'</span><span class="s1">: </span><span class="s3">lambda</span><span class="s1">: FloatingFormat(</span>
            <span class="s1">data</span><span class="s3">, </span><span class="s1">precision</span><span class="s3">, </span><span class="s1">floatmode</span><span class="s3">, </span><span class="s1">suppress</span><span class="s3">, </span><span class="s1">sign</span><span class="s3">, </span><span class="s1">legacy=legacy)</span><span class="s3">,</span>
        <span class="s2">'longfloat'</span><span class="s1">: </span><span class="s3">lambda</span><span class="s1">: FloatingFormat(</span>
            <span class="s1">data</span><span class="s3">, </span><span class="s1">precision</span><span class="s3">, </span><span class="s1">floatmode</span><span class="s3">, </span><span class="s1">suppress</span><span class="s3">, </span><span class="s1">sign</span><span class="s3">, </span><span class="s1">legacy=legacy)</span><span class="s3">,</span>
        <span class="s2">'complexfloat'</span><span class="s1">: </span><span class="s3">lambda</span><span class="s1">: ComplexFloatingFormat(</span>
            <span class="s1">data</span><span class="s3">, </span><span class="s1">precision</span><span class="s3">, </span><span class="s1">floatmode</span><span class="s3">, </span><span class="s1">suppress</span><span class="s3">, </span><span class="s1">sign</span><span class="s3">, </span><span class="s1">legacy=legacy)</span><span class="s3">,</span>
        <span class="s2">'longcomplexfloat'</span><span class="s1">: </span><span class="s3">lambda</span><span class="s1">: ComplexFloatingFormat(</span>
            <span class="s1">data</span><span class="s3">, </span><span class="s1">precision</span><span class="s3">, </span><span class="s1">floatmode</span><span class="s3">, </span><span class="s1">suppress</span><span class="s3">, </span><span class="s1">sign</span><span class="s3">, </span><span class="s1">legacy=legacy)</span><span class="s3">,</span>
        <span class="s2">'datetime'</span><span class="s1">: </span><span class="s3">lambda</span><span class="s1">: DatetimeFormat(data</span><span class="s3">, </span><span class="s1">legacy=legacy)</span><span class="s3">,</span>
        <span class="s2">'timedelta'</span><span class="s1">: </span><span class="s3">lambda</span><span class="s1">: TimedeltaFormat(data)</span><span class="s3">,</span>
        <span class="s2">'object'</span><span class="s1">: </span><span class="s3">lambda</span><span class="s1">: _object_format</span><span class="s3">,</span>
        <span class="s2">'void'</span><span class="s1">: </span><span class="s3">lambda</span><span class="s1">: str_format</span><span class="s3">,</span>
        <span class="s2">'numpystr'</span><span class="s1">: </span><span class="s3">lambda</span><span class="s1">: repr_format</span><span class="s3">,</span>
        <span class="s2">'str'</span><span class="s1">: </span><span class="s3">lambda</span><span class="s1">: str}</span>

    <span class="s4"># we need to wrap values in `formatter` in a lambda, so that the interface</span>
    <span class="s4"># is the same as the above values.</span>
    <span class="s3">def </span><span class="s1">indirect(x):</span>
        <span class="s3">return lambda</span><span class="s1">: x</span>

    <span class="s3">if </span><span class="s1">formatter </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">fkeys = [k </span><span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">formatter.keys() </span><span class="s3">if </span><span class="s1">formatter[k] </span><span class="s3">is not None</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s2">'all' </span><span class="s3">in </span><span class="s1">fkeys:</span>
            <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">formatdict.keys():</span>
                <span class="s1">formatdict[key] = indirect(formatter[</span><span class="s2">'all'</span><span class="s1">])</span>
        <span class="s3">if </span><span class="s2">'int_kind' </span><span class="s3">in </span><span class="s1">fkeys:</span>
            <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">[</span><span class="s2">'int'</span><span class="s1">]:</span>
                <span class="s1">formatdict[key] = indirect(formatter[</span><span class="s2">'int_kind'</span><span class="s1">])</span>
        <span class="s3">if </span><span class="s2">'float_kind' </span><span class="s3">in </span><span class="s1">fkeys:</span>
            <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">[</span><span class="s2">'float'</span><span class="s3">, </span><span class="s2">'longfloat'</span><span class="s1">]:</span>
                <span class="s1">formatdict[key] = indirect(formatter[</span><span class="s2">'float_kind'</span><span class="s1">])</span>
        <span class="s3">if </span><span class="s2">'complex_kind' </span><span class="s3">in </span><span class="s1">fkeys:</span>
            <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">[</span><span class="s2">'complexfloat'</span><span class="s3">, </span><span class="s2">'longcomplexfloat'</span><span class="s1">]:</span>
                <span class="s1">formatdict[key] = indirect(formatter[</span><span class="s2">'complex_kind'</span><span class="s1">])</span>
        <span class="s3">if </span><span class="s2">'str_kind' </span><span class="s3">in </span><span class="s1">fkeys:</span>
            <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">[</span><span class="s2">'numpystr'</span><span class="s3">, </span><span class="s2">'str'</span><span class="s1">]:</span>
                <span class="s1">formatdict[key] = indirect(formatter[</span><span class="s2">'str_kind'</span><span class="s1">])</span>
        <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">formatdict.keys():</span>
            <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">fkeys:</span>
                <span class="s1">formatdict[key] = indirect(formatter[key])</span>

    <span class="s3">return </span><span class="s1">formatdict</span>

<span class="s3">def </span><span class="s1">_get_format_function(data</span><span class="s3">, </span><span class="s1">**options):</span>
    <span class="s0">&quot;&quot;&quot; 
    find the right formatting function for the dtype_ 
    &quot;&quot;&quot;</span>
    <span class="s1">dtype_ = data.dtype</span>
    <span class="s1">dtypeobj = dtype_.type</span>
    <span class="s1">formatdict = _get_formatdict(data</span><span class="s3">, </span><span class="s1">**options)</span>
    <span class="s3">if </span><span class="s1">issubclass(dtypeobj</span><span class="s3">, </span><span class="s1">_nt.bool_):</span>
        <span class="s3">return </span><span class="s1">formatdict[</span><span class="s2">'bool'</span><span class="s1">]()</span>
    <span class="s3">elif </span><span class="s1">issubclass(dtypeobj</span><span class="s3">, </span><span class="s1">_nt.integer):</span>
        <span class="s3">if </span><span class="s1">issubclass(dtypeobj</span><span class="s3">, </span><span class="s1">_nt.timedelta64):</span>
            <span class="s3">return </span><span class="s1">formatdict[</span><span class="s2">'timedelta'</span><span class="s1">]()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">formatdict[</span><span class="s2">'int'</span><span class="s1">]()</span>
    <span class="s3">elif </span><span class="s1">issubclass(dtypeobj</span><span class="s3">, </span><span class="s1">_nt.floating):</span>
        <span class="s3">if </span><span class="s1">issubclass(dtypeobj</span><span class="s3">, </span><span class="s1">_nt.longfloat):</span>
            <span class="s3">return </span><span class="s1">formatdict[</span><span class="s2">'longfloat'</span><span class="s1">]()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">formatdict[</span><span class="s2">'float'</span><span class="s1">]()</span>
    <span class="s3">elif </span><span class="s1">issubclass(dtypeobj</span><span class="s3">, </span><span class="s1">_nt.complexfloating):</span>
        <span class="s3">if </span><span class="s1">issubclass(dtypeobj</span><span class="s3">, </span><span class="s1">_nt.clongfloat):</span>
            <span class="s3">return </span><span class="s1">formatdict[</span><span class="s2">'longcomplexfloat'</span><span class="s1">]()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">formatdict[</span><span class="s2">'complexfloat'</span><span class="s1">]()</span>
    <span class="s3">elif </span><span class="s1">issubclass(dtypeobj</span><span class="s3">, </span><span class="s1">(_nt.unicode_</span><span class="s3">, </span><span class="s1">_nt.string_)):</span>
        <span class="s3">return </span><span class="s1">formatdict[</span><span class="s2">'numpystr'</span><span class="s1">]()</span>
    <span class="s3">elif </span><span class="s1">issubclass(dtypeobj</span><span class="s3">, </span><span class="s1">_nt.datetime64):</span>
        <span class="s3">return </span><span class="s1">formatdict[</span><span class="s2">'datetime'</span><span class="s1">]()</span>
    <span class="s3">elif </span><span class="s1">issubclass(dtypeobj</span><span class="s3">, </span><span class="s1">_nt.object_):</span>
        <span class="s3">return </span><span class="s1">formatdict[</span><span class="s2">'object'</span><span class="s1">]()</span>
    <span class="s3">elif </span><span class="s1">issubclass(dtypeobj</span><span class="s3">, </span><span class="s1">_nt.void):</span>
        <span class="s3">if </span><span class="s1">dtype_.names </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">StructuredVoidFormat.from_data(data</span><span class="s3">, </span><span class="s1">**options)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">formatdict[</span><span class="s2">'void'</span><span class="s1">]()</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">formatdict[</span><span class="s2">'numpystr'</span><span class="s1">]()</span>


<span class="s3">def </span><span class="s1">_recursive_guard(fillvalue=</span><span class="s2">'...'</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Like the python 3.2 reprlib.recursive_repr, but forwards *args and **kwargs 
 
    Decorates a function such that if it calls itself with the same first 
    argument, it returns `fillvalue` instead of recursing. 
 
    Largely copied from reprlib.recursive_repr 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">decorating_function(f):</span>
        <span class="s1">repr_running = set()</span>

        <span class="s1">@functools.wraps(f)</span>
        <span class="s3">def </span><span class="s1">wrapper(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
            <span class="s1">key = id(self)</span><span class="s3">, </span><span class="s1">get_ident()</span>
            <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">repr_running:</span>
                <span class="s3">return </span><span class="s1">fillvalue</span>
            <span class="s1">repr_running.add(key)</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">f(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
            <span class="s3">finally</span><span class="s1">:</span>
                <span class="s1">repr_running.discard(key)</span>

        <span class="s3">return </span><span class="s1">wrapper</span>

    <span class="s3">return </span><span class="s1">decorating_function</span>


<span class="s4"># gracefully handle recursive calls, when object arrays contain themselves</span>
<span class="s1">@_recursive_guard()</span>
<span class="s3">def </span><span class="s1">_array2string(a</span><span class="s3">, </span><span class="s1">options</span><span class="s3">, </span><span class="s1">separator=</span><span class="s2">' '</span><span class="s3">, </span><span class="s1">prefix=</span><span class="s2">&quot;&quot;</span><span class="s1">):</span>
    <span class="s4"># The formatter __init__s in _get_format_function cannot deal with</span>
    <span class="s4"># subclasses yet, and we also need to avoid recursion issues in</span>
    <span class="s4"># _formatArray with subclasses which return 0d arrays in place of scalars</span>
    <span class="s1">data = asarray(a)</span>
    <span class="s3">if </span><span class="s1">a.shape == ():</span>
        <span class="s1">a = data</span>

    <span class="s3">if </span><span class="s1">a.size &gt; options[</span><span class="s2">'threshold'</span><span class="s1">]:</span>
        <span class="s1">summary_insert = </span><span class="s2">&quot;...&quot;</span>
        <span class="s1">data = _leading_trailing(data</span><span class="s3">, </span><span class="s1">options[</span><span class="s2">'edgeitems'</span><span class="s1">])</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">summary_insert = </span><span class="s2">&quot;&quot;</span>

    <span class="s4"># find the right formatting function for the array</span>
    <span class="s1">format_function = _get_format_function(data</span><span class="s3">, </span><span class="s1">**options)</span>

    <span class="s4"># skip over &quot;[&quot;</span>
    <span class="s1">next_line_prefix = </span><span class="s2">&quot; &quot;</span>
    <span class="s4"># skip over array(</span>
    <span class="s1">next_line_prefix += </span><span class="s2">&quot; &quot;</span><span class="s1">*len(prefix)</span>

    <span class="s1">lst = _formatArray(a</span><span class="s3">, </span><span class="s1">format_function</span><span class="s3">, </span><span class="s1">options[</span><span class="s2">'linewidth'</span><span class="s1">]</span><span class="s3">,</span>
                       <span class="s1">next_line_prefix</span><span class="s3">, </span><span class="s1">separator</span><span class="s3">, </span><span class="s1">options[</span><span class="s2">'edgeitems'</span><span class="s1">]</span><span class="s3">,</span>
                       <span class="s1">summary_insert</span><span class="s3">, </span><span class="s1">options[</span><span class="s2">'legacy'</span><span class="s1">])</span>
    <span class="s3">return </span><span class="s1">lst</span>


<span class="s3">def </span><span class="s1">_array2string_dispatcher(</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">max_line_width=</span><span class="s3">None, </span><span class="s1">precision=</span><span class="s3">None,</span>
        <span class="s1">suppress_small=</span><span class="s3">None, </span><span class="s1">separator=</span><span class="s3">None, </span><span class="s1">prefix=</span><span class="s3">None,</span>
        <span class="s1">style=</span><span class="s3">None, </span><span class="s1">formatter=</span><span class="s3">None, </span><span class="s1">threshold=</span><span class="s3">None,</span>
        <span class="s1">edgeitems=</span><span class="s3">None, </span><span class="s1">sign=</span><span class="s3">None, </span><span class="s1">floatmode=</span><span class="s3">None, </span><span class="s1">suffix=</span><span class="s3">None,</span>
        <span class="s1">*</span><span class="s3">, </span><span class="s1">legacy=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s3">return </span><span class="s1">(a</span><span class="s3">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_array2string_dispatcher</span><span class="s3">, </span><span class="s1">module=</span><span class="s2">'numpy'</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">array2string(a</span><span class="s3">, </span><span class="s1">max_line_width=</span><span class="s3">None, </span><span class="s1">precision=</span><span class="s3">None,</span>
                 <span class="s1">suppress_small=</span><span class="s3">None, </span><span class="s1">separator=</span><span class="s2">' '</span><span class="s3">, </span><span class="s1">prefix=</span><span class="s2">&quot;&quot;</span><span class="s3">,</span>
                 <span class="s1">style=np._NoValue</span><span class="s3">, </span><span class="s1">formatter=</span><span class="s3">None, </span><span class="s1">threshold=</span><span class="s3">None,</span>
                 <span class="s1">edgeitems=</span><span class="s3">None, </span><span class="s1">sign=</span><span class="s3">None, </span><span class="s1">floatmode=</span><span class="s3">None, </span><span class="s1">suffix=</span><span class="s2">&quot;&quot;</span><span class="s3">,</span>
                 <span class="s1">*</span><span class="s3">, </span><span class="s1">legacy=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a string representation of an array. 
 
    Parameters 
    ---------- 
    a : array_like 
        Input array. 
    max_line_width : int, optional 
        Inserts newlines if text is longer than `max_line_width`. 
        Defaults to ``numpy.get_printoptions()['linewidth']``. 
    precision : int or None, optional 
        Floating point precision. 
        Defaults to ``numpy.get_printoptions()['precision']``. 
    suppress_small : bool, optional 
        Represent numbers &quot;very close&quot; to zero as zero; default is False. 
        Very close is defined by precision: if the precision is 8, e.g., 
        numbers smaller (in absolute value) than 5e-9 are represented as 
        zero. 
        Defaults to ``numpy.get_printoptions()['suppress']``. 
    separator : str, optional 
        Inserted between elements. 
    prefix : str, optional 
    suffix: str, optional 
        The length of the prefix and suffix strings are used to respectively 
        align and wrap the output. An array is typically printed as:: 
 
          prefix + array2string(a) + suffix 
 
        The output is left-padded by the length of the prefix string, and 
        wrapping is forced at the column ``max_line_width - len(suffix)``. 
        It should be noted that the content of prefix and suffix strings are 
        not included in the output. 
    style : _NoValue, optional 
        Has no effect, do not use. 
 
        .. deprecated:: 1.14.0 
    formatter : dict of callables, optional 
        If not None, the keys should indicate the type(s) that the respective 
        formatting function applies to.  Callables should return a string. 
        Types that are not specified (by their corresponding keys) are handled 
        by the default formatters.  Individual types for which a formatter 
        can be set are: 
 
        - 'bool' 
        - 'int' 
        - 'timedelta' : a `numpy.timedelta64` 
        - 'datetime' : a `numpy.datetime64` 
        - 'float' 
        - 'longfloat' : 128-bit floats 
        - 'complexfloat' 
        - 'longcomplexfloat' : composed of two 128-bit floats 
        - 'void' : type `numpy.void` 
        - 'numpystr' : types `numpy.string_` and `numpy.unicode_` 
        - 'str' : all other strings 
 
        Other keys that can be used to set a group of types at once are: 
 
        - 'all' : sets all types 
        - 'int_kind' : sets 'int' 
        - 'float_kind' : sets 'float' and 'longfloat' 
        - 'complex_kind' : sets 'complexfloat' and 'longcomplexfloat' 
        - 'str_kind' : sets 'str' and 'numpystr' 
    threshold : int, optional 
        Total number of array elements which trigger summarization 
        rather than full repr. 
        Defaults to ``numpy.get_printoptions()['threshold']``. 
    edgeitems : int, optional 
        Number of array items in summary at beginning and end of 
        each dimension. 
        Defaults to ``numpy.get_printoptions()['edgeitems']``. 
    sign : string, either '-', '+', or ' ', optional 
        Controls printing of the sign of floating-point types. If '+', always 
        print the sign of positive values. If ' ', always prints a space 
        (whitespace character) in the sign position of positive values.  If 
        '-', omit the sign character of positive values. 
        Defaults to ``numpy.get_printoptions()['sign']``. 
    floatmode : str, optional 
        Controls the interpretation of the `precision` option for 
        floating-point types. 
        Defaults to ``numpy.get_printoptions()['floatmode']``. 
        Can take the following values: 
 
        - 'fixed': Always print exactly `precision` fractional digits, 
          even if this would print more or fewer digits than 
          necessary to specify the value uniquely. 
        - 'unique': Print the minimum number of fractional digits necessary 
          to represent each value uniquely. Different elements may 
          have a different number of digits.  The value of the 
          `precision` option is ignored. 
        - 'maxprec': Print at most `precision` fractional digits, but if 
          an element can be uniquely represented with fewer digits 
          only print it with that many. 
        - 'maxprec_equal': Print at most `precision` fractional digits, 
          but if every element in the array can be uniquely 
          represented with an equal number of fewer digits, use that 
          many digits for all elements. 
    legacy : string or `False`, optional 
        If set to the string `'1.13'` enables 1.13 legacy printing mode. This 
        approximates numpy 1.13 print output by including a space in the sign 
        position of floats and different behavior for 0d arrays. If set to 
        `False`, disables legacy mode. Unrecognized strings will be ignored 
        with a warning for forward compatibility. 
 
        .. versionadded:: 1.14.0 
 
    Returns 
    ------- 
    array_str : str 
        String representation of the array. 
 
    Raises 
    ------ 
    TypeError 
        if a callable in `formatter` does not return a string. 
 
    See Also 
    -------- 
    array_str, array_repr, set_printoptions, get_printoptions 
 
    Notes 
    ----- 
    If a formatter is specified for a certain type, the `precision` keyword is 
    ignored for that type. 
 
    This is a very flexible function; `array_repr` and `array_str` are using 
    `array2string` internally so keywords with the same name should work 
    identically in all three functions. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; x = np.array([1e-16,1,2,3]) 
    &gt;&gt;&gt; np.array2string(x, precision=2, separator=',', 
    ...                       suppress_small=True) 
    '[0.,1.,2.,3.]' 
 
    &gt;&gt;&gt; x  = np.arange(3.) 
    &gt;&gt;&gt; np.array2string(x, formatter={'float_kind':lambda x: &quot;%.2f&quot; % x}) 
    '[0.00 1.00 2.00]' 
 
    &gt;&gt;&gt; x  = np.arange(3) 
    &gt;&gt;&gt; np.array2string(x, formatter={'int':lambda x: hex(x)}) 
    '[0x0 0x1 0x2]' 
 
    &quot;&quot;&quot;</span>

    <span class="s1">overrides = _make_options_dict(precision</span><span class="s3">, </span><span class="s1">threshold</span><span class="s3">, </span><span class="s1">edgeitems</span><span class="s3">,</span>
                                   <span class="s1">max_line_width</span><span class="s3">, </span><span class="s1">suppress_small</span><span class="s3">, None, None,</span>
                                   <span class="s1">sign</span><span class="s3">, </span><span class="s1">formatter</span><span class="s3">, </span><span class="s1">floatmode</span><span class="s3">, </span><span class="s1">legacy)</span>
    <span class="s1">options = _format_options.copy()</span>
    <span class="s1">options.update(overrides)</span>

    <span class="s3">if </span><span class="s1">options[</span><span class="s2">'legacy'</span><span class="s1">] == </span><span class="s2">'1.13'</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">style </span><span class="s3">is </span><span class="s1">np._NoValue:</span>
            <span class="s1">style = repr</span>

        <span class="s3">if </span><span class="s1">a.shape == () </span><span class="s3">and </span><span class="s1">a.dtype.names </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">style(a.item())</span>
    <span class="s3">elif </span><span class="s1">style </span><span class="s3">is not </span><span class="s1">np._NoValue:</span>
        <span class="s4"># Deprecation 11-9-2017  v1.14</span>
        <span class="s1">warnings.warn(</span><span class="s2">&quot;'style' argument is deprecated and no longer functional&quot;</span>
                      <span class="s2">&quot; except in 1.13 'legacy' mode&quot;</span><span class="s3">,</span>
                      <span class="s1">DeprecationWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">3</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">options[</span><span class="s2">'legacy'</span><span class="s1">] != </span><span class="s2">'1.13'</span><span class="s1">:</span>
        <span class="s1">options[</span><span class="s2">'linewidth'</span><span class="s1">] -= len(suffix)</span>

    <span class="s4"># treat as a null array if any of shape elements == 0</span>
    <span class="s3">if </span><span class="s1">a.size == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s2">&quot;[]&quot;</span>

    <span class="s3">return </span><span class="s1">_array2string(a</span><span class="s3">, </span><span class="s1">options</span><span class="s3">, </span><span class="s1">separator</span><span class="s3">, </span><span class="s1">prefix)</span>


<span class="s3">def </span><span class="s1">_extendLine(s</span><span class="s3">, </span><span class="s1">line</span><span class="s3">, </span><span class="s1">word</span><span class="s3">, </span><span class="s1">line_width</span><span class="s3">, </span><span class="s1">next_line_prefix</span><span class="s3">, </span><span class="s1">legacy):</span>
    <span class="s1">needs_wrap = len(line) + len(word) &gt; line_width</span>
    <span class="s3">if </span><span class="s1">legacy != </span><span class="s2">'1.13'</span><span class="s1">:</span>
        <span class="s4"># don't wrap lines if it won't help</span>
        <span class="s3">if </span><span class="s1">len(line) &lt;= len(next_line_prefix):</span>
            <span class="s1">needs_wrap = </span><span class="s3">False</span>

    <span class="s3">if </span><span class="s1">needs_wrap:</span>
        <span class="s1">s += line.rstrip() + </span><span class="s2">&quot;</span><span class="s3">\n</span><span class="s2">&quot;</span>
        <span class="s1">line = next_line_prefix</span>
    <span class="s1">line += word</span>
    <span class="s3">return </span><span class="s1">s</span><span class="s3">, </span><span class="s1">line</span>


<span class="s3">def </span><span class="s1">_extendLine_pretty(s</span><span class="s3">, </span><span class="s1">line</span><span class="s3">, </span><span class="s1">word</span><span class="s3">, </span><span class="s1">line_width</span><span class="s3">, </span><span class="s1">next_line_prefix</span><span class="s3">, </span><span class="s1">legacy):</span>
    <span class="s0">&quot;&quot;&quot; 
    Extends line with nicely formatted (possibly multi-line) string ``word``. 
    &quot;&quot;&quot;</span>
    <span class="s1">words = word.splitlines()</span>
    <span class="s3">if </span><span class="s1">len(words) == </span><span class="s5">1 </span><span class="s3">or </span><span class="s1">legacy == </span><span class="s2">'1.13'</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">_extendLine(s</span><span class="s3">, </span><span class="s1">line</span><span class="s3">, </span><span class="s1">word</span><span class="s3">, </span><span class="s1">line_width</span><span class="s3">, </span><span class="s1">next_line_prefix</span><span class="s3">, </span><span class="s1">legacy)</span>

    <span class="s1">max_word_length = max(len(word) </span><span class="s3">for </span><span class="s1">word </span><span class="s3">in </span><span class="s1">words)</span>
    <span class="s3">if </span><span class="s1">(len(line) + max_word_length &gt; line_width </span><span class="s3">and</span>
            <span class="s1">len(line) &gt; len(next_line_prefix)):</span>
        <span class="s1">s += line.rstrip() + </span><span class="s2">'</span><span class="s3">\n</span><span class="s2">'</span>
        <span class="s1">line = next_line_prefix + words[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">indent = next_line_prefix</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">indent = len(line)*</span><span class="s2">' '</span>
        <span class="s1">line += words[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s3">for </span><span class="s1">word </span><span class="s3">in </span><span class="s1">words[</span><span class="s5">1</span><span class="s1">::]:</span>
        <span class="s1">s += line.rstrip() + </span><span class="s2">'</span><span class="s3">\n</span><span class="s2">'</span>
        <span class="s1">line = indent + word</span>

    <span class="s1">suffix_length = max_word_length - len(words[-</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">line += suffix_length*</span><span class="s2">' '</span>

    <span class="s3">return </span><span class="s1">s</span><span class="s3">, </span><span class="s1">line</span>

<span class="s3">def </span><span class="s1">_formatArray(a</span><span class="s3">, </span><span class="s1">format_function</span><span class="s3">, </span><span class="s1">line_width</span><span class="s3">, </span><span class="s1">next_line_prefix</span><span class="s3">,</span>
                 <span class="s1">separator</span><span class="s3">, </span><span class="s1">edge_items</span><span class="s3">, </span><span class="s1">summary_insert</span><span class="s3">, </span><span class="s1">legacy):</span>
    <span class="s0">&quot;&quot;&quot;formatArray is designed for two modes of operation: 
 
    1. Full output 
 
    2. Summarized output 
 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">recurser(index</span><span class="s3">, </span><span class="s1">hanging_indent</span><span class="s3">, </span><span class="s1">curr_width):</span>
        <span class="s0">&quot;&quot;&quot; 
        By using this local function, we don't need to recurse with all the 
        arguments. Since this function is not created recursively, the cost is 
        not significant 
        &quot;&quot;&quot;</span>
        <span class="s1">axis = len(index)</span>
        <span class="s1">axes_left = a.ndim - axis</span>

        <span class="s3">if </span><span class="s1">axes_left == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">format_function(a[index])</span>

        <span class="s4"># when recursing, add a space to align with the [ added, and reduce the</span>
        <span class="s4"># length of the line by 1</span>
        <span class="s1">next_hanging_indent = hanging_indent + </span><span class="s2">' '</span>
        <span class="s3">if </span><span class="s1">legacy == </span><span class="s2">'1.13'</span><span class="s1">:</span>
            <span class="s1">next_width = curr_width</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">next_width = curr_width - len(</span><span class="s2">']'</span><span class="s1">)</span>

        <span class="s1">a_len = a.shape[axis]</span>
        <span class="s1">show_summary = summary_insert </span><span class="s3">and </span><span class="s5">2</span><span class="s1">*edge_items &lt; a_len</span>
        <span class="s3">if </span><span class="s1">show_summary:</span>
            <span class="s1">leading_items = edge_items</span>
            <span class="s1">trailing_items = edge_items</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">leading_items = </span><span class="s5">0</span>
            <span class="s1">trailing_items = a_len</span>

        <span class="s4"># stringify the array with the hanging indent on the first line too</span>
        <span class="s1">s = </span><span class="s2">''</span>

        <span class="s4"># last axis (rows) - wrap elements if they would not fit on one line</span>
        <span class="s3">if </span><span class="s1">axes_left == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4"># the length up until the beginning of the separator / bracket</span>
            <span class="s3">if </span><span class="s1">legacy == </span><span class="s2">'1.13'</span><span class="s1">:</span>
                <span class="s1">elem_width = curr_width - len(separator.rstrip())</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">elem_width = curr_width - max(len(separator.rstrip())</span><span class="s3">, </span><span class="s1">len(</span><span class="s2">']'</span><span class="s1">))</span>

            <span class="s1">line = hanging_indent</span>
            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(leading_items):</span>
                <span class="s1">word = recurser(index + (i</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">next_hanging_indent</span><span class="s3">, </span><span class="s1">next_width)</span>
                <span class="s1">s</span><span class="s3">, </span><span class="s1">line = _extendLine_pretty(</span>
                    <span class="s1">s</span><span class="s3">, </span><span class="s1">line</span><span class="s3">, </span><span class="s1">word</span><span class="s3">, </span><span class="s1">elem_width</span><span class="s3">, </span><span class="s1">hanging_indent</span><span class="s3">, </span><span class="s1">legacy)</span>
                <span class="s1">line += separator</span>

            <span class="s3">if </span><span class="s1">show_summary:</span>
                <span class="s1">s</span><span class="s3">, </span><span class="s1">line = _extendLine(</span>
                    <span class="s1">s</span><span class="s3">, </span><span class="s1">line</span><span class="s3">, </span><span class="s1">summary_insert</span><span class="s3">, </span><span class="s1">elem_width</span><span class="s3">, </span><span class="s1">hanging_indent</span><span class="s3">, </span><span class="s1">legacy)</span>
                <span class="s3">if </span><span class="s1">legacy == </span><span class="s2">'1.13'</span><span class="s1">:</span>
                    <span class="s1">line += </span><span class="s2">&quot;, &quot;</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">line += separator</span>

            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(trailing_items</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">):</span>
                <span class="s1">word = recurser(index + (-i</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">next_hanging_indent</span><span class="s3">, </span><span class="s1">next_width)</span>
                <span class="s1">s</span><span class="s3">, </span><span class="s1">line = _extendLine_pretty(</span>
                    <span class="s1">s</span><span class="s3">, </span><span class="s1">line</span><span class="s3">, </span><span class="s1">word</span><span class="s3">, </span><span class="s1">elem_width</span><span class="s3">, </span><span class="s1">hanging_indent</span><span class="s3">, </span><span class="s1">legacy)</span>
                <span class="s1">line += separator</span>

            <span class="s3">if </span><span class="s1">legacy == </span><span class="s2">'1.13'</span><span class="s1">:</span>
                <span class="s4"># width of the separator is not considered on 1.13</span>
                <span class="s1">elem_width = curr_width</span>
            <span class="s1">word = recurser(index + (-</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">next_hanging_indent</span><span class="s3">, </span><span class="s1">next_width)</span>
            <span class="s1">s</span><span class="s3">, </span><span class="s1">line = _extendLine_pretty(</span>
                <span class="s1">s</span><span class="s3">, </span><span class="s1">line</span><span class="s3">, </span><span class="s1">word</span><span class="s3">, </span><span class="s1">elem_width</span><span class="s3">, </span><span class="s1">hanging_indent</span><span class="s3">, </span><span class="s1">legacy)</span>

            <span class="s1">s += line</span>

        <span class="s4"># other axes - insert newlines between rows</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">s = </span><span class="s2">''</span>
            <span class="s1">line_sep = separator.rstrip() + </span><span class="s2">'</span><span class="s3">\n</span><span class="s2">'</span><span class="s1">*(axes_left - </span><span class="s5">1</span><span class="s1">)</span>

            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(leading_items):</span>
                <span class="s1">nested = recurser(index + (i</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">next_hanging_indent</span><span class="s3">, </span><span class="s1">next_width)</span>
                <span class="s1">s += hanging_indent + nested + line_sep</span>

            <span class="s3">if </span><span class="s1">show_summary:</span>
                <span class="s3">if </span><span class="s1">legacy == </span><span class="s2">'1.13'</span><span class="s1">:</span>
                    <span class="s4"># trailing space, fixed nbr of newlines, and fixed separator</span>
                    <span class="s1">s += hanging_indent + summary_insert + </span><span class="s2">&quot;, </span><span class="s3">\n</span><span class="s2">&quot;</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">s += hanging_indent + summary_insert + line_sep</span>

            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(trailing_items</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">):</span>
                <span class="s1">nested = recurser(index + (-i</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">next_hanging_indent</span><span class="s3">,</span>
                                  <span class="s1">next_width)</span>
                <span class="s1">s += hanging_indent + nested + line_sep</span>

            <span class="s1">nested = recurser(index + (-</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">next_hanging_indent</span><span class="s3">, </span><span class="s1">next_width)</span>
            <span class="s1">s += hanging_indent + nested</span>

        <span class="s4"># remove the hanging indent, and wrap in []</span>
        <span class="s1">s = </span><span class="s2">'[' </span><span class="s1">+ s[len(hanging_indent):] + </span><span class="s2">']'</span>
        <span class="s3">return </span><span class="s1">s</span>

    <span class="s3">try</span><span class="s1">:</span>
        <span class="s4"># invoke the recursive part with an initial index and prefix</span>
        <span class="s3">return </span><span class="s1">recurser(index=()</span><span class="s3">,</span>
                        <span class="s1">hanging_indent=next_line_prefix</span><span class="s3">,</span>
                        <span class="s1">curr_width=line_width)</span>
    <span class="s3">finally</span><span class="s1">:</span>
        <span class="s4"># recursive closures have a cyclic reference to themselves, which</span>
        <span class="s4"># requires gc to collect (gh-10620). To avoid this problem, for</span>
        <span class="s4"># performance and PyPy friendliness, we break the cycle:</span>
        <span class="s1">recurser = </span><span class="s3">None</span>

<span class="s3">def </span><span class="s1">_none_or_positive_arg(x</span><span class="s3">, </span><span class="s1">name):</span>
    <span class="s3">if </span><span class="s1">x </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">-</span><span class="s5">1</span>
    <span class="s3">if </span><span class="s1">x &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;{} must be &gt;= 0&quot;</span><span class="s1">.format(name))</span>
    <span class="s3">return </span><span class="s1">x</span>

<span class="s3">class </span><span class="s1">FloatingFormat:</span>
    <span class="s0">&quot;&quot;&quot; Formatter for subtypes of np.floating &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">precision</span><span class="s3">, </span><span class="s1">floatmode</span><span class="s3">, </span><span class="s1">suppress_small</span><span class="s3">, </span><span class="s1">sign=</span><span class="s3">False,</span>
                 <span class="s1">*</span><span class="s3">, </span><span class="s1">legacy=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s4"># for backcompatibility, accept bools</span>
        <span class="s3">if </span><span class="s1">isinstance(sign</span><span class="s3">, </span><span class="s1">bool):</span>
            <span class="s1">sign = </span><span class="s2">'+' </span><span class="s3">if </span><span class="s1">sign </span><span class="s3">else </span><span class="s2">'-'</span>

        <span class="s1">self._legacy = legacy</span>
        <span class="s3">if </span><span class="s1">self._legacy == </span><span class="s2">'1.13'</span><span class="s1">:</span>
            <span class="s4"># when not 0d, legacy does not support '-'</span>
            <span class="s3">if </span><span class="s1">data.shape != () </span><span class="s3">and </span><span class="s1">sign == </span><span class="s2">'-'</span><span class="s1">:</span>
                <span class="s1">sign = </span><span class="s2">' '</span>

        <span class="s1">self.floatmode = floatmode</span>
        <span class="s3">if </span><span class="s1">floatmode == </span><span class="s2">'unique'</span><span class="s1">:</span>
            <span class="s1">self.precision = </span><span class="s3">None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.precision = precision</span>

        <span class="s1">self.precision = _none_or_positive_arg(self.precision</span><span class="s3">, </span><span class="s2">'precision'</span><span class="s1">)</span>

        <span class="s1">self.suppress_small = suppress_small</span>
        <span class="s1">self.sign = sign</span>
        <span class="s1">self.exp_format = </span><span class="s3">False</span>
        <span class="s1">self.large_exponent = </span><span class="s3">False</span>

        <span class="s1">self.fillFormat(data)</span>

    <span class="s3">def </span><span class="s1">fillFormat(self</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s4"># only the finite values are used to compute the number of digits</span>
        <span class="s1">finite_vals = data[isfinite(data)]</span>

        <span class="s4"># choose exponential mode based on the non-zero finite values:</span>
        <span class="s1">abs_non_zero = absolute(finite_vals[finite_vals != </span><span class="s5">0</span><span class="s1">])</span>
        <span class="s3">if </span><span class="s1">len(abs_non_zero) != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">max_val = np.max(abs_non_zero)</span>
            <span class="s1">min_val = np.min(abs_non_zero)</span>
            <span class="s3">with </span><span class="s1">errstate(over=</span><span class="s2">'ignore'</span><span class="s1">):  </span><span class="s4"># division can overflow</span>
                <span class="s3">if </span><span class="s1">max_val &gt;= </span><span class="s5">1.e8 </span><span class="s3">or </span><span class="s1">(</span><span class="s3">not </span><span class="s1">self.suppress_small </span><span class="s3">and</span>
                        <span class="s1">(min_val &lt; </span><span class="s5">0.0001 </span><span class="s3">or </span><span class="s1">max_val/min_val &gt; </span><span class="s5">1000.</span><span class="s1">)):</span>
                    <span class="s1">self.exp_format = </span><span class="s3">True</span>

        <span class="s4"># do a first pass of printing all the numbers, to determine sizes</span>
        <span class="s3">if </span><span class="s1">len(finite_vals) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">self.pad_left = </span><span class="s5">0</span>
            <span class="s1">self.pad_right = </span><span class="s5">0</span>
            <span class="s1">self.trim = </span><span class="s2">'.'</span>
            <span class="s1">self.exp_size = -</span><span class="s5">1</span>
            <span class="s1">self.unique = </span><span class="s3">True</span>
        <span class="s3">elif </span><span class="s1">self.exp_format:</span>
            <span class="s1">trim</span><span class="s3">, </span><span class="s1">unique = </span><span class="s2">'.'</span><span class="s3">, True</span>
            <span class="s3">if </span><span class="s1">self.floatmode == </span><span class="s2">'fixed' </span><span class="s3">or </span><span class="s1">self._legacy == </span><span class="s2">'1.13'</span><span class="s1">:</span>
                <span class="s1">trim</span><span class="s3">, </span><span class="s1">unique = </span><span class="s2">'k'</span><span class="s3">, False</span>
            <span class="s1">strs = (dragon4_scientific(x</span><span class="s3">, </span><span class="s1">precision=self.precision</span><span class="s3">,</span>
                               <span class="s1">unique=unique</span><span class="s3">, </span><span class="s1">trim=trim</span><span class="s3">, </span><span class="s1">sign=self.sign == </span><span class="s2">'+'</span><span class="s1">)</span>
                    <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">finite_vals)</span>
            <span class="s1">frac_strs</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">exp_strs = zip(*(s.partition(</span><span class="s2">'e'</span><span class="s1">) </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">strs))</span>
            <span class="s1">int_part</span><span class="s3">, </span><span class="s1">frac_part = zip(*(s.split(</span><span class="s2">'.'</span><span class="s1">) </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">frac_strs))</span>
            <span class="s1">self.exp_size = max(len(s) </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">exp_strs) - </span><span class="s5">1</span>

            <span class="s1">self.trim = </span><span class="s2">'k'</span>
            <span class="s1">self.precision = max(len(s) </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">frac_part)</span>

            <span class="s4"># for back-compat with np 1.13, use 2 spaces &amp; sign and full prec</span>
            <span class="s3">if </span><span class="s1">self._legacy == </span><span class="s2">'1.13'</span><span class="s1">:</span>
                <span class="s1">self.pad_left = </span><span class="s5">3</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s4"># this should be only 1 or 2. Can be calculated from sign.</span>
                <span class="s1">self.pad_left = max(len(s) </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">int_part)</span>
            <span class="s4"># pad_right is only needed for nan length calculation</span>
            <span class="s1">self.pad_right = self.exp_size + </span><span class="s5">2 </span><span class="s1">+ self.precision</span>

            <span class="s1">self.unique = </span><span class="s3">False</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s4"># first pass printing to determine sizes</span>
            <span class="s1">trim</span><span class="s3">, </span><span class="s1">unique = </span><span class="s2">'.'</span><span class="s3">, True</span>
            <span class="s3">if </span><span class="s1">self.floatmode == </span><span class="s2">'fixed'</span><span class="s1">:</span>
                <span class="s1">trim</span><span class="s3">, </span><span class="s1">unique = </span><span class="s2">'k'</span><span class="s3">, False</span>
            <span class="s1">strs = (dragon4_positional(x</span><span class="s3">, </span><span class="s1">precision=self.precision</span><span class="s3">,</span>
                                       <span class="s1">fractional=</span><span class="s3">True,</span>
                                       <span class="s1">unique=unique</span><span class="s3">, </span><span class="s1">trim=trim</span><span class="s3">,</span>
                                       <span class="s1">sign=self.sign == </span><span class="s2">'+'</span><span class="s1">)</span>
                    <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">finite_vals)</span>
            <span class="s1">int_part</span><span class="s3">, </span><span class="s1">frac_part = zip(*(s.split(</span><span class="s2">'.'</span><span class="s1">) </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">strs))</span>
            <span class="s3">if </span><span class="s1">self._legacy == </span><span class="s2">'1.13'</span><span class="s1">:</span>
                <span class="s1">self.pad_left = </span><span class="s5">1 </span><span class="s1">+ max(len(s.lstrip(</span><span class="s2">'-+'</span><span class="s1">)) </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">int_part)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self.pad_left = max(len(s) </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">int_part)</span>
            <span class="s1">self.pad_right = max(len(s) </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">frac_part)</span>
            <span class="s1">self.exp_size = -</span><span class="s5">1</span>

            <span class="s3">if </span><span class="s1">self.floatmode </span><span class="s3">in </span><span class="s1">[</span><span class="s2">'fixed'</span><span class="s3">, </span><span class="s2">'maxprec_equal'</span><span class="s1">]:</span>
                <span class="s1">self.precision = self.pad_right</span>
                <span class="s1">self.unique = </span><span class="s3">False</span>
                <span class="s1">self.trim = </span><span class="s2">'k'</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self.unique = </span><span class="s3">True</span>
                <span class="s1">self.trim = </span><span class="s2">'.'</span>

        <span class="s3">if </span><span class="s1">self._legacy != </span><span class="s2">'1.13'</span><span class="s1">:</span>
            <span class="s4"># account for sign = ' ' by adding one to pad_left</span>
            <span class="s3">if </span><span class="s1">self.sign == </span><span class="s2">' ' </span><span class="s3">and not </span><span class="s1">any(np.signbit(finite_vals)):</span>
                <span class="s1">self.pad_left += </span><span class="s5">1</span>

        <span class="s4"># if there are non-finite values, may need to increase pad_left</span>
        <span class="s3">if </span><span class="s1">data.size != finite_vals.size:</span>
            <span class="s1">neginf = self.sign != </span><span class="s2">'-' </span><span class="s3">or </span><span class="s1">any(data[isinf(data)] &lt; </span><span class="s5">0</span><span class="s1">)</span>
            <span class="s1">nanlen = len(_format_options[</span><span class="s2">'nanstr'</span><span class="s1">])</span>
            <span class="s1">inflen = len(_format_options[</span><span class="s2">'infstr'</span><span class="s1">]) + neginf</span>
            <span class="s1">offset = self.pad_right + </span><span class="s5">1  </span><span class="s4"># +1 for decimal pt</span>
            <span class="s1">self.pad_left = max(self.pad_left</span><span class="s3">, </span><span class="s1">nanlen - offset</span><span class="s3">, </span><span class="s1">inflen - offset)</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s3">if not </span><span class="s1">np.isfinite(x):</span>
            <span class="s3">with </span><span class="s1">errstate(invalid=</span><span class="s2">'ignore'</span><span class="s1">):</span>
                <span class="s3">if </span><span class="s1">np.isnan(x):</span>
                    <span class="s1">sign = </span><span class="s2">'+' </span><span class="s3">if </span><span class="s1">self.sign == </span><span class="s2">'+' </span><span class="s3">else </span><span class="s2">''</span>
                    <span class="s1">ret = sign + _format_options[</span><span class="s2">'nanstr'</span><span class="s1">]</span>
                <span class="s3">else</span><span class="s1">:  </span><span class="s4"># isinf</span>
                    <span class="s1">sign = </span><span class="s2">'-' </span><span class="s3">if </span><span class="s1">x &lt; </span><span class="s5">0 </span><span class="s3">else </span><span class="s2">'+' </span><span class="s3">if </span><span class="s1">self.sign == </span><span class="s2">'+' </span><span class="s3">else </span><span class="s2">''</span>
                    <span class="s1">ret = sign + _format_options[</span><span class="s2">'infstr'</span><span class="s1">]</span>
                <span class="s3">return </span><span class="s2">' '</span><span class="s1">*(self.pad_left + self.pad_right + </span><span class="s5">1 </span><span class="s1">- len(ret)) + ret</span>

        <span class="s3">if </span><span class="s1">self.exp_format:</span>
            <span class="s3">return </span><span class="s1">dragon4_scientific(x</span><span class="s3">,</span>
                                      <span class="s1">precision=self.precision</span><span class="s3">,</span>
                                      <span class="s1">unique=self.unique</span><span class="s3">,</span>
                                      <span class="s1">trim=self.trim</span><span class="s3">,</span>
                                      <span class="s1">sign=self.sign == </span><span class="s2">'+'</span><span class="s3">,</span>
                                      <span class="s1">pad_left=self.pad_left</span><span class="s3">,</span>
                                      <span class="s1">exp_digits=self.exp_size)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">dragon4_positional(x</span><span class="s3">,</span>
                                      <span class="s1">precision=self.precision</span><span class="s3">,</span>
                                      <span class="s1">unique=self.unique</span><span class="s3">,</span>
                                      <span class="s1">fractional=</span><span class="s3">True,</span>
                                      <span class="s1">trim=self.trim</span><span class="s3">,</span>
                                      <span class="s1">sign=self.sign == </span><span class="s2">'+'</span><span class="s3">,</span>
                                      <span class="s1">pad_left=self.pad_left</span><span class="s3">,</span>
                                      <span class="s1">pad_right=self.pad_right)</span>


<span class="s1">@set_module(</span><span class="s2">'numpy'</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">format_float_scientific(x</span><span class="s3">, </span><span class="s1">precision=</span><span class="s3">None, </span><span class="s1">unique=</span><span class="s3">True, </span><span class="s1">trim=</span><span class="s2">'k'</span><span class="s3">,</span>
                            <span class="s1">sign=</span><span class="s3">False, </span><span class="s1">pad_left=</span><span class="s3">None, </span><span class="s1">exp_digits=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Format a floating-point scalar as a decimal string in scientific notation. 
 
    Provides control over rounding, trimming and padding. Uses and assumes 
    IEEE unbiased rounding. Uses the &quot;Dragon4&quot; algorithm. 
 
    Parameters 
    ---------- 
    x : python float or numpy floating scalar 
        Value to format. 
    precision : non-negative integer or None, optional 
        Maximum number of digits to print. May be None if `unique` is 
        `True`, but must be an integer if unique is `False`. 
    unique : boolean, optional 
        If `True`, use a digit-generation strategy which gives the shortest 
        representation which uniquely identifies the floating-point number from 
        other values of the same type, by judicious rounding. If `precision` 
        was omitted, print all necessary digits, otherwise digit generation is 
        cut off after `precision` digits and the remaining value is rounded. 
        If `False`, digits are generated as if printing an infinite-precision 
        value and stopping after `precision` digits, rounding the remaining 
        value. 
    trim : one of 'k', '.', '0', '-', optional 
        Controls post-processing trimming of trailing digits, as follows: 
 
        * 'k' : keep trailing zeros, keep decimal point (no trimming) 
        * '.' : trim all trailing zeros, leave decimal point 
        * '0' : trim all but the zero before the decimal point. Insert the 
          zero if it is missing. 
        * '-' : trim trailing zeros and any trailing decimal point 
    sign : boolean, optional 
        Whether to show the sign for positive values. 
    pad_left : non-negative integer, optional 
        Pad the left side of the string with whitespace until at least that 
        many characters are to the left of the decimal point. 
    exp_digits : non-negative integer, optional 
        Pad the exponent with zeros until it contains at least this many digits. 
        If omitted, the exponent will be at least 2 digits. 
 
    Returns 
    ------- 
    rep : string 
        The string representation of the floating point value 
 
    See Also 
    -------- 
    format_float_positional 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.format_float_scientific(np.float32(np.pi)) 
    '3.1415927e+00' 
    &gt;&gt;&gt; s = np.float32(1.23e24) 
    &gt;&gt;&gt; np.format_float_scientific(s, unique=False, precision=15) 
    '1.230000071797338e+24' 
    &gt;&gt;&gt; np.format_float_scientific(s, exp_digits=4) 
    '1.23e+0024' 
    &quot;&quot;&quot;</span>
    <span class="s1">precision = _none_or_positive_arg(precision</span><span class="s3">, </span><span class="s2">'precision'</span><span class="s1">)</span>
    <span class="s1">pad_left = _none_or_positive_arg(pad_left</span><span class="s3">, </span><span class="s2">'pad_left'</span><span class="s1">)</span>
    <span class="s1">exp_digits = _none_or_positive_arg(exp_digits</span><span class="s3">, </span><span class="s2">'exp_digits'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">dragon4_scientific(x</span><span class="s3">, </span><span class="s1">precision=precision</span><span class="s3">, </span><span class="s1">unique=unique</span><span class="s3">,</span>
                              <span class="s1">trim=trim</span><span class="s3">, </span><span class="s1">sign=sign</span><span class="s3">, </span><span class="s1">pad_left=pad_left</span><span class="s3">,</span>
                              <span class="s1">exp_digits=exp_digits)</span>


<span class="s1">@set_module(</span><span class="s2">'numpy'</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">format_float_positional(x</span><span class="s3">, </span><span class="s1">precision=</span><span class="s3">None, </span><span class="s1">unique=</span><span class="s3">True,</span>
                            <span class="s1">fractional=</span><span class="s3">True, </span><span class="s1">trim=</span><span class="s2">'k'</span><span class="s3">, </span><span class="s1">sign=</span><span class="s3">False,</span>
                            <span class="s1">pad_left=</span><span class="s3">None, </span><span class="s1">pad_right=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Format a floating-point scalar as a decimal string in positional notation. 
 
    Provides control over rounding, trimming and padding. Uses and assumes 
    IEEE unbiased rounding. Uses the &quot;Dragon4&quot; algorithm. 
 
    Parameters 
    ---------- 
    x : python float or numpy floating scalar 
        Value to format. 
    precision : non-negative integer or None, optional 
        Maximum number of digits to print. May be None if `unique` is 
        `True`, but must be an integer if unique is `False`. 
    unique : boolean, optional 
        If `True`, use a digit-generation strategy which gives the shortest 
        representation which uniquely identifies the floating-point number from 
        other values of the same type, by judicious rounding. If `precision` 
        was omitted, print out all necessary digits, otherwise digit generation 
        is cut off after `precision` digits and the remaining value is rounded. 
        If `False`, digits are generated as if printing an infinite-precision 
        value and stopping after `precision` digits, rounding the remaining 
        value. 
    fractional : boolean, optional 
        If `True`, the cutoff of `precision` digits refers to the total number 
        of digits after the decimal point, including leading zeros. 
        If `False`, `precision` refers to the total number of significant 
        digits, before or after the decimal point, ignoring leading zeros. 
    trim : one of 'k', '.', '0', '-', optional 
        Controls post-processing trimming of trailing digits, as follows: 
 
        * 'k' : keep trailing zeros, keep decimal point (no trimming) 
        * '.' : trim all trailing zeros, leave decimal point 
        * '0' : trim all but the zero before the decimal point. Insert the 
          zero if it is missing. 
        * '-' : trim trailing zeros and any trailing decimal point 
    sign : boolean, optional 
        Whether to show the sign for positive values. 
    pad_left : non-negative integer, optional 
        Pad the left side of the string with whitespace until at least that 
        many characters are to the left of the decimal point. 
    pad_right : non-negative integer, optional 
        Pad the right side of the string with whitespace until at least that 
        many characters are to the right of the decimal point. 
 
    Returns 
    ------- 
    rep : string 
        The string representation of the floating point value 
 
    See Also 
    -------- 
    format_float_scientific 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.format_float_positional(np.float32(np.pi)) 
    '3.1415927' 
    &gt;&gt;&gt; np.format_float_positional(np.float16(np.pi)) 
    '3.14' 
    &gt;&gt;&gt; np.format_float_positional(np.float16(0.3)) 
    '0.3' 
    &gt;&gt;&gt; np.format_float_positional(np.float16(0.3), unique=False, precision=10) 
    '0.3000488281' 
    &quot;&quot;&quot;</span>
    <span class="s1">precision = _none_or_positive_arg(precision</span><span class="s3">, </span><span class="s2">'precision'</span><span class="s1">)</span>
    <span class="s1">pad_left = _none_or_positive_arg(pad_left</span><span class="s3">, </span><span class="s2">'pad_left'</span><span class="s1">)</span>
    <span class="s1">pad_right = _none_or_positive_arg(pad_right</span><span class="s3">, </span><span class="s2">'pad_right'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">dragon4_positional(x</span><span class="s3">, </span><span class="s1">precision=precision</span><span class="s3">, </span><span class="s1">unique=unique</span><span class="s3">,</span>
                              <span class="s1">fractional=fractional</span><span class="s3">, </span><span class="s1">trim=trim</span><span class="s3">,</span>
                              <span class="s1">sign=sign</span><span class="s3">, </span><span class="s1">pad_left=pad_left</span><span class="s3">,</span>
                              <span class="s1">pad_right=pad_right)</span>


<span class="s3">class </span><span class="s1">IntegerFormat:</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s3">if </span><span class="s1">data.size &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">max_str_len = max(len(str(np.max(data)))</span><span class="s3">,</span>
                              <span class="s1">len(str(np.min(data))))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">max_str_len = </span><span class="s5">0</span>
        <span class="s1">self.format = </span><span class="s2">'%{}d'</span><span class="s1">.format(max_str_len)</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s3">return </span><span class="s1">self.format % x</span>


<span class="s3">class </span><span class="s1">BoolFormat:</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s4"># add an extra space so &quot; True&quot; and &quot;False&quot; have the same length and</span>
        <span class="s4"># array elements align nicely when printed, except in 0d arrays</span>
        <span class="s1">self.truestr = </span><span class="s2">' True' </span><span class="s3">if </span><span class="s1">data.shape != () </span><span class="s3">else </span><span class="s2">'True'</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s3">return </span><span class="s1">self.truestr </span><span class="s3">if </span><span class="s1">x </span><span class="s3">else </span><span class="s2">&quot;False&quot;</span>


<span class="s3">class </span><span class="s1">ComplexFloatingFormat:</span>
    <span class="s0">&quot;&quot;&quot; Formatter for subtypes of np.complexfloating &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">precision</span><span class="s3">, </span><span class="s1">floatmode</span><span class="s3">, </span><span class="s1">suppress_small</span><span class="s3">,</span>
                 <span class="s1">sign=</span><span class="s3">False, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">legacy=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s4"># for backcompatibility, accept bools</span>
        <span class="s3">if </span><span class="s1">isinstance(sign</span><span class="s3">, </span><span class="s1">bool):</span>
            <span class="s1">sign = </span><span class="s2">'+' </span><span class="s3">if </span><span class="s1">sign </span><span class="s3">else </span><span class="s2">'-'</span>

        <span class="s1">floatmode_real = floatmode_imag = floatmode</span>
        <span class="s3">if </span><span class="s1">legacy == </span><span class="s2">'1.13'</span><span class="s1">:</span>
            <span class="s1">floatmode_real = </span><span class="s2">'maxprec_equal'</span>
            <span class="s1">floatmode_imag = </span><span class="s2">'maxprec'</span>

        <span class="s1">self.real_format = FloatingFormat(</span>
            <span class="s1">x.real</span><span class="s3">, </span><span class="s1">precision</span><span class="s3">, </span><span class="s1">floatmode_real</span><span class="s3">, </span><span class="s1">suppress_small</span><span class="s3">,</span>
            <span class="s1">sign=sign</span><span class="s3">, </span><span class="s1">legacy=legacy</span>
        <span class="s1">)</span>
        <span class="s1">self.imag_format = FloatingFormat(</span>
            <span class="s1">x.imag</span><span class="s3">, </span><span class="s1">precision</span><span class="s3">, </span><span class="s1">floatmode_imag</span><span class="s3">, </span><span class="s1">suppress_small</span><span class="s3">,</span>
            <span class="s1">sign=</span><span class="s2">'+'</span><span class="s3">, </span><span class="s1">legacy=legacy</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s1">r = self.real_format(x.real)</span>
        <span class="s1">i = self.imag_format(x.imag)</span>

        <span class="s4"># add the 'j' before the terminal whitespace in i</span>
        <span class="s1">sp = len(i.rstrip())</span>
        <span class="s1">i = i[:sp] + </span><span class="s2">'j' </span><span class="s1">+ i[sp:]</span>

        <span class="s3">return </span><span class="s1">r + i</span>


<span class="s3">class </span><span class="s1">_TimelikeFormat:</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s1">non_nat = data[~isnat(data)]</span>
        <span class="s3">if </span><span class="s1">len(non_nat) &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s4"># Max str length of non-NaT elements</span>
            <span class="s1">max_str_len = max(len(self._format_non_nat(np.max(non_nat)))</span><span class="s3">,</span>
                              <span class="s1">len(self._format_non_nat(np.min(non_nat))))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">max_str_len = </span><span class="s5">0</span>
        <span class="s3">if </span><span class="s1">len(non_nat) &lt; data.size:</span>
            <span class="s4"># data contains a NaT</span>
            <span class="s1">max_str_len = max(max_str_len</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span>
        <span class="s1">self._format = </span><span class="s2">'%{}s'</span><span class="s1">.format(max_str_len)</span>
        <span class="s1">self._nat = </span><span class="s2">&quot;'NaT'&quot;</span><span class="s1">.rjust(max_str_len)</span>

    <span class="s3">def </span><span class="s1">_format_non_nat(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s4"># override in subclass</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s3">if </span><span class="s1">isnat(x):</span>
            <span class="s3">return </span><span class="s1">self._nat</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._format % self._format_non_nat(x)</span>


<span class="s3">class </span><span class="s1">DatetimeFormat(_TimelikeFormat):</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">unit=</span><span class="s3">None, </span><span class="s1">timezone=</span><span class="s3">None, </span><span class="s1">casting=</span><span class="s2">'same_kind'</span><span class="s3">,</span>
                 <span class="s1">legacy=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s4"># Get the unit from the dtype</span>
        <span class="s3">if </span><span class="s1">unit </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">x.dtype.kind == </span><span class="s2">'M'</span><span class="s1">:</span>
                <span class="s1">unit = datetime_data(x.dtype)[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">unit = </span><span class="s2">'s'</span>

        <span class="s3">if </span><span class="s1">timezone </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">timezone = </span><span class="s2">'naive'</span>
        <span class="s1">self.timezone = timezone</span>
        <span class="s1">self.unit = unit</span>
        <span class="s1">self.casting = casting</span>
        <span class="s1">self.legacy = legacy</span>

        <span class="s4"># must be called after the above are configured</span>
        <span class="s1">super(DatetimeFormat</span><span class="s3">, </span><span class="s1">self).__init__(x)</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s3">if </span><span class="s1">self.legacy == </span><span class="s2">'1.13'</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._format_non_nat(x)</span>
        <span class="s3">return </span><span class="s1">super(DatetimeFormat</span><span class="s3">, </span><span class="s1">self).__call__(x)</span>

    <span class="s3">def </span><span class="s1">_format_non_nat(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s3">return </span><span class="s2">&quot;'%s'&quot; </span><span class="s1">% datetime_as_string(x</span><span class="s3">,</span>
                                    <span class="s1">unit=self.unit</span><span class="s3">,</span>
                                    <span class="s1">timezone=self.timezone</span><span class="s3">,</span>
                                    <span class="s1">casting=self.casting)</span>


<span class="s3">class </span><span class="s1">TimedeltaFormat(_TimelikeFormat):</span>
    <span class="s3">def </span><span class="s1">_format_non_nat(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s3">return </span><span class="s1">str(x.astype(</span><span class="s2">'i8'</span><span class="s1">))</span>


<span class="s3">class </span><span class="s1">SubArrayFormat:</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">format_function):</span>
        <span class="s1">self.format_function = format_function</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">arr):</span>
        <span class="s3">if </span><span class="s1">arr.ndim &lt;= </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s2">&quot;[&quot; </span><span class="s1">+ </span><span class="s2">&quot;, &quot;</span><span class="s1">.join(self.format_function(a) </span><span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">arr) + </span><span class="s2">&quot;]&quot;</span>
        <span class="s3">return </span><span class="s2">&quot;[&quot; </span><span class="s1">+ </span><span class="s2">&quot;, &quot;</span><span class="s1">.join(self.__call__(a) </span><span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">arr) + </span><span class="s2">&quot;]&quot;</span>


<span class="s3">class </span><span class="s1">StructuredVoidFormat:</span>
    <span class="s0">&quot;&quot;&quot; 
    Formatter for structured np.void objects. 
 
    This does not work on structured alias types like np.dtype(('i4', 'i2,i2')), 
    as alias scalars lose their field information, and the implementation 
    relies upon np.void.__getitem__. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">format_functions):</span>
        <span class="s1">self.format_functions = format_functions</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">from_data(cls</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">**options):</span>
        <span class="s0">&quot;&quot;&quot; 
        This is a second way to initialize StructuredVoidFormat, using the raw data 
        as input. Added to avoid changing the signature of __init__. 
        &quot;&quot;&quot;</span>
        <span class="s1">format_functions = []</span>
        <span class="s3">for </span><span class="s1">field_name </span><span class="s3">in </span><span class="s1">data.dtype.names:</span>
            <span class="s1">format_function = _get_format_function(data[field_name]</span><span class="s3">, </span><span class="s1">**options)</span>
            <span class="s3">if </span><span class="s1">data.dtype[field_name].shape != ():</span>
                <span class="s1">format_function = SubArrayFormat(format_function)</span>
            <span class="s1">format_functions.append(format_function)</span>
        <span class="s3">return </span><span class="s1">cls(format_functions)</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s1">str_fields = [</span>
            <span class="s1">format_function(field)</span>
            <span class="s3">for </span><span class="s1">field</span><span class="s3">, </span><span class="s1">format_function </span><span class="s3">in </span><span class="s1">zip(x</span><span class="s3">, </span><span class="s1">self.format_functions)</span>
        <span class="s1">]</span>
        <span class="s3">if </span><span class="s1">len(str_fields) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s2">&quot;({},)&quot;</span><span class="s1">.format(str_fields[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s2">&quot;({})&quot;</span><span class="s1">.format(</span><span class="s2">&quot;, &quot;</span><span class="s1">.join(str_fields))</span>


<span class="s3">def </span><span class="s1">_void_scalar_repr(x):</span>
    <span class="s0">&quot;&quot;&quot; 
    Implements the repr for structured-void scalars. It is called from the 
    scalartypes.c.src code, and is placed here because it uses the elementwise 
    formatters defined above. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">StructuredVoidFormat.from_data(array(x)</span><span class="s3">, </span><span class="s1">**_format_options)(x)</span>


<span class="s1">_typelessdata = [int_</span><span class="s3">, </span><span class="s1">float_</span><span class="s3">, </span><span class="s1">complex_</span><span class="s3">, </span><span class="s1">bool_]</span>
<span class="s3">if </span><span class="s1">issubclass(intc</span><span class="s3">, </span><span class="s1">int):</span>
    <span class="s1">_typelessdata.append(intc)</span>
<span class="s3">if </span><span class="s1">issubclass(longlong</span><span class="s3">, </span><span class="s1">int):</span>
    <span class="s1">_typelessdata.append(longlong)</span>


<span class="s3">def </span><span class="s1">dtype_is_implied(dtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    Determine if the given dtype is implied by the representation of its values. 
 
    Parameters 
    ---------- 
    dtype : dtype 
        Data type 
 
    Returns 
    ------- 
    implied : bool 
        True if the dtype is implied by the representation of its values. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.core.arrayprint.dtype_is_implied(int) 
    True 
    &gt;&gt;&gt; np.array([1, 2, 3], int) 
    array([1, 2, 3]) 
    &gt;&gt;&gt; np.core.arrayprint.dtype_is_implied(np.int8) 
    False 
    &gt;&gt;&gt; np.array([1, 2, 3], np.int8) 
    array([1, 2, 3], dtype=int8) 
    &quot;&quot;&quot;</span>
    <span class="s1">dtype = np.dtype(dtype)</span>
    <span class="s3">if </span><span class="s1">_format_options[</span><span class="s2">'legacy'</span><span class="s1">] == </span><span class="s2">'1.13' </span><span class="s3">and </span><span class="s1">dtype.type == bool_:</span>
        <span class="s3">return False</span>

    <span class="s4"># not just void types can be structured, and names are not part of the repr</span>
    <span class="s3">if </span><span class="s1">dtype.names </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s3">return False</span>

    <span class="s3">return </span><span class="s1">dtype.type </span><span class="s3">in </span><span class="s1">_typelessdata</span>


<span class="s3">def </span><span class="s1">dtype_short_repr(dtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert a dtype to a short form which evaluates to the same dtype. 
 
    The intent is roughly that the following holds 
 
    &gt;&gt;&gt; from numpy import * 
    &gt;&gt;&gt; dt = np.int64([1, 2]).dtype 
    &gt;&gt;&gt; assert eval(dtype_short_repr(dt)) == dt 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">dtype.names </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s4"># structured dtypes give a list or tuple repr</span>
        <span class="s3">return </span><span class="s1">str(dtype)</span>
    <span class="s3">elif </span><span class="s1">issubclass(dtype.type</span><span class="s3">, </span><span class="s1">flexible):</span>
        <span class="s4"># handle these separately so they don't give garbage like str256</span>
        <span class="s3">return </span><span class="s2">&quot;'%s'&quot; </span><span class="s1">% str(dtype)</span>

    <span class="s1">typename = dtype.name</span>
    <span class="s4"># quote typenames which can't be represented as python variable names</span>
    <span class="s3">if </span><span class="s1">typename </span><span class="s3">and not </span><span class="s1">(typename[</span><span class="s5">0</span><span class="s1">].isalpha() </span><span class="s3">and </span><span class="s1">typename.isalnum()):</span>
        <span class="s1">typename = repr(typename)</span>

    <span class="s3">return </span><span class="s1">typename</span>


<span class="s3">def </span><span class="s1">_array_repr_implementation(</span>
        <span class="s1">arr</span><span class="s3">, </span><span class="s1">max_line_width=</span><span class="s3">None, </span><span class="s1">precision=</span><span class="s3">None, </span><span class="s1">suppress_small=</span><span class="s3">None,</span>
        <span class="s1">array2string=array2string):</span>
    <span class="s0">&quot;&quot;&quot;Internal version of array_repr() that allows overriding array2string.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">max_line_width </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">max_line_width = _format_options[</span><span class="s2">'linewidth'</span><span class="s1">]</span>

    <span class="s3">if </span><span class="s1">type(arr) </span><span class="s3">is not </span><span class="s1">ndarray:</span>
        <span class="s1">class_name = type(arr).__name__</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">class_name = </span><span class="s2">&quot;array&quot;</span>

    <span class="s1">skipdtype = dtype_is_implied(arr.dtype) </span><span class="s3">and </span><span class="s1">arr.size &gt; </span><span class="s5">0</span>

    <span class="s1">prefix = class_name + </span><span class="s2">&quot;(&quot;</span>
    <span class="s1">suffix = </span><span class="s2">&quot;)&quot; </span><span class="s3">if </span><span class="s1">skipdtype </span><span class="s3">else </span><span class="s2">&quot;,&quot;</span>

    <span class="s3">if </span><span class="s1">(_format_options[</span><span class="s2">'legacy'</span><span class="s1">] == </span><span class="s2">'1.13' </span><span class="s3">and</span>
            <span class="s1">arr.shape == () </span><span class="s3">and not </span><span class="s1">arr.dtype.names):</span>
        <span class="s1">lst = repr(arr.item())</span>
    <span class="s3">elif </span><span class="s1">arr.size &gt; </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">arr.shape == (</span><span class="s5">0</span><span class="s3">,</span><span class="s1">):</span>
        <span class="s1">lst = array2string(arr</span><span class="s3">, </span><span class="s1">max_line_width</span><span class="s3">, </span><span class="s1">precision</span><span class="s3">, </span><span class="s1">suppress_small</span><span class="s3">,</span>
                           <span class="s2">', '</span><span class="s3">, </span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">suffix=suffix)</span>
    <span class="s3">else</span><span class="s1">:  </span><span class="s4"># show zero-length shape unless it is (0,)</span>
        <span class="s1">lst = </span><span class="s2">&quot;[], shape=%s&quot; </span><span class="s1">% (repr(arr.shape)</span><span class="s3">,</span><span class="s1">)</span>

    <span class="s1">arr_str = prefix + lst + suffix</span>

    <span class="s3">if </span><span class="s1">skipdtype:</span>
        <span class="s3">return </span><span class="s1">arr_str</span>

    <span class="s1">dtype_str = </span><span class="s2">&quot;dtype={})&quot;</span><span class="s1">.format(dtype_short_repr(arr.dtype))</span>

    <span class="s4"># compute whether we should put dtype on a new line: Do so if adding the</span>
    <span class="s4"># dtype would extend the last line past max_line_width.</span>
    <span class="s4"># Note: This line gives the correct result even when rfind returns -1.</span>
    <span class="s1">last_line_len = len(arr_str) - (arr_str.rfind(</span><span class="s2">'</span><span class="s3">\n</span><span class="s2">'</span><span class="s1">) + </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">spacer = </span><span class="s2">&quot; &quot;</span>
    <span class="s3">if </span><span class="s1">_format_options[</span><span class="s2">'legacy'</span><span class="s1">] == </span><span class="s2">'1.13'</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">issubclass(arr.dtype.type</span><span class="s3">, </span><span class="s1">flexible):</span>
            <span class="s1">spacer = </span><span class="s2">'</span><span class="s3">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">' '</span><span class="s1">*len(class_name + </span><span class="s2">&quot;(&quot;</span><span class="s1">)</span>
    <span class="s3">elif </span><span class="s1">last_line_len + len(dtype_str) + </span><span class="s5">1 </span><span class="s1">&gt; max_line_width:</span>
        <span class="s1">spacer = </span><span class="s2">'</span><span class="s3">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">' '</span><span class="s1">*len(class_name + </span><span class="s2">&quot;(&quot;</span><span class="s1">)</span>

    <span class="s3">return </span><span class="s1">arr_str + spacer + dtype_str</span>


<span class="s3">def </span><span class="s1">_array_repr_dispatcher(</span>
        <span class="s1">arr</span><span class="s3">, </span><span class="s1">max_line_width=</span><span class="s3">None, </span><span class="s1">precision=</span><span class="s3">None, </span><span class="s1">suppress_small=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s3">return </span><span class="s1">(arr</span><span class="s3">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_array_repr_dispatcher</span><span class="s3">, </span><span class="s1">module=</span><span class="s2">'numpy'</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">array_repr(arr</span><span class="s3">, </span><span class="s1">max_line_width=</span><span class="s3">None, </span><span class="s1">precision=</span><span class="s3">None, </span><span class="s1">suppress_small=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the string representation of an array. 
 
    Parameters 
    ---------- 
    arr : ndarray 
        Input array. 
    max_line_width : int, optional 
        Inserts newlines if text is longer than `max_line_width`. 
        Defaults to ``numpy.get_printoptions()['linewidth']``. 
    precision : int, optional 
        Floating point precision. 
        Defaults to ``numpy.get_printoptions()['precision']``. 
    suppress_small : bool, optional 
        Represent numbers &quot;very close&quot; to zero as zero; default is False. 
        Very close is defined by precision: if the precision is 8, e.g., 
        numbers smaller (in absolute value) than 5e-9 are represented as 
        zero. 
        Defaults to ``numpy.get_printoptions()['suppress']``. 
 
    Returns 
    ------- 
    string : str 
      The string representation of an array. 
 
    See Also 
    -------- 
    array_str, array2string, set_printoptions 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.array_repr(np.array([1,2])) 
    'array([1, 2])' 
    &gt;&gt;&gt; np.array_repr(np.ma.array([0.])) 
    'MaskedArray([0.])' 
    &gt;&gt;&gt; np.array_repr(np.array([], np.int32)) 
    'array([], dtype=int32)' 
 
    &gt;&gt;&gt; x = np.array([1e-6, 4e-7, 2, 3]) 
    &gt;&gt;&gt; np.array_repr(x, precision=6, suppress_small=True) 
    'array([0.000001,  0.      ,  2.      ,  3.      ])' 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_array_repr_implementation(</span>
        <span class="s1">arr</span><span class="s3">, </span><span class="s1">max_line_width</span><span class="s3">, </span><span class="s1">precision</span><span class="s3">, </span><span class="s1">suppress_small)</span>


<span class="s1">@_recursive_guard()</span>
<span class="s3">def </span><span class="s1">_guarded_repr_or_str(v):</span>
    <span class="s3">if </span><span class="s1">isinstance(v</span><span class="s3">, </span><span class="s1">bytes):</span>
        <span class="s3">return </span><span class="s1">repr(v)</span>
    <span class="s3">return </span><span class="s1">str(v)</span>


<span class="s3">def </span><span class="s1">_array_str_implementation(</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">max_line_width=</span><span class="s3">None, </span><span class="s1">precision=</span><span class="s3">None, </span><span class="s1">suppress_small=</span><span class="s3">None,</span>
        <span class="s1">array2string=array2string):</span>
    <span class="s0">&quot;&quot;&quot;Internal version of array_str() that allows overriding array2string.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">(_format_options[</span><span class="s2">'legacy'</span><span class="s1">] == </span><span class="s2">'1.13' </span><span class="s3">and</span>
            <span class="s1">a.shape == () </span><span class="s3">and not </span><span class="s1">a.dtype.names):</span>
        <span class="s3">return </span><span class="s1">str(a.item())</span>

    <span class="s4"># the str of 0d arrays is a special case: It should appear like a scalar,</span>
    <span class="s4"># so floats are not truncated by `precision`, and strings are not wrapped</span>
    <span class="s4"># in quotes. So we return the str of the scalar value.</span>
    <span class="s3">if </span><span class="s1">a.shape == ():</span>
        <span class="s4"># obtain a scalar and call str on it, avoiding problems for subclasses</span>
        <span class="s4"># for which indexing with () returns a 0d instead of a scalar by using</span>
        <span class="s4"># ndarray's getindex. Also guard against recursive 0d object arrays.</span>
        <span class="s3">return </span><span class="s1">_guarded_repr_or_str(np.ndarray.__getitem__(a</span><span class="s3">, </span><span class="s1">()))</span>

    <span class="s3">return </span><span class="s1">array2string(a</span><span class="s3">, </span><span class="s1">max_line_width</span><span class="s3">, </span><span class="s1">precision</span><span class="s3">, </span><span class="s1">suppress_small</span><span class="s3">, </span><span class="s2">' '</span><span class="s3">, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">_array_str_dispatcher(</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">max_line_width=</span><span class="s3">None, </span><span class="s1">precision=</span><span class="s3">None, </span><span class="s1">suppress_small=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s3">return </span><span class="s1">(a</span><span class="s3">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_array_str_dispatcher</span><span class="s3">, </span><span class="s1">module=</span><span class="s2">'numpy'</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">array_str(a</span><span class="s3">, </span><span class="s1">max_line_width=</span><span class="s3">None, </span><span class="s1">precision=</span><span class="s3">None, </span><span class="s1">suppress_small=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a string representation of the data in an array. 
 
    The data in the array is returned as a single string.  This function is 
    similar to `array_repr`, the difference being that `array_repr` also 
    returns information on the kind of array and its data type. 
 
    Parameters 
    ---------- 
    a : ndarray 
        Input array. 
    max_line_width : int, optional 
        Inserts newlines if text is longer than `max_line_width`. 
        Defaults to ``numpy.get_printoptions()['linewidth']``. 
    precision : int, optional 
        Floating point precision. 
        Defaults to ``numpy.get_printoptions()['precision']``. 
    suppress_small : bool, optional 
        Represent numbers &quot;very close&quot; to zero as zero; default is False. 
        Very close is defined by precision: if the precision is 8, e.g., 
        numbers smaller (in absolute value) than 5e-9 are represented as 
        zero. 
        Defaults to ``numpy.get_printoptions()['suppress']``. 
 
    See Also 
    -------- 
    array2string, array_repr, set_printoptions 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.array_str(np.arange(3)) 
    '[0 1 2]' 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_array_str_implementation(</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">max_line_width</span><span class="s3">, </span><span class="s1">precision</span><span class="s3">, </span><span class="s1">suppress_small)</span>


<span class="s4"># needed if __array_function__ is disabled</span>
<span class="s1">_array2string_impl = getattr(array2string</span><span class="s3">, </span><span class="s2">'__wrapped__'</span><span class="s3">, </span><span class="s1">array2string)</span>
<span class="s1">_default_array_str = functools.partial(_array_str_implementation</span><span class="s3">,</span>
                                       <span class="s1">array2string=_array2string_impl)</span>
<span class="s1">_default_array_repr = functools.partial(_array_repr_implementation</span><span class="s3">,</span>
                                        <span class="s1">array2string=_array2string_impl)</span>


<span class="s3">def </span><span class="s1">set_string_function(f</span><span class="s3">, </span><span class="s1">repr=</span><span class="s3">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Set a Python function to be used when pretty printing arrays. 
 
    Parameters 
    ---------- 
    f : function or None 
        Function to be used to pretty print arrays. The function should expect 
        a single array argument and return a string of the representation of 
        the array. If None, the function is reset to the default NumPy function 
        to print arrays. 
    repr : bool, optional 
        If True (default), the function for pretty printing (``__repr__``) 
        is set, if False the function that returns the default string 
        representation (``__str__``) is set. 
 
    See Also 
    -------- 
    set_printoptions, get_printoptions 
 
    Examples 
    -------- 
    &gt;&gt;&gt; def pprint(arr): 
    ...     return 'HA! - What are you going to do now?' 
    ... 
    &gt;&gt;&gt; np.set_string_function(pprint) 
    &gt;&gt;&gt; a = np.arange(10) 
    &gt;&gt;&gt; a 
    HA! - What are you going to do now? 
    &gt;&gt;&gt; _ = a 
    &gt;&gt;&gt; # [0 1 2 3 4 5 6 7 8 9] 
 
    We can reset the function to the default: 
 
    &gt;&gt;&gt; np.set_string_function(None) 
    &gt;&gt;&gt; a 
    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 
 
    `repr` affects either pretty printing or normal string representation. 
    Note that ``__repr__`` is still affected by setting ``__str__`` 
    because the width of each array element in the returned string becomes 
    equal to the length of the result of ``__str__()``. 
 
    &gt;&gt;&gt; x = np.arange(4) 
    &gt;&gt;&gt; np.set_string_function(lambda x:'random', repr=False) 
    &gt;&gt;&gt; x.__str__() 
    'random' 
    &gt;&gt;&gt; x.__repr__() 
    'array([0, 1, 2, 3])' 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">f </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">repr:</span>
            <span class="s3">return </span><span class="s1">multiarray.set_string_function(_default_array_repr</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">multiarray.set_string_function(_default_array_str</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">multiarray.set_string_function(f</span><span class="s3">, </span><span class="s1">repr)</span>
</pre>
</body>
</html>